
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>小巴童鞋</title>
	<meta name="author" content="小巴">

	
	<meta name="description" content="Nov 27,&nbsp 2014 swift Comments Swift闭包 闭包是自包含的函数代码块，可以在代码中被传递和使用。
Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 lambdas 函数比较相似。 &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="小巴童鞋" type="application/atom+xml">
	
	<link rel="canonical" href="http://baxiang123.com//pages/2/index.html">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
	<link href="/stylesheets/google-fonts.css" rel="stylesheet" type="text/css">
	
	<meta name="baidu-site-verification" content="6a14c2aa1891f60e94e78134679099cd"/>
<meta name="baidu-site-verification" content="tXGpoDjJRv" />
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?d811e8c9d300f1af279a81ea7923be4d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script type="text/javascript">
 function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
 $(document).bind('DOMNodeInserted', function(event) {
  addBlankTargetForLinks();
 });
 </script>
 
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script async src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='/images/xiaoba.png' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1>&nbsp;&nbsp;<a href="/">小巴童鞋</a></h1>
<p class="subtitle">BaXiang&#8217;s technology blog</p>
<nav id="main-nav"><!--ul class="main">
    <nav id="main-nav">
		<li><a href="/">Home</a></li>
		<li><a href="/blog/archives">Blogs</a></li>
		<li><a href="#">About</a></li>
    </nav> 
</ul><!-->
<ul class="main-navigation">
  <li><a href="/">Blog | 博客</a></li>
  <li><a href="/blog/archives">Archives | 目录</a></li>
  <li><a href="/blog/categories">Categories  | 分类</a></li>
  <li><a href="/aboutme/">About Me | 关于</a></li>
  
</ul>

</nav>
<nav id="sub-nav">
	<br/>
	<div class="social">
        
            <a class="weibo" href="http://www.weibo.com/1655203353" title="Weibo" target="_blank">Weibo</a>
        
		
		
			<a class="facebook" href="http://www.facebook.com/xiang.ba.1" title="Facebook">Facebook</a>
		
		
		
			<a class="twitter" href="http://twitter.com/baxiang2014" title="Twitter">Twitter</a>
		
		
			<a class="github" href="https://github.com/baxiang" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E9%97%AD%E5%8C%85.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E9%97%AD%E5%8C%85.html" itemprop="url">Swift闭包</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。
Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 lambdas 函数比较相似。</p>


<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。
这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。</p>


<blockquote>
<p>注意：</p>
<p>如果您不熟悉捕获（capturing）这个概念也不用担心，您可以在 <a href="#capturing_values">值捕获</a> 章节对其进行详细了解。</p>
</blockquote>


<p>在<a href="../chapter2/06_Function.html">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：</p>


<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>


<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>


<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随（Trailing）闭包语法</li>
</ul>


<p><a name="closure_expressions"></a></p>


<h2 id="-closure-expressions-">闭包表达式（Closure Expressions）</h2>


<p><a href="../chapter2/06_Function.html#nested_function">嵌套函数</a> 是一个在较复杂函数中方便进行命名和定义自包含代码模块的方式。
当然，有时候撰写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在您处理一些函数并需要将另外一些函数作为该函数的参数时。</p>


<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。
闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。
下面闭包表达式的例子通过使用几次迭代展示了<code>sort</code>函数定义和语法优化的方式。
每一次迭代都用更简洁的方式描述了相同的功能。</p>


<p><a name="the_sort_function"></a></p>


<h3 id="sort-the-sort-function-">sort 函数（The Sort Function）</h3>


<p>Swift 标准库提供了<code>sort</code>函数，会根据您提供的基于输出类型排序的闭包函数将已知类型数组中的值进行排序。
一旦排序完成，函数会返回一个与原数组大小相同的新数组，该数组中包含已经正确排序的同类型元素。</p>


<p>下面的闭包表达式示例使用<code>sort</code>函数对一个<code>String</code>类型的数组进行字母逆序排序，以下是初始数组值：</p>


<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</code></pre>


<p><code>sort</code>函数需要传入两个参数：</p>


<ul>
<li>已知类型的数组</li>
<li>闭包函数，该闭包函数需要传入与数组类型相同的两个值，并返回一个布尔类型值来告诉<code>sort</code>函数当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回<code>true</code>，反之返回<code>false</code>。</li>
</ul>


<p>该例子对一个<code>String</code>类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p>


<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为<code>sort</code>函数的第二个参数传入：</p>


<pre><code>func backwards(s1: String, s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversed = sort(names, backwards)
// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
</code></pre>


<p>如果第一个字符串 (<code>s1</code>) 大于第二个字符串 (<code>s2</code>)，<code>backwards</code>函数返回<code>true</code>，表示在新的数组中<code>s1</code>应该出现在<code>s2</code>前。
对于字符串中的字符来说，“大于” 表示 “按照字母顺序较晚出现”。
这意味着字母<code>"B"</code>大于字母<code>"A"</code>，字符串<code>"Tom"</code>大于字符串<code>"Tim"</code>。
其将进行字母逆序排序，<code>"Barry"</code>将会排在<code>"Alex"</code>之后。</p>


<p>然而，这是一个相当冗长的方式，本质上只是写了一个单表达式函数 (a &gt; b)。
在下面的例子中，利用闭合表达式语法可以更好的构造一个内联排序闭包。</p>


<p><a name="closure_expression_syntax"></a></p>


<h3 id="-closure-expression-syntax-">闭包表达式语法（Closure Expression Syntax）</h3>


<p>闭包表达式语法有如下一般形式：</p>


<pre><code>{ (parameters) -&gt; returnType in
    statements
}
</code></pre>


<p>闭包表达式语法可以使用常量、变量和<code>inout</code>类型作为参数，不提供默认值。
也可以在参数列表的最后使用可变参数。
元组也可以作为参数和返回值。</p>


<p>下面的例子展示了之前<code>backwards</code>函数对应的闭包表达式版本的代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
    })
</code></pre>


<p>需要注意的是内联闭包参数和返回值类型声明与<code>backwards</code>函数类型声明相同。
在这两种方式中，都写成了<code>(s1: String, s2: String) -&gt; Bool</code>。
然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>


<p>闭包的函数体部分由关键字<code>in</code>引入。
该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>


<p>因为这个闭包的函数体部分如此短以至于可以将其改写成一行代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )
</code></pre>


<p>这说明<code>sort</code>函数的整体调用保持不变，一对圆括号仍然包裹住了函数中整个参数集合。而其中一个参数现在变成了内联闭包（相比于<code>backwards</code>版本的代码）。</p>


<p><a name="inferring_type_from_context"></a></p>


<h3 id="-inferring-type-from-context-">根据上下文推断类型（Inferring Type From Context）</h3>


<p>因为排序闭包函数是作为<code>sort</code>函数的参数进行传入的，Swift可以推断其参数和返回值的类型。
<code>sort</code>期望第二个参数是类型为<code>(String, String) -&gt; Bool</code>的函数，因此实际上<code>String</code>,<code>String</code>和<code>Bool</code>类型并不需要作为闭包表达式定义中的一部分。
因为所有的类型都可以被正确推断，返回箭头 (<code>-&gt;</code>) 和围绕在参数周围的括号也可以被省略：</p>


<pre><code>reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )
</code></pre>


<p>实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数时，都可以推断出闭包的参数和返回值类型，这意味着您几乎不需要利用完整格式构造任何内联闭包。</p>


<p><a name="implicit_returns_from_single_expression_closures"></a></p>


<h3 id="-implicit-return-from-single-expression-clossures-">单表达式闭包隐式返回（Implicit Return From Single-Expression Clossures）</h3>


<p>单行表达式闭包可以通过隐藏<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>


<pre><code>reversed = sort(names, { s1, s2 in s1 &gt; s2 } )
</code></pre>


<p>在这个例子中，<code>sort</code>函数的第二个参数函数类型明确了闭包必须返回一个<code>Bool</code>类型值。
因为闭包函数体只包含了一个单一表达式 (<code>s1 &gt; s2</code>)，该表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略。</p>


<p><a name="shorthand_argument_names"></a></p>


<h3 id="-shorthand-argument-names-">参数名称缩写（Shorthand Argument Names）</h3>


<p>Swift 自动为内联函数提供了参数名称缩写功能，您可以直接通过<code>$0</code>,<code>$1</code>,<code>$2</code>来顺序调用闭包的参数。</p>


<p>如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。
<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>


<pre><code>reversed = sort(names, { $0 &gt; $1 } )
</code></pre>


<p>在这个例子中，<code>$0</code>和<code>$1</code>表示闭包中第一个和第二个<code>String</code>类型的参数。</p>


<p><a name="operator_functions"></a></p>


<h3 id="-operator-functions-">运算符函数（Operator Functions）</h3>


<p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。
Swift 的<code>String</code>类型定义了关于大于号 (<code>&gt;</code>) 的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。
而这正好与<code>sort</code>函数的第二个参数需要的函数类型相符合。
因此，您可以简单地传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现：</p>


<pre><code>reversed = sort(names, &gt;)
</code></pre>


<p>更多关于运算符表达式的内容请查看 <a href="../chapter2/23_Advanced_Operators.html#operator_functions">运算符函数</a>。</p>


<p><a name="trailing_closures"></a></p>


<h2 id="-trailing-closures-">尾随闭包（Trailing Closures）</h2>


<p>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。
尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</p>


<pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; ()) {
    // 函数体部分
}

// 以下是不使用尾随闭包进行函数调用

someFunctionThatTakesAClosure({
    // 闭包主体部分
    })

// 以下是使用尾随闭包进行函数调用

someFunctionThatTakesAClosure() {
    // 闭包主体部分
}
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把<code>()</code>省略掉。</p>
</blockquote>


<p>在上例中作为<code>sort</code>函数参数的字符串排序闭包可以改写为：</p>


<pre><code>reversed = sort(names) { $0 &gt; $1 }
</code></pre>


<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。
举例来说，Swift 的<code>Array</code>类型有一个<code>map</code>方法，其获取一个闭包表达式作为其唯一参数。
数组中的每一个元素调用一次该闭包函数，并返回该元素所映射的值(也可以是不同类型的值)。
具体的映射方式和返回值类型由闭包来指定。</p>


<p>当提供给数组闭包函数后，<code>map</code>方法将返回一个新的数组，数组中包含了与原数组一一对应的映射后的值。</p>


<p>下例介绍了如何在<code>map</code>方法中使用尾随闭包将<code>Int</code>类型数组<code>[16,58,510]</code>转换为包含对应<code>String</code>类型的数组<code>["OneSix", "FiveEight", "FiveOneZero"]</code>:</p>


<pre><code>let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
</code></pre>


<p>如上代码创建了一个数字位和他们名字映射的英文版本字典。
同时定义了一个准备转换为字符串的整型数组。</p>


<p>您现在可以通过传递一个尾随闭包给<code>numbers</code>的<code>map</code>方法来创建对应的字符串版本数组。
需要注意的时调用<code>numbers.map</code>不需要在<code>map</code>后面包含任何括号，因为其只需要传递闭包表达式这一个参数，并且该闭包表达式参数通过尾随方式进行撰写：</p>


<pre><code>let strings = numbers.map {
    (var number) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
// strings 常量被推断为字符串类型数组，即 String[]
// 其值为 ["OneSix", "FiveEight", "FiveOneZero"]
</code></pre>


<p><code>map</code>在数组中为每一个元素调用了闭包表达式。
您不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行推断。</p>


<p>闭包<code>number</code>参数被声明为一个变量参数（变量的具体描述请参看<a href="../chapter2/06_Functions.html#closure_expression_syntax">常量参数和变量参数</a>），因此可以在闭包函数体内对其进行修改。
闭包表达式制定了返回类型为<code>String</code>，以表明存储映射值的新数组类型为<code>String</code>。</p>


<p>闭包表达式在每次被调用的时候创建了一个字符串并返回。
其使用求余运算符 (number % 10) 计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。</p>


<blockquote>
<p>注意：</p>
<p>字典<code>digitNames</code>下标后跟着一个叹号 (!)，因为字典下标返回一个可选值 (optional value)，表明即使该 key 不存在也不会查找失败。
在上例中，它保证了<code>number % 10</code>可以总是作为一个<code>digitNames</code>字典的有效下标 key。
因此叹号可以用于强制解析 (force-unwrap) 存储在可选下标项中的<code>String</code>类型值。</p>
</blockquote>


<p>从<code>digitNames</code>字典中获取的字符串被添加到输出的前部，逆序建立了一个字符串版本的数字。
（在表达式<code>number % 10</code>中，如果number为16，则返回6，58返回8，510返回0）。</p>


<p><code>number</code>变量之后除以10。
因为其是整数，在计算过程中未除尽部分被忽略。
因此 16变成了1，58变成了5，510变成了51。</p>


<p>整个过程重复进行，直到<code>number /= 10</code>为0，这时闭包会将字符串输出，而<code>map</code>函数则会将字符串添加到所映射的数组中。</p>


<p>上例中尾随闭包语法在函数后整洁封装了具体的闭包功能，而不再需要将整个闭包包裹在<code>map</code>函数的括号内。</p>


<p><a name="capturing_values"></a></p>


<h2 id="-capturing-values-">捕获值（Capturing Values）</h2>


<p>闭包可以在其定义的上下文中捕获常量或变量。
即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>


<p>Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>


<p>下例为一个叫做<code>makeIncrementor</code>的函数，其包含了一个叫做<code>incrementor</code>嵌套函数。
嵌套函数<code>incrementor</code>从上下文中捕获了两个值，<code>runningTotal</code>和<code>amount</code>。
之后<code>makeIncrementor</code>将<code>incrementor</code>作为闭包返回。
每次调用<code>incrementor</code>时，其会以<code>amount</code>作为增量增加<code>runningTotal</code>的值。</p>


<pre><code>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}
</code></pre>


<p><code>makeIncrementor</code>返回类型为<code>() -&gt; Int</code>。
这意味着其返回的是一个函数，而不是一个简单类型值。
该函数在每次调用时不接受参数只返回一个<code>Int</code>类型的值。
关于函数返回其他函数的内容，请查看<a href="../chapter2/06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>


<p><code>makeIncrementor</code>函数定义了一个整型变量<code>runningTotal</code>(初始为0) 用来存储当前跑步总数。
该值通过<code>incrementor</code>返回。</p>


<p><code>makeIncrementor</code>有一个<code>Int</code>类型的参数，其外部命名为<code>forIncrement</code>， 内部命名为<code>amount</code>，表示每次<code>incrementor</code>被调用时<code>runningTotal</code>将要增加的量。</p>


<p><code>incrementor</code>函数用来执行实际的增加操作。
该函数简单地使<code>runningTotal</code>增加<code>amount</code>，并将其返回。</p>


<p>如果我们单独看这个函数，会发现看上去不同寻常：</p>


<pre><code>func incrementor() -&gt; Int {
    runningTotal += amount
    return runningTotal
}
</code></pre>


<p><code>incrementor</code>函数并没有获取任何参数，但是在函数体内访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为其通过捕获在包含它的函数体内已经存在的<code>runningTotal</code>和<code>amount</code>变量而实现。</p>


<p>由于没有修改<code>amount</code>变量，<code>incrementor</code>实际上捕获并存储了该变量的一个副本，而该副本随着<code>incrementor</code>一同被存储。</p>


<p>然而，因为每次调用该函数的时候都会修改<code>runningTotal</code>的值，<code>incrementor</code>捕获了当前<code>runningTotal</code>变量的引用，而不是仅仅复制该变量的初始值。捕获一个引用保证了当<code>makeIncrementor</code>结束时候并不会消失，也保证了当下一次执行<code>incrementor</code>函数时，<code>runningTotal</code>可以继续增加。</p>


<blockquote>
<p>注意：</p>
<p>Swift 会决定捕获引用还是拷贝值。
您不需要标注<code>amount</code>或者<code>runningTotal</code>来声明在嵌入的<code>incrementor</code>函数中的使用方式。
Swift 同时也处理<code>runingTotal</code>变量的内存管理操作，如果不再被<code>incrementor</code>函数使用，则会被清除。</p>
</blockquote>


<p>下面代码为一个使用<code>makeIncrementor</code>的例子：</p>


<pre><code>let incrementByTen = makeIncrementor(forIncrement: 10)
</code></pre>


<p>该例子定义了一个叫做<code>incrementByTen</code>的常量，该常量指向一个每次调用会加10的<code>incrementor</code>函数。
调用这个函数多次可以得到以下结果：</p>


<pre><code>incrementByTen()
// 返回的值为10
incrementByTen()
// 返回的值为20
incrementByTen()
// 返回的值为30
</code></pre>


<p>如果您创建了另一个<code>incrementor</code>，其会有一个属于自己的独立的<code>runningTotal</code>变量的引用。
下面的例子中，<code>incrementBySevne</code>捕获了一个新的<code>runningTotal</code>变量，该变量和<code>incrementByTen</code>中捕获的变量没有任何联系：</p>


<pre><code>let incrementBySeven = makeIncrementor(forIncrement: 7)
incrementBySeven()
// 返回的值为7
incrementByTen()
// 返回的值为40
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果您闭包分配给一个类实例的属性，并且该闭包通过指向该实例或其成员来捕获了该实例，您将创建一个在闭包和实例间的强引用环。
Swift 使用捕获列表来打破这种强引用环。更多信息，请参考 <a href="../chapter2/16_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>


<p><a name="closures_are_reference_types"></a></p>


<h2 id="-closures-are-reference-types-">闭包是引用类型（Closures Are Reference Types）</h2>


<p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。
这是因为函数和闭包都是引用类型。</p>


<p>无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。
上面的例子中，<code>incrementByTen</code>指向闭包的引用是一个常量，而并非闭包内容本身。</p>


<p>这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包：</p>


<pre><code>let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// 返回的值为50
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.html" itemprop="url">Swift自动引用计数</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Swift 使用自动引用计数（ARC）这一机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 的内存管理机制会一直起着作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>


<p>然而，在少数情况下，ARC 为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用 ARC 来管理你的应用程序的内存。</p>


<blockquote>
<p>注意:</p>
<p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
</blockquote>


<p><a name="how_arc_works"></a></p>


<h2 id="-">自动引用计数的工作机制</h2>


<p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>


<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>


<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为一，ARC都不会销毁这个实例。</p>


<p>为了使之成为可能，无论你将实例赋值给属性，常量或者是变量，属性，常量或者变量，都会对此实例创建强引用。之所以称之为强引用，是因为它会将实例牢牢的保持住，只要强引用还在，实例是不允许被销毁的。</p>


<p><a name="arc_in_action"></a></p>


<h2 id="-">自动引用计数实战</h2>


<p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的<code>Person</code>类开始，并定义了一个叫<code>name</code>的常量属性：</p>


<pre><code>    class Person {
        let name: String

            init(name: String) {
            self.name = name
            println("\(name) is being initialized")
        }

            deinit {
            println("\(name) is being deinitialized")
        }
    }
</code></pre>


<p><code>Person</code>类有一个构造函数，此构造函数为实例的<code>name</code>属性赋值并打印出信息，以表明初始化过程生效。<code>Person</code>类同时也拥有析构函数，同样会在实例被销毁的时候打印出信息。</p>


<p>接下来的代码片段定义了三个类型为<code>Person?</code>的变量，用来按照代码片段中的顺序，为新的<code>Person</code>实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为<code>nil</code>，目前还不会引用到<code>Person</code>类的实例。</p>


<pre><code>    var reference1: Person?
    var reference2: Person?
    var reference3: Person?
</code></pre>


<p>现在你可以创建<code>Person</code>类的新实例，并且将它赋值给三个变量其中的一个：</p>


<pre><code>    reference1 = Person(name: "John Appleseed")
    // prints "John Appleseed is being initialized”
</code></pre>


<p>应当注意到当你调用<code>Person</code>类的构造函数的时候，&#8221;John Appleseed is being initialized”会被打印出来。由此可以确定构造函数被执行。</p>


<p>由于<code>Person</code>类的新实例被赋值给了<code>reference1</code>变量，所以<code>reference1</code>到<code>Person</code>类的新实例之间建立了一个强引用。正是因为这个强引用，ARC 会保证<code>Person</code>实例被保持在内存中不被销毁。</p>


<p>如果你将同样的<code>Person</code>实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>


<pre><code>    reference2 = reference1
    reference3 = reference1
</code></pre>


<p>现在这个<code>Person</code>实例已经有三个强引用了。</p>


<p>如果你通过给两个变量赋值<code>nil</code>的方式断开两个强引用（）包括最先的那个强引用），只留下一个强引用，<code>Person</code>实例不会被销毁：</p>


<pre><code>reference2 = reference1
reference3 = reference1
</code></pre>


<p>ARC 会在第三个，也即最后一个强引用被断开的时候，销毁<code>Person</code>实例，这也意味着你不再使用这个<code>Person</code>实例：</p>


<pre><code>reference3 = nil
// prints "John Appleseed is being deinitialized"
</code></pre>


<p><a name="strong_reference_cycles_between_class_instances"></a></p>


<h2 id="-">类实例之间的循环强引用</h2>


<p>在上面的例子中，ARC 会跟踪你所新创建的<code>Person</code>实例的引用数量，并且会在<code>Person</code>实例不再被需要时销毁它。</p>


<p>然而，我们可能会写出这样的代码，一个类永远不会有0个强引用。这种情况发生在两个类实例互相保持对方的强引用，并让对方不被销毁。这就是所谓的循环强引用。</p>


<p>你可以通过定义类之间的关系为弱引用或者无主引用，以此替代强引用，从而解决循环强引用的问题。具体的过程在<a href="#1">解决类实例之间的循环强引用</a>中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>


<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民:</p>


<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { println("\(name) is being deinitialized") }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    var tenant: Person?
    deinit { println("Apartment #\(number) is being deinitialized") }
}
</code></pre>


<p>每一个<code>Person</code>实例有一个类型为<code>String</code>，名字为<code>name</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>


<p>类似的，每个<code>Apartment</code>实例有一个叫<code>number</code>，类型为<code>Int</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>


<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓<code>Person</code>和<code>Apartment</code>的实例是否像预期的那样被销毁。</p>


<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>number73</code>,并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，并为可选的：</p>


<pre><code>var john: Person?
var number73: Apartment?
</code></pre>


<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将类实例赋值给<code>john</code>和<code>number73</code>变量：</p>


<pre><code>john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)
</code></pre>


<p>在两个实例被创建和赋值后，下图表面了强引用的关系。变量<code>john</code>现在有一个指向<code>Person</code>实例的强引用，而变量<code>number73</code>有一个指向<code>Apartment</code>实例的强引用：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt=""></p>


<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量<code>john</code>和<code>number73</code>中的实例，这样实例的属性才能被赋值：</p>


<pre><code>john!.apartment = number73
number73!.tenant = john
</code></pre>


<p>在将两个实例联系在一起之后，强引用的关系如图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt=""></p>


<p>不幸的是，将这两个实例关联在一起之后，一个循环强引用被创建了。<code>Person</code>实例现在有了一个指向<code>Apartment</code>实例的强引用，而<code>Apartment</code>实例也有了一个指向<code>Person</code>实例的强引用。因此，当你断开<code>john</code>和<code>number73</code>变量所持有的强引用时，引用计数并不会降为 0，实例也不会被 ARC 销毁：</p>


<pre><code>john = nil
number73 = nil
</code></pre>


<p>注意，当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。强引用循环阻止了<code>Person</code>和<code>Apartment</code>类实例的销毁，并在你的应用程序中造成了内存泄漏。</p>


<p>在你将<code>john</code>和<code>number73</code>赋值为<code>nil</code>后，强引用关系如下图：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt=""></p>


<p><code>Person</code>和<code>Apartment</code>实例之间的强引用关系保留了下来并且不会被断开。</p>


<p><a name="resolving_strong_reference_cycles_between_class_instances"></a></p>


<h2 id="-a-name-1-a-"><a name="1">解决实例之间的循环强引用</a></h2>


<p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>


<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>


<p>对于生命周期中会变为<code>nil</code>的实例使用弱引用。相反的，对于初始化赋值后再也不会被赋值为<code>nil</code>的实例，使用无主引用。</p>


<h3 id="-">弱引用</h3>


<p>弱引用不会牢牢保持住引用的实例，并且不会阻止 ARC 销毁被引用的实例。这种行为阻止了引用变为循环强引用。声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。</p>


<p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以阻止循环强引用。如果引用总是有值，则可以使用无主引用，在<a href="#2">无主引用</a>中有描述。在上面<code>Apartment</code>的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。</p>


<blockquote>
<p>注意:</p>
<p>弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。</p>
</blockquote>


<p>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。可选类型是在 Swift 语言中推荐的用来表示可能没有值的类型。</p>


<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为<code>nil</code>。你可以像其他可选值一样，检查弱引用的值是否存在，你永远也不会遇到被销毁了而不存在的实例。</p>


<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>


<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { println("\(name) is being deinitialized") }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    weak var tenant: Person?
    deinit { println("Apartment #\(number) is being deinitialized") }
}
</code></pre>


<p>然后跟之前一样，建立两个变量（john和number73）之间的强引用，并关联两个实例：</p>


<pre><code>var john: Person?
var number73: Apartment?

john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)

john!.apartment = number73
number73!.tenant = john
</code></pre>


<p>现在，两个关联在一起的实例的引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt=""></p>


<p><code>Person</code>实例依然保持对<code>Apartment</code>实例的强引用，但是<code>Apartment</code>实例只是对<code>Person</code>实例的弱引用。这意味着当你断开<code>john</code>变量所保持的强引用时，再也没有指向<code>Person</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt=""></p>


<p>由于再也没有指向<code>Person</code>实例的强引用，该实例会被销毁：</p>


<pre><code>john = nil
// prints "John Appleseed is being deinitialized"
</code></pre>


<p>唯一剩下的指向<code>Apartment</code>实例的强引用来自于变量<code>number73</code>。如果你断开这个强引用，再也没有指向<code>Apartment</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt=""></p>


<p>由于再也没有指向<code>Apartment</code>实例的强引用，该实例也会被销毁：</p>


<pre><code>number73 = nil
// prints "Apartment #73 is being deinitialized"
</code></pre>


<p>上面的两段代码展示了变量<code>john</code>和<code>number73</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>


<h3 id="-a-name-2-a-"><a name="2">无主引用</a></h3>


<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>


<p>由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为<code>nil</code>，因为非可选类型的变量不允许被赋值为<code>nil</code>。</p>


<blockquote>
<p>注意:
如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。</p>
<p>还需要注意的是如果你试图访问实例已经被销毁的无主引用，程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。</p>
</blockquote>


<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系会潜在的创造循环强引用。</p>


<p><code>Customer</code>和<code>CreditCard</code>之间的关系与前面弱引用例子中<code>Apartment</code>和<code>Person</code>的关系截然不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code>类有一个可选类型的<code>card</code>属性，但是<code>CreditCard</code>类有一个非可选类型的<code>customer</code>属性。</p>


<p>此外，只能通过将一个<code>number</code>值和<code>customer</code>实例传递给<code>CreditCard</code>构造函数的方式来创建<code>CreditCard</code>实例。这样可以确保当创建<code>CreditCard</code>实例时总是有一个<code>customer</code>实例与之关联。</p>


<p>由于信用卡总是关联着一个客户，因此将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>


<pre><code>class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { println("\(name) is being deinitialized") }
}

class CreditCard {
    let number: Int
    unowned let customer: Customer
    init(number: Int, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { println("Card #\(number) is being deinitialized") }
}
</code></pre>


<p>下面的代码片段定义了一个叫<code>john</code>的可选类型<code>Customer</code>变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为<code>nil</code>。</p>


<pre><code>var john: Customer?
</code></pre>


<p>现在你可以创建<code>Customer</code>类的实例，用它初始化<code>CreditCard</code>实例，并将新创建的<code>CreditCard</code>实例赋值为客户的<code>card</code>属性。</p>


<pre><code>john = Customer(name: "John Appleseed")
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre>


<p>在你关联两个实例后，他们的引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt=""></p>


<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对<code>Customer</code>实例的无主引用。</p>


<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt=""></p>


<p>由于再也没有指向<code>Customer</code>实例的强引用，该实例被销毁了。其后，再也没有指向<code>CreditCard</code>实例的强引用，该实例也随之被销毁了：</p>


<pre><code>john = nil
// prints "John Appleseed is being deinitialized"
// prints "Card #1234567890123456 is being deinitialized"
</code></pre>


<p>最后的代码展示了在<code>john</code>变量被设为<code>nil</code>后<code>Customer</code>实例和<code>CreditCard</code>实例的构造函数都打印出了“销毁”的信息。</p>


<h3 id="-">无主引用以及显式展开的可选属性</h3>


<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>


<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>


<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。</p>


<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后不能为<code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用显示展开的可选属性。</p>


<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>


<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，而每一个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>


<pre><code>class Country {
    let name: String
    let capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>


<p>为了建立两个类的依赖关系，<code>City</code>的构造函数有一个<code>Country</code>实例的参数，并且将实例保存为<code>country</code>属性。</p>


<p><code>Country</code>的构造函数调用了<code>City</code>的构造函数。然而，只有<code>Country</code>的实例完全初始化完后，<code>Country</code>的构造函数才能把<code>self</code>传给<code>City</code>的构造函数。（<a href="14_Initialization.html">在两步构造函数中有具体描述</a>）</p>


<p>为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将<code>Country</code>的<code>capitalCity</code>属性声明为显示展开的可选类型属性。这表示像其他可选类型一样，<code>capitalCity</code>属性的默认值为<code>nil</code>，但是不需要展开他的值就能访问它。（<a href="01_The_Basics.html">在显示展开的可选类型中有描述</a>）</p>


<p>由于<code>capitalCity</code>默认值为<code>nil</code>，一旦<code>Country</code>的实例在构造函数中给<code>name</code>属性赋值后，整个初始化过程就完成了。这代表一旦<code>name</code>属性被后，<code>Country</code>的构造函数就能引用并传递显式的<code>self</code>。<code>Country</code>的构造函数在赋值<code>capitalCity</code>时，就能将<code>self</code>作为参数传递给<code>City</code>的构造函数。</p>


<p>以上的意义在于你可以通过一条语句同时创建<code>Country</code>和<code>City</code>的实例，而不产生循环强引用，并且<code>capitalCity</code>的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>


<pre><code>var country = Country(name: "Canada", capitalName: "Ottawa")
println("\(country.name)'s capital city is called \(country.capitalCity.name)")
// prints "Canada's capital city is called Ottawa"
</code></pre>


<p>在上面的例子中，使用显示展开可选值的意义在于满足了两个类构造函数的需求。<code>capitalCity</code>属性在初始化完成后，能作为非可选值使用同事还避免了循环强引用。</p>


<p><a name="strong_reference_cycles_for_closures"></a></p>


<h2 id="-">闭包引起的循环强引用</h2>


<p>前面我们看到了循环强引用环是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破循环强引用。</p>


<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod</code>。这两种情况都导致了闭包 “捕获&#8221; <code>self</code>，从而产生了循环强引用。</p>


<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你也把一个引用赋值给了这个闭包。实质上，这跟之前的问题是一样的－两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>


<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包占用列表（closuer capture list）。同样的，在学习如何用闭包占用列表破坏循环强引用之前，先来了解一下循环强引用是如何产生的，这对我们是很有帮助的。</p>


<p>下面的例子为你展示了当一个闭包引用了<code>self</code>后是如何产生一个循环强引用的。例子中定义了一个叫<code>HTMLElement</code>的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>


<pre><code>class HTMLElement {

    let name: String
    let text: String?

    @lazy var asHTML: () -&gt; String = {
        if let text = self.text {
            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println("\(name) is being deinitialized")
    }

}
</code></pre>


<p><code>HTMLElement</code>类定义了一个<code>name</code>属性来表示这个元素的名称，例如代表段落的&#8221;p&#8221;，或者代表换行的&#8221;br&#8221;。<code>HTMLElement</code>还定义了一个可选属性<code>text</code>，用来设置和展现 HTML 元素的文本。</p>


<p>除了上面的两个属性，<code>HTMLElement</code>还定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个闭包，将<code>name</code>和<code>text</code>组合成 HTML 字符串片段。该属性是<code>() -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。</p>


<p>默认情况下，闭包赋值给了<code>asHTML</code>属性，这个闭包返回一个代表 HTML 标签的字符串。如果<code>text</code>值存在，该标签就包含可选值<code>text</code>；如果<code>text</code>不存在，该标签就不包含文本。对于段落元素，根据<code>text</code>是&#8221;some text&#8221;还是<code>nil</code>，闭包会返回&#8221;<code>&lt;p&gt;some text&lt;/p&gt;</code>&#8220;或者&#8221;<code>&lt;p /&gt;</code>&#8220;。</p>


<p>可以像实例方法那样去命名、使用<code>asHTML</code>属性。然而，由于<code>asHTML</code>是闭包而不是实例方法，如果你想改变特定元素的 HTML 处理的话，可以用自定义的闭包来取代默认值。</p>


<blockquote>
<p>注意:</p>
<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>


<p><code>HTMLElement</code>类只提供一个构造函数，通过<code>name</code>和<code>text</code>（如果有的话）参数来初始化一个元素。该类也定义了一个析构函数，当<code>HTMLElement</code>实例被销毁时，打印一条消息。</p>


<p>下面的代码展示了如何用<code>HTMLElement</code>类创建实例并打印消息。</p>


<pre><code>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints"hello, world"
</code></pre>


<blockquote>
<p>注意:</p>
<p>上面的<code>paragraph</code>变量定义为<code>可选HTMLElement</code>，因此我们可以赋值<code>nil</code>给它来演示循环强引用。</p>
</blockquote>


<p>不幸的是，上面写的<code>HTMLElement</code>类产生了类实例和<code>asHTML</code>默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt=""></p>


<p>实例的<code>asHTML</code>属性持有闭包的强引用。但是，闭包在其闭包体内使用了<code>self</code>（引用了<code>self.name</code>和<code>self.text</code>），因此闭包占有了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包占有值的信息，请参考<a href="07_Closures.html">值捕获</a>）。</p>


<blockquote>
<p>注意:</p>
<p>虽然闭包多次使用了<code>self</code>，它只占有<code>HTMLElement</code>实例的一个强引用。</p>
</blockquote>


<p>如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为循环强引用：</p>


<pre><code>paragraph = nil
</code></pre>


<p>注意<code>HTMLElementdeinitializer</code>中的消息并没有别打印，证明了<code>HTMLElement</code>实例并没有被销毁。</p>


<h2 id="-">解决闭包引起的循环强引用</h2>


<p>在定义闭包时同时定义占有列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。占有列表定义了闭包体内占有一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个占有的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>


<blockquote>
<p>注意:</p>
<p>Swift 有如下要求：只要在闭包内使用<code>self</code>的成员，就要用<code>self.someProperty</code>或者<code>self.someMethod</code>（而不只是<code>someProperty</code>或<code>someMethod</code>）。这提醒你可能会不小心就占有了<code>self</code>。</p>
</blockquote>


<h3 id="-">定义占有列表</h3>


<p>占有列表中的每个元素都是由<code>weak</code>或者<code>unowned</code>关键字和实例的引用（如<code>self</code>或<code>someInstance</code>）成对组成。每一对都在花括号中，通过逗号分开。</p>


<p>占有列表放置在闭包参数列表和返回类型之前：</p>


<pre><code>@lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre>


<p>如果闭包没有指定参数列表或者返回类型，则可以通过上下文推断，那么可以占有列表放在闭包开始的地方，跟着是关键字<code>in</code>：</p>


<pre><code>@lazy var someClosure: () -&gt; String = {
    [unowned self] in
    // closure body goes here
}
</code></pre>


<h3 id="-">弱引用和无主引用</h3>


<p>当闭包和占有的实例总是互相引用时并且总是同时销毁时，将闭包内的占有定义为无主引用。</p>


<p>相反的，当占有引用有时可能会是<code>nil</code>时，将闭包内的占有定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为<code>nil</code>。这使我们可以在闭包内检查他们是否存在。</p>


<blockquote>
<p>注意:</p>
<p>如果占有的引用绝对不会置为<code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>


<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样这样编写<code>HTMLElement</code>类来避免循环强引用：</p>


<pre><code>class HTMLElement {

    let name: String
    let text: String?

    @lazy var asHTML: () -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println("\(name) is being deinitialized")
    }

}
</code></pre>


<p>上面的<code>HTMLElement</code>实现和之前的实现一致，只是在<code>asHTML</code>闭包中多了一个占有列表。这里，占有列表是<code>[unowned self]</code>，表示“用无主引用而不是强引用来占有<code>self</code>”。</p>


<p>和之前一样，我们可以创建并打印<code>HTMLElement</code>实例：</p>


<pre><code>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints "&lt;p&gt;hello, world&lt;/p&gt;"
</code></pre>


<p>使用占有列表后引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt=""></p>


<p>这一次，闭包以无主引用的形式占有<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息。</p>


<pre><code>paragraph = nil
// prints "p is being deinitialized"
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E7%BB%A7%E6%89%BF.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E7%BB%A7%E6%89%BF.html" itemprop="url">Swift继承</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>一个类可以<em>继承（inherit）</em>另一个类的方法（methods），属性（property）和其它特性。当一个类继承其它类时，继承类叫<em>子类（subclass）</em>，被继承类叫<em>超类（或父类，superclass）</em>。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>


<p>在 Swift 中，类可以调用和访问超类的方法，属性和附属脚本（subscripts），并且可以重写（override）这些方法，属性和附属脚本来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>


<p>可以为类中继承来的属性添加属性观察器（property observer），这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性（stored property）还是计算型属性（computed property）。</p>


<p><a name="defining_a_base_class"></a></p>


<h2 id="-base-class-">定义一个基类（Base class）</h2>


<p>不继承于其它类的类，称之为<em>基类（base calss）</em>。</p>


<blockquote>
<p>注意：</p>
<p>Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>
</blockquote>


<p>下面的例子定义了一个叫<code>Vehicle</code>的基类。这个基类声明了两个对所有车辆都通用的属性（<code>numberOfWheels</code>和<code>maxPassengers</code>）。这些属性在<code>description</code>方法中使用，这个方法返回一个<code>String</code>类型的，对车辆特征的描述：</p>


<pre><code>class Vehicle {
    var numberOfWheels: Int
    var maxPassengers: Int
    func description() -&gt; String {
        return "\(numberOfWheels) wheels; up to \(maxPassengers) passengers"
    }
    init() {
        numberOfWheels = 0
        maxPassengers = 1
    }
}
</code></pre>


<p><code>Vehicle</code>类定义了<em>构造器（initializer）</em>来设置属性的值。构造器会在<a href="../chapter2/_14Initialization.html">构造过程</a>一节中详细介绍，这里我们做一下简单介绍，以便于讲解子类中继承来的属性如何被修改。</p>


<p>构造器用于创建某个类型的一个新实例。尽管构造器并不是方法，但在语法上，两者很相似。构造器的工作是准备新实例以供使用，并确保实例中的所有属性都拥有有效的初始化值。</p>


<p>构造器的最简单形式就像一个没有参数的实例方法，使用<code>init</code>关键字：</p>


<pre><code>init() {
    // 执行构造过程
}
</code></pre>


<p>如果要创建一个<code>Vehicle</code>类的新实例，使用<em>构造器</em>语法调用上面的初始化器，即类名后面跟一个空的小括号：</p>


<pre><code>let someVehicle = Vehicle()
</code></pre>


<p>这个<code>Vehicle</code>类的构造器为任意的一辆车设置一些初始化属性值（<code>numberOfWheels = 0</code>和<code>maxPassengers = 1</code>）。</p>


<p><code>Vehicle</code>类定义了车辆的共同特性，但这个类本身并没太大用处。为了使它更为实用，你需要进一步细化它来描述更具体的车辆。</p>


<p><a name="subclassing"></a></p>


<h2 id="-subclassing-">子类生成（Subclassing）</h2>


<p><em>子类生成（Subclassing）</em>指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以优化或改变它。你还可以为子类添加新的特性。</p>


<p>为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：</p>


<pre><code>class SomeClass: SomeSuperclass {
    // 类的定义
}
</code></pre>


<p>下一个例子，定义一个更具体的车辆类叫<code>Bicycle</code>。这个新类是在 <code>Vehicle</code>类的基础上创建起来。因此你需要将<code>Vehicle</code>类放在 <code>Bicycle</code>类后面，用冒号分隔。</p>


<p>我们可以将这读作：</p>


<p>“定义一个新的类叫<code>Bicycle</code>，它继承了<code>Vehicle</code>的特性”；</p>


<pre><code>class Bicycle: Vehicle {
    init() {
        super.init()
        numberOfWheels = 2
    }
}
</code></pre>


<p> <code>Bicycle</code>是<code>Vehicle</code>的子类，<code>Vehicle</code>是<code>Bicycle</code>的超类。新的<code>Bicycle</code>类自动获得<code>Vehicle</code>类的特性，比如 <code>maxPassengers</code>和<code>numberOfWheels</code>属性。你可以在子类中定制这些特性，或添加新的特性来更好地描述<code>Bicycle</code>类。</p>


<p><code>Bicycle</code>类定义了一个构造器来设置它定制的特性（自行车只有2个轮子）。<code>Bicycle</code>的构造器调用了它父类<code>Vehicle</code>的构造器 <code>super.init()</code>，以此确保在<code>Bicycle</code>类试图修改那些继承来的属性前<code>Vehicle</code>类已经初始化过它们了。</p>


<blockquote>
<p>注意：</p>
<p>不像 Objective-C，在 Swift 中，初始化器默认是不继承的，见<a href="../chapter2/_14Initialization.html#initializer_inheritance_and_ overriding">初始化器的继承与重写</a></p>
</blockquote>


<p><code>Vehicle</code>类中<code>maxPassengers</code>的默认值对自行车来说已经是正确的，因此在<code>Bicycle</code>的构造器中并没有改变它。而<code>numberOfWheels</code>原来的值对自行车来说是不正确的，因此在初始化器中将它更改为 2。</p>


<p><code>Bicycle</code>不仅可以继承<code>Vehicle</code>的属性，还可以继承它的方法。如果你创建了一个<code>Bicycle</code>类的实例，你就可以调用它继承来的<code>description</code>方法，并且可以看到，它输出的属性值已经发生了变化：</p>


<pre><code>let bicycle = Bicycle()
println("Bicycle: \(bicycle.description())")
// Bicycle: 2 wheels; up to 1 passengers
</code></pre>


<p>子类还可以继续被其它类继承：</p>


<pre><code>class Tandem: Bicycle {
    init() {
        super.init()
        maxPassengers = 2
    }
}
</code></pre>


<p>上面的例子创建了<code>Bicycle</code>的一个子类：双人自行车（tandem）。<code>Tandem</code>从<code>Bicycle</code>继承了两个属性，而这两个属性是<code>Bicycle</code>从<code>Vehicle</code>继承而来的。<code>Tandem</code>并不修改轮子的数量，因为它仍是一辆自行车，有 2 个轮子。但它需要修改<code>maxPassengers</code>的值，因为双人自行车可以坐两个人。</p>


<blockquote>
<p>注意：</p>
<p>子类只允许修改从超类继承来的变量属性，而不能修改继承来的常量属性。</p>
</blockquote>


<p>创建一个<code>Tandem</code>类的实例，打印它的描述，即可看到它的属性已被更新：</p>


<pre><code>let tandem = Tandem()
println("Tandem: \(tandem.description())")
// Tandem: 2 wheels; up to 2 passengers
</code></pre>


<p>注意，<code>Tandem</code>类也继承了<code>description</code>方法。一个类的实例方法会被这个类的所有子类继承。</p>


<p><a name="overriding"></a></p>


<h2 id="-overriding-">重写（Overriding）</h2>


<p>子类可以为继承来的实例方法（instance method），类方法（class method），实例属性（instance property），或附属脚本（subscript）提供自己定制的实现（implementation）。我们把这种行为叫<em>重写（overriding）</em>。</p>


<p>如果要重写某个特性，你需要在重写定义的前面加上<code>override</code>关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少<code>override</code>关键字的重写都会在编译时被诊断为错误。</p>


<p><code>override</code>关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>


<h3 id="-">访问超类的方法，属性及附属脚本</h3>


<p>当你在子类中重写超类的方法，属性或附属脚本时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以优化已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>


<p>在合适的地方，你可以通过使用<code>super</code>前缀来访问超类版本的方法，属性或附属脚本：</p>


<ul>
<li>在方法<code>someMethod</code>的重写实现中，可以通过<code>super.someMethod()</code>来调用超类版本的<code>someMethod</code>方法。</li>
<li>在属性<code>someProperty</code>的 getter 或 setter 的重写实现中，可以通过<code>super.someProperty</code>来访问超类版本的<code>someProperty</code>属性。</li>
<li>在附属脚本的重写实现中，可以通过<code>super[someIndex]</code>来访问超类版本中的相同附属脚本。</li>
</ul>


<h3 id="-">重写方法</h3>


<p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。</p>


<p>下面的例子定义了<code>Vehicle</code>的一个新的子类，叫<code>Car</code>，它重写了从<code>Vehicle</code>类继承来的<code>description</code>方法：</p>


<pre><code>class Car: Vehicle {
    var speed: Double = 0.0
    init() {
        super.init()
        maxPassengers = 5
        numberOfWheels = 4
    }
    override func description() -&gt; String {
        return super.description() + "; "
            + "traveling at \(speed) mph"
    }
}
</code></pre>


<p><code>Car</code>声明了一个新的存储型属性<code>speed</code>，它是<code>Double</code>类型的，默认值是<code>0.0</code>，表示“时速是0英里”。<code>Car</code>有自己的初始化器，它将乘客的最大数量设为5，轮子数量设为4。</p>


<p><code>Car</code>重写了继承来的<code>description</code>方法，它的声明与<code>Vehicle</code>中的<code>description</code>方法一致，声明前面加上了<code>override</code>关键字。</p>


<p><code>Car</code>中的<code>description</code>方法并非完全自定义，而是通过<code>super.description</code>使用了超类<code>Vehicle</code>中的<code>description</code>方法，然后再追加一些额外的信息，比如汽车的当前速度。</p>


<p>如果你创建一个<code>Car</code>的新实例，并打印<code>description</code>方法的输出，你就会发现描述信息已经发生了改变：</p>


<pre><code>let car = Car()
println("Car: \(car.description())")
// Car: 4 wheels; up to 5 passengers; traveling at 0.0 mph
</code></pre>


<h3 id="-">重写属性</h3>


<p>你可以重写继承来的实例属性或类属性，提供自己定制的getter和setter，或添加属性观察器使重写的属性观察属性值什么时候发生改变。</p>


<h4 id="-getters-setters">重写属性的Getters和Setters</h4>


<p>你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。</p>


<p>你可以将一个继承来的只读属性重写为一个读写属性，只需要你在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。</p>


<blockquote>
<p>注意：</p>
<p>如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接返回<code>super.someProperty</code>来返回继承来的值。正如下面的<code>SpeedLimitedCar</code>的例子所示。</p>
</blockquote>


<p>以下的例子定义了一个新类，叫<code>SpeedLimitedCar</code>，它是<code>Car</code>的子类。类<code>SpeedLimitedCar</code>表示安装了限速装置的车，它的最高速度只能达到40mph。你可以通过重写继承来的<code>speed</code>属性来实现这个速度限制：</p>


<pre><code>class SpeedLimitedCar: Car {
    override var speed: Double  {
    get {
        return super.speed
    }
    set {
        super.speed = min(newValue, 40.0)
    }
    }
}
</code></pre>


<p>当你设置一个<code>SpeedLimitedCar</code>实例的<code>speed</code>属性时，属性setter的实现会去检查新值与限制值40mph的大小，它会将超类的<code>speed</code>设置为<code>newValue</code>和<code>40.0</code>中较小的那个。这两个值哪个较小由<code>min</code>函数决定，它是Swift标准库中的一个全局函数。<code>min</code>函数接收两个或更多的数，返回其中最小的那个。</p>


<p>如果你尝试将<code>SpeedLimitedCar</code>实例的<code>speed</code>属性设置为一个大于40mph的数，然后打印<code>description</code>函数的输出，你会发现速度被限制在40mph：</p>


<pre><code>let limitedCar = SpeedLimitedCar()
limitedCar.speed = 60.0
println("SpeedLimitedCar: \(limitedCar.description())")
// SpeedLimitedCar: 4 wheels; up to 5 passengers; traveling at 40.0 mph
</code></pre>


<h4 id="-property-observer-">重写属性观察器（Property Observer）</h4>


<p>你可以在属性重写中为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。关于属性观察器的更多内容，请看<a href="../chapter2/_10Properties.html#property_observer">属性观察器</a>。</p>


<blockquote>
<p>注意：</p>
<p>你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供<code>willSet</code>或<code>didSet</code>实现是不恰当。此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>
</blockquote>


<p>下面的例子定义了一个新类叫<code>AutomaticCar</code>，它是<code>Car</code>的子类。<code>AutomaticCar</code>表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位。<code>AutomaticCar</code>也提供了定制的<code>description</code>方法，可以输出当前挡位。</p>


<pre><code>class AutomaticCar: Car {
    var gear = 1
    override var speed: Double {
    didSet {
        gear = Int(speed / 10.0) + 1
    }
    }
    override func description() -&gt; String {
        return super.description() + " in gear \(gear)"
    }
}
</code></pre>


<p>当你设置<code>AutomaticCar</code>的<code>speed</code>属性，属性的<code>didSet</code>观察器就会自动地设置<code>gear</code>属性，为新的速度选择一个合适的挡位。具体来说就是，属性观察器将新的速度值除以10，然后向下取得最接近的整数值，最后加1来得到档位<code>gear</code>的值。例如，速度为10.0时，挡位为1；速度为35.0时，挡位为4：</p>


<pre><code>let automatic = AutomaticCar()
automatic.speed = 35.0
println("AutomaticCar: \(automatic.description())")
// AutomaticCar: 4 wheels; up to 5 passengers; traveling at 35.0 mph in gear 4
</code></pre>


<p><a name="preventing_overrides"></a></p>


<h2 id="-">防止重写</h2>


<p>你可以通过把方法，属性或附属脚本标记为<em><code>final</code></em>来防止它们被重写，只需要在声明关键字前加上<code>@final</code>特性即可。（例如：<code>@final var</code>, <code>@final func</code>, <code>@final class func</code>, 以及 <code>@final subscript</code>）</p>


<p>如果你重写了<code>final</code>方法，属性或附属脚本，在编译时会报错。在扩展中，你添加到类里的方法，属性或附属脚本也可以在扩展的定义里标记为 final。</p>


<p>你可以通过在关键字<code>class</code>前添加<code>@final</code>特性（<code>@final class</code>）来将整个类标记为 final 的，这样的类是不可被继承的，否则会报编译错误。</p>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.html" itemprop="url">Swift类型检查</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>  <em>类型检查</em>是一种检查类实例的方式，并且或者也是让实例作为它的父类或者子类的一种方式。</p>


<p>  类型检查在 Swift 中使用<code>is</code> 和 <code>as</code>操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p>


<p>  你也可以用来检查一个类是否实现了某个协议，就像在 <a href="Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_363">Protocols Checking for Protocol Conformance</a>部分讲述的一样。</p>


<p><a name="defining_a_class_hierarchy_for_type_casting"></a></p>


<h2 id="-">定义一个类层次作为例子</h2>


<p>  你可以将它用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。这下面的三个代码段定义了一个类层次和一个包含了几个这些类实例的数组，作为类型检查的例子。</p>


<p>  第一个代码片段定义了一个新的基础类<code>MediaItem</code>。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 <code>String</code> 类型的 <code>name</code> 属性，和一个<code>init name</code>初始化器。（它假定所有的媒体项都有个名称。）</p>


<pre><code>class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}
</code></pre>


<p>  下一个代码段定义了 <code>MediaItem</code> 的两个子类。第一个子类<code>Movie</code>，在父类（或者说基类）的基础上增加了一个 <code>director</code>（导演） 属性，和相应的初始化器。第二个类在父类的基础上增加了一个 <code>artist</code>（艺术家） 属性，和相应的初始化器：</p>


<pre><code>class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}
</code></pre>


<p>  最后一个代码段创建了一个数组常量 <code>library</code>
  ，包含两个<code>Movie</code>实例和三个<code>Song</code>实例。<code>library</code>的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够演绎出<code>Movie</code> 和 <code>Song</code> 有共同的父类 <code>MediaItem</code> ，所以它推断出 <code>MediaItem[]</code> 类作为 <code>library</code> 的类型。</p>


<pre><code>let library = [
Movie(name: "Casablanca", director: "Michael Curtiz"),
Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
Movie(name: "Citizen Kane", director: "Orson Welles"),
Song(name: "The One And Only", artist: "Chesney Hawkes"),
Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
]
// the type of "library" is inferred to be MediaItem[]
</code></pre>


<p>  在幕后<code>library</code> 里存储的媒体项依然是 <code>Movie</code> 和 <code>Song</code> 类型的，但是，若你迭代它，取出的实例会是 <code>MediaItem</code> 类型的，而不是 <code>Movie</code> 和 <code>Song</code> 类型的。为了让它们作为它们本来的类型工作，你需要检查它们的类型或者向下转换它们的类型到其它类型，就像下面描述的一样。</p>


<p><a name="checking_type"></a></p>


<h2 id="-">检查类型</h2>


<p>  用类型检查操作符(<code>is</code>)来检查一个实例是否属于特定子类型。类型检查操作符返回 <code>true</code> 若实例属于那个子类型，若不属于返回 <code>false</code> 。</p>


<p>  下面的例子定义了两个变量，<code>movieCount</code> 和 <code>songCount</code>，用来计算数组<code>library</code> 中 <code>Movie</code> 和 <code>Song</code> 类型的实例数量。</p>


<pre><code>var movieCount = 0
var songCount = 0

for item in library {
    if item is Movie {
        ++movieCount
    } else if item is Song {
        ++songCount
    }
}

println("Media library contains \(movieCount) movies and \(songCount) songs")
// prints "Media library contains 2 movies and 3 songs"
</code></pre>


<p>  示例迭代了数组 <code>library</code> 中的所有项。每一次， <code>for</code>-<code>in</code> 循环设置
  <code>item</code> 为数组中的下一个 <code>MediaItem</code>。</p>


<p>  若当前 <code>MediaItem</code> 是一个 <code>Movie</code> 类型的实例， <code>item is Movie</code> 返回
  <code>true</code>，相反返回 <code>false</code>。同样的，<code>item is
  Song</code>检查item是否为<code>Song</code>类型的实例。在循环结束后，<code>movieCount</code> 和 <code>songCount</code>的值就是被找到属于各自的类型的实例数量。</p>


<p><a name="downcasting"></a></p>


<h2 id="-downcasting-">向下转型（Downcasting）</h2>


<p>  某类型的一个常量或变量可能在幕后实际上属于一个子类。你可以相信，上面就是这种情况。你可以尝试向下转到它的子类型，用类型检查操作符(<code>as</code>)</p>


<p>  因为向下转型可能会失败，类型检查操作符带有两种不同形式。可选形式（ optional form） <code>as?</code> 返回一个你试图下转成的类型的可选值（optional value）。强制形式 <code>as</code> 把试图向下转型和强制解包（force-unwraps）结果作为一个混合动作。</p>


<p>  当你不确定下转可以成功时，用类型检查的可选形式(<code>as?</code>)。可选形式的类型检查总是返回一个可选值（optional value），并且若下转是不可能的，可选值将是 <code>nil</code> 。这使你能够检查下转是否成功。</p>


<p>  只有你可以确定下转一定会成功时，才使用强制形式。当你试图下转为一个不正确的类型时，强制形式的类型检查会触发一个运行时错误。</p>


<p>  下面的例子，迭代了<code>library</code>里的每一个 <code>MediaItem</code> ，并打印出适当的描述。要这样做，<code>item</code>需要真正作为<code>Movie</code> 或 <code>Song</code>的类型来使用。不仅仅是作为 <code>MediaItem</code>。为了能够使用<code>Movie</code> 或 <code>Song</code>的 <code>director</code> 或 <code>artist</code>属性，这是必要的。</p>


<p>  在这个示例中，数组中的每一个<code>item</code>可能是 <code>Movie</code> 或 <code>Song</code>。   事前你不知道每个<code>item</code>的真实类型，所以这里使用可选形式的类型检查 （<code>as?</code>）去检查循环里的每次下转。</p>


<pre><code>for item in library {
    if let movie = item as? Movie {
        println("Movie: '\(movie.name)', dir. \(movie.director)")
    } else if let song = item as? Song {
        println("Song: '\(song.name)', by \(song.artist)")
    }
}

// Movie: 'Casablanca', dir. Michael Curtiz
// Song: 'Blue Suede Shoes', by Elvis Presley
// Movie: 'Citizen Kane', dir. Orson Welles
// Song: 'The One And Only', by Chesney Hawkes
// Song: 'Never Gonna Give You Up', by Rick Astley
</code></pre>


<p>  示例首先试图将 <code>item</code> 下转为 <code>Movie</code>。因为 <code>item</code> 是一个 <code>MediaItem</code>
  类型的实例，它可能是一个<code>Movie</code>；同样，它可能是一个 <code>Song</code>，或者仅仅是基类
  <code>MediaItem</code>。因为不确定，<code>as?</code>形式在试图下转时将返还一个可选值。 <code>item as Movie</code> 的返回值是<code>Movie?</code>类型或 “optional <code>Movie</code>”。</p>


<p>  当下转为 <code>Movie</code> 应用在两个 <code>Song</code>
  实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 <code>Movie</code>真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“<code>if let movie = item as? Movie</code>”，可以这样解读：</p>


<p>  “尝试将 <code>item</code> 转为 <code>Movie</code>类型。若成功，设置一个新的临时常量 <code>movie</code>  来存储返回的可选<code>Movie</code>”</p>


<p>  若下转成功，然后<code>movie</code>的属性将用于打印一个<code>Movie</code>实例的描述，包括它的导演的名字<code>director</code>。当<code>Song</code>被找到时，一个相近的原理被用来检测 <code>Song</code> 实例和打印它的描述。</p>


<blockquote>
<p>注意：</p>
<p>转换没有真的改变实例或它的值。潜在的根本的实例保持不变；只是简单地把它作为它被转换成的类来使用。</p>
</blockquote>


<p><a name="type_casting_for_any_and_anyobject"></a></p>


<h2 id="-any-anyobject-"><code>Any</code>和<code>AnyObject</code>的类型检查</h2>


<p>  Swift为不确定类型提供了两种特殊类型别名：</p>


<ul>
<li><p><code>AnyObject</code>可以代表任何class类型的实例。</p>
</li>
<li><p><code>Any</code>可以表示任何类型，除了方法类型（function types）。</p>
</li>
</ul>


<blockquote>
<p>注意：</p>
<p>只有当你明确的需要它的行为和功能时才使用<code>Any</code>和<code>AnyObject</code>。在你的代码里使用你期望的明确的类型总是更好的。</p>
</blockquote>


<h3 id="-anyobject-"><code>AnyObject</code>类型</h3>


<p>  当需要在工作中使用 Cocoa
  APIs，它一般接收一个<code>AnyObject[]</code>类型的数组，或者说“一个任何对象类型的数组”。这是因为 Objective-C 没有明确的类型化数组。但是，你常常可以确定包含在仅从你知道的 API 信息提供的这样一个数组中的对象的类型。</p>


<p>  在这些情况下，你可以使用强制形式的类型检查(<code>as</code>)来下转在数组中的每一项到比 <code>AnyObject</code> 更明确的类型，不需要可选解析（optional unwrapping）。</p>


<p>  下面的示例定义了一个 <code>AnyObject[]</code> 类型的数组并填入三个<code>Movie</code>类型的实例：</p>


<pre><code>let someObjects: AnyObject[] = [
    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
    Movie(name: "Moon", director: "Duncan Jones"),
    Movie(name: "Alien", director: "Ridley Scott")
]
</code></pre>


<p>  因为知道这个数组只包含 <code>Movie</code> 实例，你可以直接用(<code>as</code>)下转并解包到不可选的<code>Movie</code>类型（ps：其实就是我们常用的正常类型，这里是为了和可选类型相对比）。</p>


<pre><code>for object in someObjects {
    let movie = object as Movie
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</code></pre>


<p>  为了变为一个更短的形式，下转<code>someObjects</code>数组为<code>Movie[]</code>类型来代替下转每一项方式。</p>


<pre><code>for movie in someObjects as Movie[] {
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</code></pre>


<h3 id="-any-"><code>Any</code>类型</h3>


<p>  这里有个示例，使用 <code>Any</code> 类型来和混合的不同类型一起工作，包括非<code>class</code>类型。它创建了一个可以存储<code>Any</code>类型的数组 <code>things</code>。</p>


<pre><code>var things = Any[]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))
</code></pre>


<p>  <code>things</code> 数组包含两个 <code>Int</code> 值，2个 <code>Double</code> 值，1个 <code>String</code> 值，一个元组 <code>(Double, Double)</code> ，Ivan Reitman 导演的电影“Ghostbusters”。</p>


<p>  你可以在 <code>switch</code> <code>cases</code>里用<code>is</code> 和 <code>as</code> 操作符来发觉只知道是 <code>Any</code> 或 <code>AnyObject</code>的常量或变量的类型。 下面的示例迭代 <code>things</code>数组中的每一项的并用<code>switch</code>语句查找每一项的类型。这几种<code>switch</code>语句的情形绑定它们匹配的值到一个规定类型的常量，让它们可以打印它们的值：</p>


<pre><code>for thing in things {
    switch thing {
    case 0 as Int:
        println("zero as an Int")
    case 0 as Double:
        println("zero as a Double")
    case let someInt as Int:
        println("an integer value of \(someInt)")
    case let someDouble as Double where someDouble &gt; 0:
        println("a positive double value of \(someDouble)")
    case is Double:
        println("some other double value that I don't want to print")
    case let someString as String:
        println("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        println("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        println("a movie called '\(movie.name)', dir. \(movie.director)")
    default:
        println("something else")
    }
}

// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of "hello"
// an (x, y) point at 3.0, 5.0
// a movie called 'Ghostbusters', dir. Ivan Reitman
</code></pre>


<p>。</p>


<blockquote>
<p>注意：</p>
<p>在一个switch语句的case中使用强制形式的类型检查操作符（as, 而不是 as?）来检查和转换到一个明确的类型。在 switch case 语句的内容中这种检查总是安全的。</p>
</blockquote>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97.html" itemprop="url">Swift类型嵌套</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>枚举类型常被用于实现特定类或结构体的功能。也能够在有多种变量类型的环境中，方便地定义通用类或结构体来使用，为了实现这种功能，Swift允许你定义类型嵌套，可以在枚举类型、类和结构体中定义支持嵌套的类型。</p>


<p>要在一个类型中嵌套另一个类型，将需要嵌套的类型的定义写在被嵌套类型的区域{}内，而且可以根据需要定义多级嵌套。</p>


<p><a name="nested_types_in_action"></a></p>


<h2 id="-">类型嵌套实例</h2>


<p>下面这个例子定义了一个结构体<code>BlackjackCard</code>(二十一点)，用来模拟<code>BlackjackCard</code>中的扑克牌点数。<code>BlackjackCard</code>结构体包含2个嵌套定义的枚举类型<code>Suit</code> 和 <code>Rank</code>。</p>


<p>在<code>BlackjackCard</code>规则中，<code>Ace</code>牌可以表示1或者11，<code>Ace</code>牌的这一特征用一个嵌套在枚举型<code>Rank</code>的结构体<code>Values</code>来表示。</p>


<pre><code>struct BlackjackCard {
    // 嵌套定义枚举型Suit
    enum Suit: Character {
       case Spades = "♠", Hearts = "♡", Diamonds = "♢", Clubs = "♣"
   }
    // 嵌套定义枚举型Rank
    enum Rank: Int {
       case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
       case Jack, Queen, King, Ace
       struct Values {
           let first: Int, second: Int?
       }
       var values: Values {
        switch self {
        case .Ace:
            return Values(first: 1, second: 11)
        case .Jack, .Queen, .King:
            return Values(first: 10, second: nil)
        default:
            return Values(first: self.toRaw(), second: nil)
            }
       }
    }
    // BlackjackCard 的属性和方法
    let rank: Rank, suit: Suit
    var description: String {
    var output = "suit is \(suit.toRaw()),"
        output += " value is \(rank.values.first)"
        if let second = rank.values.second {
            output += " or \(second)"
        }
        return output
    }
}
</code></pre>


<p>枚举型的<code>Suit</code>用来描述扑克牌的四种花色，并分别用一个<code>Character</code>类型的值代表花色符号。</p>


<p>枚举型的<code>Rank</code>用来描述扑克牌从<code>Ace</code>~10,<code>J</code>,<code>Q</code>,<code>K</code>,13张牌，并分别用一个<code>Int</code>类型的值表示牌的面值。(这个<code>Int</code>类型的值不适用于<code>Ace</code>,<code>J</code>,<code>Q</code>,<code>K</code>的牌)。</p>


<p>如上文所提到的，枚举型<code>Rank</code>在自己内部定义了一个嵌套结构体<code>Values</code>。这个结构体包含两个变量，只有<code>Ace</code>有两个数值，其余牌都只有一个数值。结构体<code>Values</code>中定义的两个属性：</p>


<p><code>first</code>, 为<code>Int</code>
<code>second</code>, 为 <code>Int?</code>, 或 “optional <code>Int</code>”</p>


<p><code>Rank</code>定义了一个计算属性<code>values</code>，这个计算属性会根据牌的面值，用适当的数值去初始化<code>Values</code>实例，并赋值给<code>values</code>。对于<code>J</code>,<code>Q</code>,<code>K</code>,<code>Ace</code>会使用特殊数值，对于数字面值的牌使用<code>Int</code>类型的值。</p>


<p><code>BlackjackCard</code>结构体自身有两个属性—<code>rank</code>与<code>suit</code>，也同样定义了一个计算属性<code>description</code>，<code>description</code>属性用<code>rank</code>和<code>suit</code>的中内容来构建对这张扑克牌名字和数值的描述，并用可选类型<code>second</code>来检查是否存在第二个值，若存在，则在原有的描述中增加对第二数值的描述。</p>


<p>因为<code>BlackjackCard</code>是一个没有自定义构造函数的结构体，在<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/14Initialization.md" target="_blank">Memberwise Initializers for Structure Types</a>中知道结构体有默认的成员构造函数，所以你可以用默认的<code>initializer</code>去初始化新的常量<code>theAceOfSpades</code>:</p>


<pre><code>let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
println("theAceOfSpades: \(theAceOfSpades.description)")
// 打印出 "theAceOfSpades: suit is ♠, value is 1 or 11"
</code></pre>


<p>尽管<code>Rank</code>和<code>Suit</code>嵌套在<code>BlackjackCard</code>中，但仍可被引用，所以在初始化实例时能够通过枚举类型中的成员名称单独引用。在上面的例子中<code>description</code>属性能正确得输出对<code>Ace</code>牌有1和11两个值。</p>


<p><a name="referring_to_nested_types"></a></p>


<h2 id="-">类型嵌套的引用</h2>


<p>在外部对嵌套类型的引用，以被嵌套类型的名字为前缀，加上所要引用的属性名：</p>


<pre><code>let heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()
// 红心的符号 为 "♡"
</code></pre>


<p>对于上面这个例子，这样可以使<code>Suit</code>, <code>Rank</code>, 和 <code>Values</code>的名字尽可能的短，因为它们的名字会自然的由被定义的上下文来限定。</p>


		
		
	</div>

</article>

</div>
<nav id="pagenavi">

    
    
        <a href="/" class="prev">上一页</a>
    
    
    
        <a href="/pages/3" class="next">下一页</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    小巴


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	
</body>
</html>
