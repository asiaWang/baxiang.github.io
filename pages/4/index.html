
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>小巴童鞋</title>
	<meta name="author" content="小巴">

	
	<meta name="description" content="Nov 27,&nbsp 2014 swift Comments Swift扩展 扩展就是向一个已有的类、结构体或枚举类型添加新功能（functionality）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（categories） &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="小巴童鞋" type="application/atom+xml">
	
	<link rel="canonical" href="http://baxiang123.com//pages/4/index.html">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
	<link href="/stylesheets/google-fonts.css" rel="stylesheet" type="text/css">
	
	<meta name="baidu-site-verification" content="6a14c2aa1891f60e94e78134679099cd"/>
<meta name="baidu-site-verification" content="tXGpoDjJRv" />
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?d811e8c9d300f1af279a81ea7923be4d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script type="text/javascript">
 function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
 $(document).bind('DOMNodeInserted', function(event) {
  addBlankTargetForLinks();
 });
 </script>
 
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script async src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='/images/xiaoba.png' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1>&nbsp;&nbsp;<a href="/">小巴童鞋</a></h1>
<p class="subtitle">BaXiang&#8217;s technology blog</p>
<nav id="main-nav"><!--ul class="main">
    <nav id="main-nav">
		<li><a href="/">Home</a></li>
		<li><a href="/blog/archives">Blogs</a></li>
		<li><a href="#">About</a></li>
    </nav> 
</ul><!-->
<ul class="main-navigation">
  <li><a href="/">Blog | 博客</a></li>
  <li><a href="/blog/archives">Archives | 目录</a></li>
  <li><a href="/blog/categories">Categories  | 分类</a></li>
  <li><a href="/aboutme/">About Me | 关于</a></li>
  
</ul>

</nav>
<nav id="sub-nav">
	<br/>
	<div class="social">
        
            <a class="weibo" href="http://www.weibo.com/1655203353" title="Weibo" target="_blank">Weibo</a>
        
		
		
			<a class="facebook" href="http://www.facebook.com/xiang.ba.1" title="Facebook">Facebook</a>
		
		
		
			<a class="twitter" href="http://twitter.com/baxiang2014" title="Twitter">Twitter</a>
		
		
			<a class="github" href="https://github.com/baxiang" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E6%89%A9%E5%B1%95.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E6%89%A9%E5%B1%95.html" itemprop="url">Swift扩展</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><em>扩展</em>就是向一个已有的类、结构体或枚举类型添加新功能（functionality）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即<em>逆向建模</em>）。扩展和 Objective-C 中的分类（categories）类似。（不过与Objective-C不同的是，Swift 的扩展没有名字。）</p>


<p>Swift 中的扩展可以：</p>


<ul>
<li>添加计算型属性和计算静态属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个接口</li>
</ul>


<blockquote>
<p>注意：</p>
<p>如果你定义了一个扩展向一个已有类型添加新功能，那么这个新功能对该类型的所有已有实例中都是可用的，即使它们是在你的这个扩展的前面定义的。</p>
</blockquote>


<p><a name="extension_syntax"></a></p>


<h2 id="-extension-syntax-">扩展语法（Extension Syntax）</h2>


<p>声明一个扩展使用关键字<code>extension</code>：</p>


<pre><code>extension SomeType {
    // 加到SomeType的新功能写到这里
}
</code></pre>


<p>一个扩展可以扩展一个已有类型，使其能够适配一个或多个协议（protocol）。当这种情况发生时，接口的名字应该完全按照类或结构体的名字的方式进行书写：</p>


<pre><code>extension SomeType: SomeProtocol, AnotherProctocol {
    // 协议实现写到这里
}
</code></pre>


<p>按照这种方式添加的协议遵循者（protocol conformance）被称之为<a href="21_Protocols.html#adding_protocol_conformance_with_an_extension">在扩展中添加协议遵循者</a></p>


<p><a name="computed_properties"></a></p>


<h2 id="-computed-properties-">计算型属性（Computed Properties）</h2>


<p>扩展可以向已有类型添加计算型实例属性和计算型类型属性。下面的例子向 Swift 的内建<code>Double</code>类型添加了5个计算型实例属性，从而提供与距离单位协作的基本支持。</p>


<pre><code>extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
println("One inch is \(oneInch) meters")
// 打印输出："One inch is 0.0254 meters"
let threeFeet = 3.ft
println("Three feet is \(threeFeet) meters")
// 打印输出："Three feet is 0.914399970739201 meters"
</code></pre>


<p>这些计算属性表达的含义是把一个<code>Double</code>型的值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性仍可以接一个带有dot语法的浮点型字面值，而这恰恰是使用这些浮点型字面量实现距离转换的方式。</p>


<p>在上述例子中，一个<code>Double</code>型的值<code>1.0</code>被用来表示“1米”。这就是为什么<code>m</code>计算型属性返回<code>self</code>——表达式<code>1.m</code>被认为是计算<code>1.0</code>的<code>Double</code>值。</p>


<p>其它单位则需要一些转换来表示在米下测量的值。1千米等于1,000米，所以<code>km</code>计算型属性要把值乘以<code>1_000.00</code>来转化成单位米下的数值。类似地，1米有3.28024英尺，所以<code>ft</code>计算型属性要把对应的<code>Double</code>值除以<code>3.28024</code>来实现英尺到米的单位换算。</p>


<p>这些属性是只读的计算型属性，所有从简考虑它们不用<code>get</code>关键字表示。它们的返回值是<code>Double</code>型，而且可以用于所有接受<code>Double</code>的数学计算中：</p>


<pre><code>let aMarathon = 42.km + 195.m
println("A marathon is \(aMarathon) meters long")
// 打印输出："A marathon is 42495.0 meters long"
</code></pre>


<blockquote>
<p>注意：</p>
<p>扩展可以添加新的计算属性，但是不可以添加存储属性，也不可以向已有属性添加属性观测器(property observers)。</p>
</blockquote>


<p><a name="initializers"></a></p>


<h2 id="-initializers-">构造器（Initializers）</h2>


<p>扩展可以向已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为构造器参数，或者提供该类型的原始实现中没有包含的额外初始化选项。</p>


<blockquote>
<p>注意：</p>
<p>如果你使用扩展向一个值类型添加一个构造器，该构造器向所有的存储属性提供默认值，而且没有定义任何定制构造器（custom initializers），那么对于来自你的扩展构造器中的值类型，你可以调用默认构造器(default initializers)和成员级构造器(memberwise initializers)。
正如在值类型的构造器授权中描述的，如果你已经把构造器写成值类型原始实现的一部分，上述规则不再适用。</p>
</blockquote>


<p>下面的例子定义了一个用于描述几何矩形的定制结构体<code>Rect</code>。这个例子同时定义了两个辅助结构体<code>Size</code>和<code>Point</code>，它们都把<code>0.0</code>作为所有属性的默认值：</p>


<pre><code>struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>


<p>因为结构体<code>Rect</code>提供了其所有属性的默认值，所以正如默认构造器中描述的，它可以自动接受一个默认的构造器和一个成员级构造器。这些构造器可以用于构造新的<code>Rect</code>实例：</p>


<pre><code>let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
</code></pre>


<p>你可以提供一个额外的使用特殊中心点和大小的构造器来扩展<code>Rect</code>结构体：</p>


<pre><code>extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>


<p>这个新的构造器首先根据提供的<code>center</code>和<code>size</code>值计算一个合适的原点。然后调用该结构体自动的成员构造器<code>init(origin:size:)</code>，该构造器将新的原点和大小存到了合适的属性中：</p>


<pre><code>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果你使用扩展提供了一个新的构造器，你依旧有责任保证构造过程能够让所有实例完全初始化。</p>
</blockquote>


<p><a name="methods"></a></p>


<h2 id="-methods-">方法（Methods）</h2>


<p>扩展可以向已有类型添加新的实例方法和类型方法。下面的例子向<code>Int</code>类型添加一个名为<code>repetitions</code>的新实例方法：</p>


<pre><code>extension Int {
    func repetitions(task: () -&gt; ()) {
        for i in 0..self {
            task()
        }
    }
}
</code></pre>


<p>这个<code>repetitions</code>方法使用了一个<code>() -&gt; ()</code>类型的单参数（single argument），表明函数没有参数而且没有返回值。</p>


<p>定义该扩展之后，你就可以对任意整数调用<code>repetitions</code>方法,实现的功能则是多次执行某任务：</p>


<pre><code>3.repetitions({
    println("Hello!")
    })
// Hello!
// Hello!
// Hello!
</code></pre>


<p>可以使用 trailing 闭包使调用更加简洁：</p>


<pre><code>3.repetitions{
    println("Goodbye!")
}
// Goodbye!
// Goodbye!
// Goodbye!
</code></pre>


<p><a name="mutating_instance_methods"></a></p>


<h3 id="-mutating-instance-methods-">修改实例方法（Mutating Instance Methods）</h3>


<p>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改<code>self</code>或其属性的方法必须将该实例方法标注为<code>mutating</code>，正如来自原始实现的修改方法一样。</p>


<p>下面的例子向Swift的<code>Int</code>类型添加了一个新的名为<code>square</code>的修改方法，来实现一个原始值的平方计算：</p>


<pre><code>extension Int {
    mutating func square() {
        self = self * self
    }
}
var someInt = 3
someInt.square()
// someInt 现在值是 9
</code></pre>


<p><a name="subscripts"></a></p>


<h2 id="-subscripts-">下标（Subscripts）</h2>


<p>扩展可以向一个已有类型添加新下标。这个例子向Swift内建类型<code>Int</code>添加了一个整型下标。该下标<code>[n]</code>返回十进制数字从右向左数的第n个数字</p>


<ul>
<li>123456789[0]返回9</li>
<li>123456789[1]返回8</li>
</ul>


<p>&#8230;等等</p>


<pre><code>extension Int {
    subscript(digitIndex: Int) -&gt; Int {
        var decimalBase = 1
            for _ in 1...digitIndex {
                decimalBase *= 10
            }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// returns 5
746381295[1]
// returns 9
746381295[2]
// returns 2
746381295[8]
// returns 7
</code></pre>


<p>如果该<code>Int</code>值没有足够的位数，即下标越界，那么上述实现的下标会返回0，因为它会在数字左边自动补0：</p>


<pre><code>746381295[9]
//returns 0, 即等同于：
0746381295[9]
</code></pre>


<p><a name="nested_types"></a></p>


<h2 id="-nested-types-">嵌套类型（Nested Types）</h2>


<p>扩展可以向已有的类、结构体和枚举添加新的嵌套类型：</p>


<pre><code>extension Character {
    enum Kind {
        case Vowel, Consonant, Other
    }
    var kind: Kind {
        switch String(self).lowercaseString {
        case "a", "e", "i", "o", "u":
            return .Vowel
        case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
             "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
            return .Consonant
        default:
            return .Other
        }
    }
}
</code></pre>


<p>该例子向<code>Character</code>添加了新的嵌套枚举。这个名为<code>Kind</code>的枚举表示特定字符的类型。具体来说，就是表示一个标准的拉丁脚本中的字符是元音还是辅音（不考虑口语和地方变种），或者是其它类型。</p>


<p>这个类子还向<code>Character</code>添加了一个新的计算实例属性，即<code>kind</code>，用来返回合适的<code>Kind</code>枚举成员。</p>


<p>现在，这个嵌套枚举可以和一个<code>Character</code>值联合使用了：</p>


<pre><code>func printLetterKinds(word: String) {
    println("'\\(word)' is made up of the following kinds of letters:")
    for character in word {
        switch character.kind {
        case .Vowel:
            print("vowel ")
        case .Consonant:
            print("consonant ")
        case .Other:
            print("other ")
        }
    }
    print("\n")
}
printLetterKinds("Hello")
// 'Hello' is made up of the following kinds of letters:
// consonant vowel consonant consonant vowel
</code></pre>


<p>函数<code>printLetterKinds</code>的输入是一个<code>String</code>值并对其字符进行迭代。在每次迭代过程中，考虑当前字符的<code>kind</code>计算属性，并打印出合适的类别描述。所以<code>printLetterKinds</code>就可以用来打印一个完整单词中所有字母的类型，正如上述单词<code>"hello"</code>所展示的。</p>


<blockquote>
<p>注意：</p>
<p>由于已知<code>character.kind</code>是<code>Character.Kind</code>型，所以<code>Character.Kind</code>中的所有成员值都可以使用<code>switch</code>语句里的形式简写，比如使用 <code>.Vowel</code>代替<code>Character.Kind.Vowel</code></p>
</blockquote>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E5%B1%9E%E6%80%A7.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E5%B1%9E%E6%80%A7.html" itemprop="url">Swift属性</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><strong>属性</strong>将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，计算属性计算（而不是存储）一个值。计算属性可以用于类、结构体和枚举里，存储属性只能用于类和结构体。</p>


<p>存储属性和计算属性通常用于特定类型的实例，但是，属性也可以直接用于类型本身，这种属性称为类型属性。</p>


<p>另外，还可以定义属性监视器来监控属性值的变化，以此来触发一个自定义的操作。属性监视器可以添加到自己写的存储属性上，也可以添加到从父类继承的属性上。</p>


<p><a name="stored_properties"></a></p>


<h2 id="-">存储属性</h2>


<p>简单来说，一个存储属性就是存储在特定类或结构体的实例里的一个常量或变量，存储属性可以是<em>变量存储属性</em>（用关键字<code>var</code>定义），也可以是<em>常量存储属性</em>（用关键字<code>let</code>定义）。</p>


<p>可以在定义存储属性的时候指定默认值，请参考<a href="../chapter2/14_Initialization.html">构造过程</a>一章的<a href="../chapter2/14_Initialization.html#default_property_values">默认属性值</a>一节。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值，请参考<a href="../chapter2/14_Initialization.html">构造过程</a>一章的<a href="../chapter2/14_Initialization.html#modifying_constant_properties_during_initialization">在初始化阶段修改常量存储属性</a>一节。</p>


<p>下面的例子定义了一个名为<code>FixedLengthRange</code>的结构体，他描述了一个在创建后无法修改值域宽度的区间：</p>


<pre><code>struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// 该区间表示整数0，1，2
rangeOfThreeItems.firstValue = 6
// 该区间现在表示整数6，7，8
</code></pre>


<p><code>FixedLengthRange</code>的实例包含一个名为<code>firstValue</code>的变量存储属性和一个名为<code>length</code>的常量存储属性。在上面的例子中，<code>length</code>在创建实例的时候被赋值，因为它是一个常量存储属性，所以之后无法修改它的值。</p>


<p><a name="stored_properties_of_constant_structure_instances"></a></p>


<h3 id="-">常量和存储属性</h3>


<p>如果创建了一个结构体的实例并赋值给一个常量，则无法修改实例的任何属性，即使定义了变量存储属性：</p>


<pre><code>let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// 该区间表示整数0，1，2，3
rangeOfFourItems.firstValue = 6
// 尽管firstValue诗歌变量属性，这里还是会报错
</code></pre>


<p>因为<code>rangeOfFourItems</code>声明成了常量（用<code>let</code>关键字），即使<code>firstValue</code>是一个变量属性，也无法再修改它了。</p>


<p>这种行为是由于结构体（struct）属于<em>值类型</em>。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>


<p>属于<em>引用类型</em>的类（class）则不一样，把一个引用类型的实例赋给一个常量后，仍然可以修改实例的变量属性。</p>


<p><a name="lazy_stored_properties"></a></p>


<h3 id="-">延迟存储属性</h3>


<p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>@lazy</code>来标示一个延迟存储属性。</p>


<blockquote>
<p>注意：</p>
<p>必须将延迟存储属性声明成变量（使用<code>var</code>关键字），因为属性的值在实例构造完成之前可能无法得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</p>
</blockquote>


<p>延迟属性很有用，当属性的值依赖于在实例的构造过程结束前无法知道具体值的外部因素时，或者当属性的值需要复杂或大量计算时，可以只在需要的时候来计算它。</p>


<p>下面的例子使用了延迟存储属性来避免复杂类的不必要的初始化。例子中定义了<code>DataImporter</code>和<code>DataManager</code>两个类，下面是部分代码：</p>


<pre><code>class DataImporter {
    /*
    DataImporter 是一个将外部文件中的数据导入的类。
    这个类的初始化会消耗不少时间。
    */
    var fileName = "data.txt"
    // 这是提供数据导入功能
}

class DataManager {
    @lazy var importer = DataImporter()
    var data = String[]()
    // 这是提供数据管理功能
}

let manager = DataManager()
manager.data += "Some data"
manager.data += "Some more data"
// DataImporter 实例的 importer 属性还没有被创建
</code></pre>


<p><code>DataManager</code>类包含一个名为<code>data</code>的存储属性，初始值是一个空的字符串（<code>String</code>）数组。虽然没有写出全部代码，<code>DataManager</code>类的目的是管理和提供对这个字符串数组的访问。</p>


<p><code>DataManager</code>的一个功能是从文件导入数据，该功能由<code>DataImporter</code>类提供，<code>DataImporter</code>需要消耗不少时间完成初始化：因为它的实例在初始化时可能要打开文件，还要读取文件内容到内存。</p>


<p><code>DataManager</code>也可能不从文件中导入数据。所以当<code>DataManager</code>的实例被创建时，没必要创建一个<code>DataImporter</code>的实例，更明智的是当用到<code>DataImporter</code>的时候才去创建它。</p>


<p>由于使用了<code>@lazy</code>，<code>importer</code>属性只有在第一次被访问的时候才被创建。比如访问它的属性<code>fileName</code>时：</p>


<pre><code>println(manager.importer.fileName)
// DataImporter 实例的 importer 属性现在被创建了
// 输出 "data.txt”
</code></pre>


<p><a name="stored_properties_and_instance_variables"></a></p>


<h3 id="-">存储属性和实例变量</h3>


<p>如果您有过 Objective-C 经验，应该知道有两种方式在类实例存储值和引用。对于属性来说，也可以使用实例变量作为属性值的后端存储。</p>


<p>Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的后端存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。
一个类型中属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>


<p><a name="computed_properties"></a></p>


<h2 id="-">计算属性</h2>


<p>除存储属性外，类、结构体和枚举可以定义<em>计算属性</em>，计算属性不直接存储值，而是提供一个 getter 来获取值，一个可选的 setter 来间接设置其他属性或变量的值。</p>


<pre><code>struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set(newCenter) {
        origin.x = newCenter.x - (size.width / 2)
        origin.y = newCenter.y - (size.height / 2)
    }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
println("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// 输出 "square.origin is now at (10.0, 10.0)”
</code></pre>


<p>这个例子定义了 3 个几何形状的结构体：</p>


<ul>
<li><code>Point</code>封装了一个<code>(x, y)</code>的坐标</li>
<li><code>Size</code>封装了一个<code>width</code>和<code>height</code></li>
<li><code>Rect</code>表示一个有原点和尺寸的矩形</li>
</ul>


<p><code>Rect</code>也提供了一个名为<code>center</code>的计算属性。一个矩形的中心点可以从原点和尺寸来算出，所以不需要将它以显式声明的<code>Point</code>来保存。<code>Rect</code>的计算属性<code>center</code>提供了自定义的 getter 和 setter 来获取和设置矩形的中心点，就像它有一个存储属性一样。</p>


<p>例子中接下来创建了一个名为<code>square</code>的<code>Rect</code>实例，初始值原点是<code>(0, 0)</code>，宽度高度都是<code>10</code>。如图所示蓝色正方形。</p>


<p><code>square</code>的<code>center</code>属性可以通过点运算符（<code>square.center</code>）来访问，这会调用 getter 来获取属性的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的<code>Point</code>来表示<code>square</code>的中心点。如代码所示，它正确返回了中心点<code>(5, 5)</code>。</p>


<p><code>center</code>属性之后被设置了一个新的值<code>(15, 15)</code>，表示向右上方移动正方形到如图所示橙色正方形的位置。设置属性<code>center</code>的值会调用 setter 来修改属性<code>origin</code>的<code>x</code>和<code>y</code>的值，从而实现移动正方形到新的位置。</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png" alt="Computed Properties sample" width="388" height="387"></p>


<p><a name="shorthand_setter_declaration"></a></p>


<h3 id="-setter-">便捷 setter 声明</h3>


<p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称<code>newValue</code>。下面是使用了便捷 setter 声明的<code>Rect</code>结构体代码：</p>


<pre><code>struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set {
        origin.x = newValue.x - (size.width / 2)
        origin.y = newValue.y - (size.height / 2)
    }
    }
}
</code></pre>


<p><a name="readonly_computed_properties"></a></p>


<h3 id="-">只读计算属性</h3>


<p>只有 getter 没有 setter 的计算属性就是<em>只读计算属性</em>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>


<blockquote>
<p>注意：</p>
<p>必须使用<code>var</code>关键字定义计算属性，包括只读计算属性，因为他们的值不是固定的。<code>let</code>关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>
</blockquote>


<p>只读计算属性的声明可以去掉<code>get</code>关键字和花括号：</p>


<pre><code>struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
    return width * height * depth
    }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
println("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// 输出 "the volume of fourByFiveByTwo is 40.0"
</code></pre>


<p>这个例子定义了一个名为<code>Cuboid</code>的结构体，表示三维空间的立方体，包含<code>width</code>、<code>height</code>和<code>depth</code>属性，还有一个名为<code>volume</code>的只读计算属性用来返回立方体的体积。设置<code>volume</code>的值毫无意义，因为通过<code>width</code>、<code>height</code>和<code>depth</code>就能算出<code>volume</code>。然而，<code>Cuboid</code>提供一个只读计算属性来让外部用户直接获取体积是很有用的。</p>


<p><a name="property_observers"></a></p>


<h2 id="-">属性监视器</h2>


<p><em>属性监视器</em>监控和响应属性值的变化，每次属性被设置值的时候都会调用属性监视器，甚至新的值和现在的值相同的时候也不例外。</p>


<p>可以为除了延迟存储属性之外的其他存储属性添加属性监视器，也可以通过重载属性的方式为继承的属性（包括存储属性和计算属性）添加属性监视器。属性重载请参考<a href="chapter/13_Inheritance.html">继承</a>一章的<a href="chapter/13_Inheritance.html#overriding">重载</a>。</p>


<blockquote>
<p>注意：</p>
<p>不需要为无法重载的计算属性添加属性监视器，因为可以通过 setter 直接监控和响应值的变化。</p>
</blockquote>


<p>可以为属性添加如下的一个或全部监视器：</p>


<ul>
<li><code>willSet</code>在设置新的值之前调用</li>
<li><code>didSet</code>在新的值被设置之后立即调用</li>
</ul>


<p><code>willSet</code>监视器会将新的属性值作为固定参数传入，在<code>willSet</code>的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称<code>newValue</code>表示。</p>


<p>类似地，<code>didSet</code>监视器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名<code>oldValue</code>。</p>


<blockquote>
<p>注意：</p>
<p><code>willSet</code>和<code>didSet</code>监视器在属性初始化过程中不会被调用，他们只会当属性的值在初始化之外的地方被设置时被调用。</p>
</blockquote>


<p>这里是一个<code>willSet</code>和<code>didSet</code>的实际例子，其中定义了一个名为<code>StepCounter</code>的类，用来统计当人步行时的总步数，可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>


<pre><code>class StepCounter {
    var totalSteps: Int = 0 {
    willSet(newTotalSteps) {
        println("About to set totalSteps to \(newTotalSteps)")
    }
    didSet {
        if totalSteps &gt; oldValue  {
            println("Added \(totalSteps - oldValue) steps")
        }
    }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
</code></pre>


<p><code>StepCounter</code>类定义了一个<code>Int</code>类型的属性<code>totalSteps</code>，它是一个存储属性，包含<code>willSet</code>和<code>didSet</code>监视器。</p>


<p>当<code>totalSteps</code>设置新值的时候，它的<code>willSet</code>和<code>didSet</code>监视器都会被调用，甚至当新的值和现在的值完全相同也会调用。</p>


<p>例子中的<code>willSet</code>监视器将表示新值的参数自定义为<code>newTotalSteps</code>，这个监视器只是简单的将新的值输出。</p>


<p><code>didSet</code>监视器在<code>totalSteps</code>的值改变后被调用，它把新的值和旧的值进行对比，如果总的步数增加了，就输出一个消息表示增加了多少步。<code>didSet</code>没有提供自定义名称，所以默认值<code>oldValue</code>表示旧值的参数名。</p>


<blockquote>
<p>注意：</p>
<p>如果在<code>didSet</code>监视器里为属性赋值，这个值会替换监视器之前设置的值。</p>
</blockquote>


<p><a name="global_and_local_variables"></a></p>


<h2 id="-">全局变量和局部变量</h2>


<p>计算属性和属性监视器所描述的模式也可以用于<em>全局变量</em>和<em>局部变量</em>，全局变量是在函数、方法、闭包或任何类型之外定义的变量，局部变量是在函数、方法或闭包内部定义的变量。</p>


<p>前面章节提到的全局或局部变量都属于存储型变量，跟存储属性类似，它提供特定类型的存储空间，并允许读取和写入。</p>


<p>另外，在全局或局部范围都可以定义计算型变量和为存储型变量定义监视器，计算型变量跟计算属性一样，返回一个计算的值而不是存储值，声明格式也完全一样。</p>


<blockquote>
<p>注意：</p>
<p>全局的常量或变量都是延迟计算的，跟<a href="#lazy_stored_properties">延迟存储属性</a>相似，不同的地方在于，全局的常量或变量不需要标记<code>@lazy</code>特性。</p>
<p>局部范围的常量或变量不会延迟计算。</p>
</blockquote>


<p><a name="type_properties"></a></p>


<h2 id="-">类型属性</h2>


<p>实例的属性属于一个特定类型实例，每次类型实例化后都拥有自己的一套属性值，实例之间的属性相互独立。</p>


<p>也可以为类型本身定义属性，不管类型有多少个实例，这些属性都只有唯一一份。这种属性就是<em>类型属性</em>。</p>


<p>类型属性用于定义特定类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>


<p>对于值类型（指结构体和枚举）可以定义存储型和计算型类型属性，对于类（class）则只能定义计算型类型属性。</p>


<p>值类型的存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算属性一样定义成变量属性。</p>


<blockquote>
<p>注意：</p>
<p>跟实例的存储属性不同，必须给存储型类型属性指定默认值，因为类型本身无法在初始化过程中使用构造器给类型属性赋值。</p>
</blockquote>


<p><a name="type_property_syntax"></a></p>


<h3 id="-">类型属性语法</h3>


<p>在 C 或 Objective-C 中，静态常量和静态变量的定义是通过特定类型加上<code>global</code>关键字。在 Swift 编程语言中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</p>


<p>使用关键字<code>static</code>来定义值类型的类型属性，关键字<code>class</code>来为类（class）定义类型属性。下面的例子演示了存储型和计算型类型属性的语法：</p>


<pre><code>struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
    // 这里返回一个 Int 值
    }
}
enum SomeEnumeration {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
    // 这里返回一个 Int 值
    }
}
class SomeClass {
    class var computedTypeProperty: Int {
    // 这里返回一个 Int 值
    }
}
</code></pre>


<blockquote>
<p>注意：</p>
<p>例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟实例计算属性的语法类似。</p>
</blockquote>


<p><a name="querying_and_setting_type_properties"></a></p>


<h3 id="-">获取和设置类型属性的值</h3>


<p>跟实例的属性一样，类型属性的访问也是通过点运算符来进行，但是，类型属性是通过类型本身来获取和设置，而不是通过实例。比如：</p>


<pre><code>println(SomeClass.computedTypeProperty)
// 输出 "42"

println(SomeStructure.storedTypeProperty)
// 输出 "Some value."
SomeStructure.storedTypeProperty = "Another value."
println(SomeStructure.storedTypeProperty)
// 输出 "Another value.”
</code></pre>


<p>下面的例子定义了一个结构体，使用两个存储型类型属性来表示多个声道的声音电平值，每个声道有一个 0 到 10 之间的整数表示声音电平值。</p>


<p>后面的图表展示了如何联合使用两个声道来表示一个立体声的声音电平值。当声道的电平值是 0，没有一个灯会亮；当声道的电平值是 10，所有灯点亮。本图中，左声道的电平是 9，右声道的电平是 7。</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png" alt="Static Properties VUMeter" width="243" height="357"></p>


<p>上面所描述的声道模型使用<code>AudioChannel</code>结构体来表示：</p>


<pre><code>struct AudioChannel {
    static let thresholdLevel = 10
    static var maxInputLevelForAllChannels = 0
    var currentLevel: Int = 0 {
    didSet {
        if currentLevel &gt; AudioChannel.thresholdLevel {
            // 将新电平值设置为阀值
            currentLevel = AudioChannel.thresholdLevel
        }
        if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {
            // 存储当前电平值作为新的最大输入电平
            AudioChannel.maxInputLevelForAllChannels = currentLevel
        }
    }
    }
}
</code></pre>


<p>结构<code>AudioChannel</code>定义了 2 个存储型类型属性来实现上述功能。第一个是<code>thresholdLevel</code>，表示声音电平的最大上限阈值，它是一个取值为 10 的常量，对所有实例都可见，如果声音电平高于 10，则取最大上限值 10（见后面描述）。</p>


<p>第二个类型属性是变量存储型属性<code>maxInputLevelForAllChannels</code>，它用来表示所有<code>AudioChannel</code>实例的电平值的最大值，初始值是 0。</p>


<p><code>AudioChannel</code>也定义了一个名为<code>currentLevel</code>的实例存储属性，表示当前声道现在的电平值，取值为 0 到 10。</p>


<p>属性<code>currentLevel</code>包含<code>didSet</code>属性监视器来检查每次新设置后的属性值，有如下两个检查：</p>


<ul>
<li>如果<code>currentLevel</code>的新值大于允许的阈值<code>thresholdLevel</code>，属性监视器将<code>currentLevel</code>的值限定为阈值<code>thresholdLevel</code>。</li>
<li>如果修正后的<code>currentLevel</code>值大于任何之前任意<code>AudioChannel</code>实例中的值，属性监视器将新值保存在静态属性<code>maxInputLevelForAllChannels</code>中。</li>
</ul>


<blockquote>
<p>注意：</p>
<p>在第一个检查过程中，<code>didSet</code>属性监视器将<code>currentLevel</code>设置成了不同的值，但这时不会再次调用属性监视器。</p>
</blockquote>


<p>可以使用结构体<code>AudioChannel</code>来创建表示立体声系统的两个声道<code>leftChannel</code>和<code>rightChannel</code>：</p>


<pre><code>var leftChannel = AudioChannel()
var rightChannel = AudioChannel()
</code></pre>


<p>如果将左声道的电平设置成 7，类型属性<code>maxInputLevelForAllChannels</code>也会更新成 7：</p>


<pre><code>leftChannel.currentLevel = 7
println(leftChannel.currentLevel)
// 输出 "7"
println(AudioChannel.maxInputLevelForAllChannels)
// 输出 "7"
</code></pre>


<p>如果试图将右声道的电平设置成 11，则会将右声道的<code>currentLevel</code>修正到最大值 10，同时<code>maxInputLevelForAllChannels</code>的值也会更新到 10：</p>


<pre><code>rightChannel.currentLevel = 11
println(rightChannel.currentLevel)
// 输出 "10"
println(AudioChannel.maxInputLevelForAllChannels)
// 输出 "10"
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6.html" itemprop="url">Swift字符串和字符</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><code>String</code>是例如“hello, world“”，“海贼王” 这样的有序的<code>Character</code>（字符）类型的值的集合，通过<code>String</code>类型来表示。</p>


<p>Swift 的<code>String</code>和<code>Character</code>类型提供了一个快速的，兼容 Unicode 的方式来处理代码中的文本信息。
创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。
字符串连接操作只需要简单地通过<code>+</code>号将两个字符串相连即可。
与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。</p>


<p>尽管语法简易，但<code>String</code>类型是一种快速、现代化的字符串实现。
每一个字符串都是由独立编码的 Unicode 字符组成，并提供了以不同 Unicode 表示（representations）来访问这些字符的支持。</p>


<p>Swift 可以在常量、变量、字面量和表达式中进行字符串插值操作，可以轻松创建用于展示、存储和打印的自定义字符串。</p>


<blockquote>
<p>注意：</p>
<p>Swift 的<code>String</code>类型与 Foundation <code>NSString</code>类进行了无缝桥接。如果您利用 Cocoa 或 Cocoa Touch 中的 Foundation 框架进行工作。所有<code>NSString</code> API 都可以调用您创建的任意<code>String</code>类型的值。除此之外，还可以使用本章介绍的<code>String</code>特性。您也可以在任意要求传入<code>NSString</code>实例作为参数的 API 中使用<code>String</code>类型的值作为替代。</p>
<p>更多关于在 Foundation 和 Cocoa 中使用<code>String</code>的信息请查看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank">Using Swift with Cocoa and Objective-C</a>。</p>
</blockquote>


<p><a name="string_literals"></a></p>


<h2 id="-string-literals-">字符串字面量（String Literals）</h2>


<p>您可以在您的代码中包含一段预定义的字符串值作为字符串字面量。
字符串字面量是由双引号 (&#8220;&#8221;) 包裹着的具有固定顺序的文本字符集。</p>


<p>字符串字面量可以用于为常量和变量提供初始值。</p>


<pre><code>let someString = "Some string literal value"
</code></pre>


<blockquote>
<p>注意：</p>
<p><code>someString</code>变量通过字符串字面量进行初始化，Swift 因此推断该变量为<code>String</code>类型。</p>
</blockquote>


<p>字符串字面量可以包含以下特殊字符：</p>


<ul>
<li>转义字符<code>\0</code>(空字符)、<code>\\</code>(反斜线)、<code>\t</code>(水平制表符)、<code>\n</code>(换行符)、<code>\r</code>(回车符)、<code>\"</code>(双引号)、<code>\'</code>(单引号)。</li>
<li>单字节 Unicode 标量，写成<code>\xnn</code>，其中<code>nn</code>为两位十六进制数。</li>
<li>双字节 Unicode 标量，写成<code>\unnnn</code>，其中<code>nnnn</code>为四位十六进制数。</li>
<li>四字节 Unicode 标量，写成<code>\Unnnnnnnn</code>，其中<code>nnnnnnnn</code>为八位十六进制数。</li>
</ul>


<p>下面的代码为各种特殊字符的使用示例。
<code>wiseWords</code>常量包含了两个转移特殊字符 (双括号)；
<code>dollarSign</code>、<code>blackHeart</code>和<code>sparklingHeart</code>常量演示了三种不同格式的 Unicode 标量：</p>


<pre><code>let wiseWords = "\"我是要成为海贼王的男人\" - 路飞"
// "我是要成为海贼王的男人" - 路飞
let dollarSign = "\x24"                // $,  Unicode 标量 U+0024
let blackHeart = "\u2665"              // ♥,  Unicode 标量 U+2665
let sparklingHeart = "\U0001F496"    // 💖, Unicode 标量 U+1F496
</code></pre>


<p><a name="initializing_an_empty_string"></a></p>


<h2 id="-initializing-an-empty-string-">初始化空字符串 (Initializing an Empty String)</h2>


<p>为了构造一个很长的字符串，可以创建一个空字符串作为初始值。
可以将空的字符串字面量赋值给变量，也可以初始化一个新的<code>String</code>实例：</p>


<pre><code>var emptyString = ""               // 空字符串字面量
var anotherEmptyString = String()  // 初始化 String 实例
// 两个字符串均为空并等价。
</code></pre>


<p>您可以通过检查其<code>Boolean</code>类型的<code>isEmpty</code>属性来判断该字符串是否为空：</p>


<pre><code>if emptyString.isEmpty {
    println("什么都没有")
}
// 打印输出："什么都没有"
</code></pre>


<p><a name="string_mutability"></a></p>


<h2 id="-string-mutability-">字符串可变性 (String Mutability)</h2>


<p>您可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：</p>


<pre><code>var variableString = "Horse"
variableString += " and carriage"
// variableString 现在为 "Horse and carriage"
let constantString = "Highlander"
constantString += " and another Highlander"
// 这会报告一个编译错误 (compile-time error) - 常量不可以被修改。
</code></pre>


<blockquote>
<p>注意：</p>
<p>在 Objective-C 和 Cocoa 中，您通过选择两个不同的类(<code>NSString</code>和<code>NSMutableString</code>)来指定该字符串是否可以被修改，Swift 中的字符串是否可以修改仅通过定义的是变量还是常量来决定，实现了多种类型可变性操作的统一。</p>
</blockquote>


<p><a name="strings_are_value_types"></a></p>


<h2 id="-strings-are-value-types-">字符串是值类型（Strings Are Value Types）</h2>


<p>Swift 的<code>String</code>类型是值类型。
如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作或在函数/方法中传递时，会进行值拷贝。
任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。
值类型在 <a href="09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a> 中进行了说明。</p>


<blockquote>
<p>注意：</p>
<p>与 Cocoa 中的<code>NSString</code>不同，当您在 Cocoa 中创建了一个<code>NSString</code>实例，并将其传递给一个函数/方法，或者赋值给一个变量，您传递或赋值的是该<code>NSString</code>实例的一个引用，除非您特别要求进行值拷贝，否则字符串不会生成新的副本来进行赋值操作。</p>
</blockquote>


<p>Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。
很明显无论该值来自于哪里，都是您独自拥有的。
您可以放心您传递的字符串本身不会被更改。</p>


<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>


<p><a name="working_with_characters"></a></p>


<h2 id="-working-with-characters-">使用字符（Working with Characters）</h2>


<p>Swift 的<code>String</code>类型表示特定序列的<code>Character</code>（字符） 类型值的集合。
每一个字符值代表一个 Unicode 字符。
您可利用<code>for-in</code>循环来遍历字符串中的每一个字符：</p>


<pre><code>for character in "Dog!🐶" {
    println(character)
}
// D
// o
// g
// !
// 🐶
</code></pre>


<p>for-in 循环在 <a href="05_Control_Flow.html#for_loops">For Loops</a> 中进行了详细描述。</p>


<p>另外，通过标明一个<code>Character</code>类型注解并通过字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p>


<pre><code>let yenSign: Character = "¥"
</code></pre>


<p><a name="counting_characters"></a></p>


<h2 id="-counting-characters-">计算字符数量 (Counting Characters)</h2>


<p>通过调用全局<code>countElements</code>函数，并将字符串作为参数进行传递，可以获取该字符串的字符数量。</p>


<pre><code>let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
println("unusualMenagerie has \(countElements(unusualMenagerie)) characters")
// 打印输出："unusualMenagerie has 40 characters"
</code></pre>


<blockquote>
<p>注意：</p>
<p>不同的 Unicode 字符以及相同 Unicode 字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间。因此字符串的长度不得不通过迭代字符串中每一个字符的长度来进行计算。如果您正在处理一个长字符串，需要注意<code>countElements</code>函数必须遍历字符串中的字符以精准计算字符串的长度。</p>
<p>另外需要注意的是通过<code>countElements</code>返回的字符数量并不总是与包含相同字符的<code>NSString</code>的<code>length</code>属性相同。<code>NSString</code>的<code>length</code>属性是基于利用 UTF-16 表示的十六位代码单元数字，而不是基于 Unicode 字符。为了解决这个问题，<code>NSString</code>的<code>length</code>属性在被 Swift 的<code>String</code>访问时会成为<code>utf16count</code>。</p>
</blockquote>


<p><a name="concatenating_strings_and_characters"></a></p>


<h2 id="-concatenating-strings-and-characters-">连接字符串和字符 (Concatenating Strings and Characters)</h2>


<p>字符串和字符的值可以通过加法运算符（<code>+</code>）相加在一起并创建一个新的字符串值：</p>


<pre><code>let string1 = "hello"
let string2 = " there"
let character1: Character = "!"
let character2: Character = "?"

let stringPlusCharacter = string1 + character1        // 等于 "hello!"
let stringPlusString = string1 + string2              // 等于 "hello there"
let characterPlusString = character1 + string1        // 等于 "!hello"
let characterPlusCharacter = character1 + character2  // 等于 "!?"
</code></pre>


<p>您也可以通过加法赋值运算符 (<code>+=</code>) 将一个字符串或者字符添加到一个已经存在字符串变量上：</p>


<pre><code>var instruction = "look over"
instruction += string2
// instruction 现在等于 "look over there"

var welcome = "good morning"
welcome += character1
// welcome 现在等于 "good morning!"
</code></pre>


<blockquote>
<p>注意：</p>
<p>您不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</p>
</blockquote>


<p><a name="string_interpolation"></a></p>


<h2 id="-string-interpolation-">字符串插值 (String Interpolation)</h2>


<p>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。
您插入的字符串字面量的每一项都被包裹在以反斜线为前缀的圆括号中：</p>


<pre><code>let multiplier = 3
let message = "\(multiplier) 乘以 2.5 是 \(Double(multiplier) * 2.5)"
// message 是 "3 乘以 2.5 是 7.5"
</code></pre>


<p>在上面的例子中，<code>multiplier</code>作为<code>\(multiplier)</code>被插入到一个字符串字面量中。
当创建字符串执行插值计算时此占位符会被替换为<code>multiplier</code>实际的值。</p>


<p><code>multiplier</code>的值也作为字符串中后面表达式的一部分。
该表达式计算<code>Double(multiplier) * 2.5</code>的值并将结果 (7.5) 插入到字符串中。
在这个例子中，表达式写为<code>\(Double(multiplier) * 2.5)</code>并包含在字符串字面量中。</p>


<blockquote>
<p>注意：</p>
<p>您插值字符串中写在括号中的表达式不能包含非转义双引号 (<code>"</code>) 和反斜杠 (<code>\</code>)，并且不能包含回车或换行符。</p>
</blockquote>


<p><a name="comparing_strings"></a></p>


<h2 id="-comparing-strings-">比较字符串 (Comparing Strings)</h2>


<p>Swift 提供了三种方式来比较字符串的值：字符串相等、前缀相等和后缀相等。</p>


<p><a name="string_equality"></a></p>


<h3 id="-string-equality-">字符串相等 (String Equality)</h3>


<p>如果两个字符串以同一顺序包含完全相同的字符，则认为两者字符串相等：</p>


<pre><code>let quotation = "我们是一样一样滴."
let sameQuotation = "我们是一样一样滴."
if quotation == sameQuotation {
    println("这两个字符串被认为是相同的")
}
// 打印输出："这两个字符串被认为是相同的"
</code></pre>


<p><a name="prefix_and_suffix_equality"></a></p>


<h3 id="-prefix-and-suffix-equality-">前缀/后缀相等 (Prefix and Suffix Equality)</h3>


<p>通过调用字符串的<code>hasPrefix</code>/<code>hasSuffix</code>方法来检查字符串是否拥有特定前缀/后缀。
两个方法均需要以字符串作为参数传入并传出<code>Boolean</code>值。
两个方法均执行基本字符串和前缀/后缀字符串之间逐个字符的比较操作。</p>


<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：</p>


<pre><code>let romeoAndJuliet = [
    "Act 1 Scene 1: Verona, A public place",
    "Act 1 Scene 2: Capulet's mansion",
    "Act 1 Scene 3: A room in Capulet's mansion",
    "Act 1 Scene 4: A street outside Capulet's mansion",
    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
    "Act 2 Scene 1: Outside Capulet's mansion",
    "Act 2 Scene 2: Capulet's orchard",
    "Act 2 Scene 3: Outside Friar Lawrence's cell",
    "Act 2 Scene 4: A street in Verona",
    "Act 2 Scene 5: Capulet's mansion",
    "Act 2 Scene 6: Friar Lawrence's cell"
]
</code></pre>


<p>您可以利用<code>hasPrefix</code>方法来计算话剧中第一幕的场景数：</p>


<pre><code>var act1SceneCount = 0
for scene in romeoAndJuliet {
    if scene.hasPrefix("Act 1 ") {
        ++act1SceneCount
    }
}
println("There are \(act1SceneCount) scenes in Act 1")
// 打印输出："There are 5 scenes in Act 1"
</code></pre>


<p>相似地，您可以用<code>hasSuffix</code>方法来计算发生在不同地方的场景数：</p>


<pre><code>“var mansionCount = 0
var cellCount = 0
for scene in romeoAndJuliet {
    if scene.hasSuffix("Capulet's mansion") {
        ++mansionCount
    } else if scene.hasSuffix("Friar Lawrence's cell") {
        ++cellCount
    }
}
println("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
// 打印输出："6 mansion scenes; 2 cell scenes”
</code></pre>


<p><a name="uppercase_and_lowercase_strings"></a></p>


<h3 id="-uppercase-and-lowercase-strings-">大写和小写字符串（Uppercase and Lowercase Strings）</h3>


<p>您可以通过字符串的<code>uppercaseString</code>和<code>lowercaseString</code>属性来访问大写/小写版本的字符串。</p>


<pre><code>let normal = "Could you help me, please?"
let shouty = normal.uppercaseString
// shouty 值为 "COULD YOU HELP ME, PLEASE?"
let whispered = normal.lowercaseString
// whispered 值为 "could you help me, please?"
</code></pre>


<p><a name="unicode"></a></p>


<h2 id="unicode">Unicode</h2>


<p>Unicode 是一个国际标准，用于文本的编码和表示。
它使您可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。</p>


<p>Swift 的字符串和字符类型是完全兼容 Unicode 标准的，它支持如下所述的一系列不同的 Unicode 编码。</p>


<p><a name="unicode_terminology"></a></p>


<h3 id="unicode-unicode-terminology-">Unicode 术语（Unicode Terminology）</h3>


<p>Unicode 中每一个字符都可以被解释为一个或多个 unicode 标量。
字符的 unicode 标量是一个唯一的21位数字(和名称)，例如<code>U+0061</code>表示小写的拉丁字母A (&#8220;a&#8221;)，<code>U+1F425</code>表示小鸡表情 (&#8220;🐥&#8221;)</p>


<p>当 Unicode 字符串被写进文本文件或其他存储结构当中，这些 unicode 标量将会按照 Unicode 定义的集中格式之一进行编码。其包括<code>UTF-8</code>（以8位代码单元进行编码） 和<code>UTF-16</code>（以16位代码单元进行编码）。</p>


<p><a name="unicode_representations_of_strings"></a></p>


<h3 id="-unicode-unicode-representations-of-strings-">字符串的 Unicode 表示（Unicode Representations of Strings）</h3>


<p>Swift 提供了几种不同的方式来访问字符串的 Unicode 表示。</p>


<p>您可以利用<code>for-in</code>来对字符串进行遍历，从而以 Unicode 字符的方式访问每一个字符值。
该过程在 <a href="#working_with_characters">使用字符</a> 中进行了描述。</p>


<p>另外，能够以其他三种 Unicode 兼容的方式访问字符串的值：</p>


<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的 Unicode 标量值集合 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>


<p>下面由<code>D``o``g``!</code>和<code>🐶</code>(<code>DOG FACE</code>，Unicode 标量为<code>U+1F436</code>)组成的字符串中的每一个字符代表着一种不同的表示：</p>


<pre><code>let dogString = "Dog!🐶"
</code></pre>


<p><a name="UTF-8"></a></p>


<h3 id="utf-8">UTF-8</h3>


<p>您可以通过遍历字符串的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示。
其为<code>UTF8View</code>类型的属性，<code>UTF8View</code>是无符号8位 (<code>UInt8</code>) 值的集合，每一个<code>UInt8</code>值都是一个字符的 UTF-8 表示：</p>


<pre><code>for codeUnit in dogString.utf8 {
    print("\(codeUnit) ")
}
print("\n")
// 68 111 103 33 240 159 144 182
</code></pre>


<p>上面的例子中，前四个10进制代码单元值 (68, 111, 103, 33) 代表了字符<code>D</code> <code>o</code> <code>g</code>和<code>!</code>，他们的 UTF-8 表示与 ASCII 表示相同。
后四个代码单元值 (240, 159, 144, 182) 是<code>DOG FACE</code>的4字节 UTF-8 表示。</p>


<p><a name="UTF-16"></a></p>


<h3 id="utf-16">UTF-16</h3>


<p>您可以通过遍历字符串的<code>utf16</code>属性来访问它的<code>UTF-16</code>表示。
其为<code>UTF16View</code>类型的属性，<code>UTF16View</code>是无符号16位 (<code>UInt16</code>) 值的集合，每一个<code>UInt16</code>都是一个字符的 UTF-16 表示：</p>


<pre><code>for codeUnit in dogString.utf16 {
    print("\(codeUnit) ")
}
print("\n")
// 68 111 103 33 55357 56374
</code></pre>


<p>同样，前四个代码单元值 (68, 111, 103, 33) 代表了字符<code>D</code> <code>o</code> <code>g</code>和<code>!</code>，他们的 UTF-16 代码单元和 UTF-8 完全相同。</p>


<p>第五和第六个代码单元值 (55357 和 56374) 是<code>DOG FACE</code>字符的UTF-16 表示。
第一个值为<code>U+D83D</code>(十进制值为 55357)，第二个值为<code>U+DC36</code>(十进制值为 56374)。</p>


<p><a name="unicode_scalars"></a></p>


<h3 id="unicode-unicode-scalars-">Unicode 标量 (Unicode Scalars)</h3>


<p>您可以通过遍历字符串的<code>unicodeScalars</code>属性来访问它的 Unicode 标量表示。
其为<code>UnicodeScalarView</code>类型的属性， <code>UnicodeScalarView</code>是<code>UnicodeScalar</code>的集合。
<code>UnicodeScalar</code>是21位的 Unicode 代码点。</p>


<p>每一个<code>UnicodeScalar</code>拥有一个值属性，可以返回对应的21位数值，用<code>UInt32</code>来表示。</p>


<pre><code>for scalar in dogString.unicodeScalars {
    print("\(scalar.value) ")
}
print("\n")
// 68 111 103 33 128054
</code></pre>


<p>同样，前四个代码单元值 (68, 111, 103, 33) 代表了字符<code>D</code> <code>o</code> <code>g</code>和<code>!</code>。
第五位数值，128054，是一个十六进制1F436的十进制表示。
其等同于<code>DOG FACE</code>的Unicode 标量 U+1F436。</p>


<p>作为查询字符值属性的一种替代方法，每个<code>UnicodeScalar</code>值也可以用来构建一个新的字符串值，比如在字符串插值中使用：</p>


<pre><code>for scalar in dogString.unicodeScalars {
    println("\(scalar) ")
}
// D
// o
// g
// !
// 🐶
</code></pre>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6.html" itemprop="url">Swift基本运算符</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>运算符是检查，改变，合并值的特殊符号或短语。例如，加号<code>+</code>将两个数相加（如<code>let i = 1 + 2</code>）。复杂些的运行算例如逻辑与运算符<code>&amp;&amp;</code>（如<code>if enteredDoorCode &amp;&amp; passedRetinaScan</code>），又或让 i 值加1的便捷运算符自增运算符<code>++i</code>等。</p>


<p>Swift 支持大部分标准 C 语言的运算符，且改进许多特性来减少常规编码错误。如，赋值符（<code>=</code>）不返回值，以防止把想要判断相等运算符（<code>==</code>）的地方写成赋值符导致的错误。数值运算符（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>等）会检测并不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。当然允许你使用 Swift 的溢出运算符来实现溢出。详情参见<a href="23_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>


<p>区别于 C 语言，在 Swift 中你可以对浮点数进行取余运算（<code>%</code>），Swift 还提供了 C 语言没有的表达两数之间的值的区间运算符，（<code>a..b</code>和<code>a...b</code>），这方便我们表达一个区间内的数值。</p>


<p>本章节只描述了 Swift 中的基本运算符，<a href="23_Advanced_Operators.html">高级运算符</a>包含了高级运算符，及如何自定义运算符，及如何进行自定义类型的运算符重载。</p>


<p><a name="terminology"></a></p>


<h2 id="-">术语</h2>


<p>运算符有一元，二元和三元运算符。</p>


<ul>
<li>一元运算符对单一操作对象操作（如<code>-a</code>）。一元运算符分前置符和后置运算符，前置运算符需紧排操作对象之前（如<code>!b</code>），后置运算符需紧跟操作对象之后（如<code>i++</code>）。</li>
<li>二元运算符操作两个操作对象（如<code>2 + 3</code>），是中置的，因为它们出现在两个操作对象之间。</li>
<li>三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三元条件运算符（<code>a ? b : c</code>）。</li>
</ul>


<p>受运算符影响的值叫操作数，在表达式<code>1 + 2</code>中，加号<code>+</code>是二元运算符，它的两个操作数是值<code>1</code>和<code>2</code>。</p>


<p><a name="assignment_operator"></a></p>


<h2 id="-">赋值运算符</h2>


<p>赋值运算（<code>a = b</code>），表示用<code>b</code>的值来初始化或更新<code>a</code>的值：</p>


<pre><code class="lang-swift">let b = 10
var a = 5
a = b
// a 现在等于 10
</code></pre>


<p>如果赋值的右边是一个多元组，它的元素可以马上被分解多个变量或变量：</p>


<pre><code>let (x, y) = (1, 2)
// 现在 x 等于 1, y 等于 2
</code></pre>


<p>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的：</p>


<pre><code class="lang-swift">if x = y {
    // 此句错误, 因为 x = y 并不返回任何值
}
</code></pre>


<p>这个特性使得你无法把（<code>==</code>）错写成（<code>=</code>）了，由于<code>if x = y</code>是错误代码，Swift 从底层帮你避免了这些代码错误。</p>


<p><a name="arithmetic_operators"></a></p>


<h2 id="-">数值运算</h2>


<p>Swift 让所有数值类型都支持了基本的四则运算：</p>


<ul>
<li>加法（<code>+</code>）</li>
<li>减法（<code>-</code>）</li>
<li>乘法（<code>*</code>）</li>
<li>除法（<code>/</code>）</li>
</ul>


<pre><code class="lang-swift">1 + 2       // 等于 3
5 - 3       // 等于 2
2 * 3       // 等于 6
10.0 / 2.5  // 等于 4.0
</code></pre>


<p>与 C 语言和 Objective-C 不同的是，Swift 默认不允许在数值运算中出现溢出情况。但你可以使用 Swift 的溢出运算符来达到你有目的的溢出（如<code>a &amp;+ b</code>）。详情参见<a href="23_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>


<p>加法运算符也用于<code>String</code>的拼接：</p>


<pre><code class="lang-swift">"hello, " + "world"  // 等于 "hello, world"
</code></pre>


<p>两个<code>Character</code>值或一个<code>String</code>和一个<code>Character</code>值，相加会生成一个新的<code>String</code>值：</p>


<pre><code class="lang-swift">let dog: Character = "d"
let cow: Character = "c"
let dogCow = dog + cow
// 译者注: 原来的引号内是很可爱的小狗和小牛, 但win os下不支持表情字符, 所以改成了普通字符
// dogCow 现在是 "dc"
</code></pre>


<p>详情参见<a href="03_Strings_and_Characters.html#concatenating_strings_and_characters">字符，字符串的拼接</a>。</p>


<h3 id="-">求余运算</h3>


<p>求余运算（<code>a % b</code>）是计算<code>b</code>的多少倍刚刚好可以容入<code>a</code>，返回多出来的那部分（余数）。</p>


<blockquote>
<p>注意：</p>
<p>求余运算（<code>%</code>）在其他语言也叫取模运算。然而严格说来，我们看该运算符对负数的操作结果，&#8221;求余&#8221;比&#8221;取模&#8221;更合适些。</p>
</blockquote>


<p>我们来谈谈取余是怎么回事，计算<code>9 % 4</code>，你先计算出<code>4</code>的多少倍会刚好可以容入<code>9</code>中：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png" alt="Art/remainderInteger_2x.png" title="Art/remainderInteger_2x.png"></p>


<p>2倍，非常好，那余数是1（用橙色标出）</p>


<p>在 Swift 中这么来表达：</p>


<pre><code class="lang-swift">9 % 4    // 等于 1
</code></pre>


<p>为了得到<code>a % b</code>的结果，<code>%</code>计算了以下等式，并输出<code>余数</code>作为结果：</p>


<p><em>a = (b × 倍数) + 余数</em></p>


<p>当<code>倍数</code>取最大值的时候，就会刚好可以容入<code>a</code>中。</p>


<p>把<code>9</code>和<code>4</code>代入等式中，我们得<code>1</code>：</p>


<pre><code class="lang-swift">9 = (4 × 2) + 1
</code></pre>


<p>同样的方法，我来们计算 <code>-9 % 4</code>：</p>


<pre><code class="lang-swift">-9 % 4   // 等于 -1
</code></pre>


<p>把<code>-9</code>和<code>4</code>代入等式，<code>-2</code>是取到的最大整数：</p>


<pre><code class="lang-swift">-9 = (4 × -2) + -1
</code></pre>


<p>余数是<code>-1</code>。</p>


<p>在对负数<code>b</code>求余时，<code>b</code>的符号会被忽略。这意味着 <code>a % b</code> 和 <code>a % -b</code>的结果是相同的。</p>


<h3 id="-">浮点数求余计算</h3>


<p>不同于 C 语言和 Objective-C，Swift 中是可以对浮点数进行求余的。</p>


<pre><code class="lang-swift">8 % 2.5 // 等于 0.5
</code></pre>


<p>这个例子中，<code>8</code>除于<code>2.5</code>等于<code>3</code>余<code>0.5</code>，所以结果是一个<code>Double</code>值<code>0.5</code>。</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderFloat_2x.png" alt="Art/remainderFloat_2x.png" title="Art/remainderFloat_2x.png"></p>


<h3 id="-">自增和自增运算</h3>


<p>和 C 语言一样，Swift 也提供了方便对变量本身加1或减1的自增（<code>++</code>）和自减（<code>--</code>）的运算符。其操作对象可以是整形和浮点型。
&zwnj;</p>


<pre><code class="lang-swift">var i = 0
++i      // 现在 i = 1
</code></pre>


<p>每调用一次<code>++i</code>，<code>i</code>的值就会加1。实际上，<code>++i</code>是<code>i = i + 1</code>的简写，而<code>--i</code>是<code>i = i - 1</code>的简写。</p>


<p><code>++</code>和<code>--</code>既是前置又是后置运算。<code>++i</code>，<code>i++</code>，<code>--i</code>和<code>i--</code>都是有效的写法。</p>


<p>我们需要注意的是这些运算符修改了<code>i</code>后有一个返回值。如果你只想修改<code>i</code>的值，那你就可以忽略这个返回值。但如果你想使用返回值，你就需要留意前置和后置操作的返回值是不同的。</p>


<ul>
<li><p>当<code>++</code>前置的时候，先自増再返回。</p>
</li>
<li><p>当<code>++</code>后置的时候，先返回再自增。</p>
</li>
</ul>


<p>例如：</p>


<pre><code class="lang-swift">var a = 0
let b = ++a // a 和 b 现在都是 1
let c = a++ // a 现在 2, 但 c 是 a 自增前的值 1
</code></pre>


<p>上述例子，<code>let b = ++a</code>先把<code>a</code>加1了再返回<code>a</code>的值。所以<code>a</code>和<code>b</code>都是新值<code>1</code>。</p>


<p>而<code>let c = a++</code>，是先返回了<code>a</code>的值，然后<code>a</code>才加1。所以<code>c</code>得到了<code>a</code>的旧值1，而<code>a</code>加1后变成2。</p>


<p>除非你需要使用<code>i++</code>的特性，不然推荐你使用<code>++i</code>和<code>--i</code>，因为先修改后返回这样的行为更符合我们的逻辑。</p>


<h3 id="-">一元负号</h3>


<p>数值的正负号可以使用前缀<code>-</code>（即一元负号）来切换：</p>


<pre><code class="lang-swift">let three = 3
let minusThree = -three       // minusThree 等于 -3
let plusThree = -minusThree   // plusThree 等于 3, 或 "负负3"
</code></pre>


<p>一元负号（<code>-</code>）写在操作数之前，中间没有空格。</p>


<h3 id="-">一元正号</h3>


<p>一元正号（<code>+</code>）不做任何改变地返回操作数的值。</p>


<pre><code class="lang-swift">let minusSix = -6
let alsoMinusSix = +minusSix  // alsoMinusSix 等于 -6
</code></pre>


<p>虽然一元<code>+</code>做无用功，但当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。</p>


<p><a name="compound_assignment_operators"></a></p>


<h2 id="-compound-assignment-operators-">复合赋值（Compound Assignment Operators）</h2>


<p>如同强大的 C 语言，Swift 也提供把其他运算符和赋值运算（<code>=</code>）组合的复合赋值运算符，加赋运算（<code>+=</code>）是其中一个例子：</p>


<pre><code class="lang-swift">var a = 1
a += 2 // a 现在是 3
</code></pre>


<p>表达式<code>a += 2</code>是<code>a = a + 2</code>的简写，一个加赋运算就把加法和赋值两件事完成了。</p>


<blockquote>
<p>注意：</p>
<p>复合赋值运算没有返回值，<code>let b = a += 2</code>这类代码是错误。这不同于上面提到的自增和自减运算符。</p>
</blockquote>


<p>在<a href="../chapter3/04_Expressions.html">表达式</a>章节里有复合运算符的完整列表。
&zwnj;
<a name="comparison_operators"></a></p>


<h2 id="-">比较运算</h2>


<p>所有标准 C 语言中的比较运算都可以在 Swift 中使用。</p>


<ul>
<li>等于（<code>a == b</code>）</li>
<li>不等于（<code>a！= b</code>）</li>
<li>大于（<code>a &gt; b</code>）</li>
<li>小于（<code>a &lt; b</code>）</li>
<li>大于等于（<code>a &gt;= b</code>）</li>
<li>小于等于（<code>a &lt;= b</code>）</li>
</ul>


<blockquote>
<p>注意：</p>
<p>Swift 也提供恒等<code>===</code>和不恒等<code>!==</code>这两个比较符来判断两个对象是否引用同一个对象实例。更多细节在<a href="09_Classes_and_Structures.html">类与结构</a>。</p>
</blockquote>


<p>每个比较运算都返回了一个标识表达式是否成立的布尔值：</p>


<pre><code class="lang-swift">1 == 1   // true, 因为 1 等于 1
2 != 1   // true, 因为 2 不等于 1
2 &gt; 1    // true, 因为 2 大于 1
1 &lt; 2    // true, 因为 1 小于2
1 &gt;= 1   // true, 因为 1 大于等于 1
2 &lt;= 1   // false, 因为 2 并不小于等于 1
</code></pre>


<p>比较运算多用于条件语句，如<code>if</code>条件：</p>


<pre><code class="lang-swift">let name = "world"
if name == "world" {
    println("hello, world")
} else {
    println("I'm sorry \(name), but I don't recognize you")
}
// 输出 "hello, world", 因为 `name` 就是等于 "world"
</code></pre>


<p>关于<code>if</code>语句，请看<a href="05_Control_Flow.html">控制流</a>。</p>


<p><a name="ternary_conditional_operator"></a></p>


<h2 id="-ternary-conditional-operator-">三元条件运算(Ternary Conditional Operator)</h2>


<p>三元条件运算的特殊在于它是有三个操作数的运算符，它的原型是<code>问题？答案1：答案2</code>。它简洁地表达根据<code>问题</code>成立与否作出二选一的操作。如果<code>问题</code>成立，返回<code>答案1</code>的结果; 如果不成立，返回<code>答案2</code>的结果。</p>


<p>使用三元条件运算简化了以下代码：</p>


<pre><code class="lang-swift">if question: {
    answer1
}
else {
    answer2
}
</code></pre>


<p>这里有个计算表格行高的例子。如果有表头，那行高应比内容高度要高出50像素; 如果没有表头，只需高出20像素。</p>


<pre><code class="lang-swift">let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)
// rowHeight 现在是 90
</code></pre>


<p>这样写会比下面的代码简洁：</p>


<pre><code class="lang-swift">let contentHeight = 40
let hasHeader = true
var rowHeight = contentHeight
if hasHeader {
    rowHeight = rowHeight + 50
} else {
    rowHeight = rowHeight + 20
}
// rowHeight 现在是 90
</code></pre>


<p>第一段代码例子使用了三元条件运算，所以一行代码就能让我们得到正确答案。这比第二段代码简洁得多，无需将<code>rowHeight</code>定义成变量，因为它的值无需在<code>if</code>语句中改变。</p>


<p>三元条件运算提供有效率且便捷的方式来表达二选一的选择。需要注意的事，过度使用三元条件运算就会由简洁的代码变成难懂的代码。我们应避免在一个组合语句使用多个三元条件运算符。</p>


<p><a name="range_operators"></a></p>


<h2 id="-">区间运算符</h2>


<p>Swift 提供了两个方便表达一个区间的值的运算符。</p>


<h3 id="-">闭区间运算符</h3>


<p>闭区间运算符（<code>a...b</code>）定义一个包含从<code>a</code>到<code>b</code>(包括<code>a</code>和<code>b</code>)的所有值的区间。
&zwnj;
闭区间运算符在迭代一个区间的所有值时是非常有用的，如在<code>for-in</code>循环中：</p>


<pre><code class="lang-swift">for index in 1...5 {
      println("\(index) * 5 = \(index * 5)")
}
// 1 * 5 = 5
// 2 * 5 = 10
// 3 * 5 = 15
// 4 * 5 = 20
// 5 * 5 = 25
</code></pre>


<p>关于<code>for-in</code>，请看<a href="05_Control_Flow.html">控制流</a>。</p>


<h3 id="-">半闭区间</h3>


<p>半闭区间（<code>a..b</code>）定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间。
之所以称为半闭区间，是因为该区间包含第一个值而不包括最后的值。</p>


<p>半闭区间的实用性在于当你使用一个0始的列表(如数组)时，非常方便地从0数到列表的长度。</p>


<pre><code class="lang-swift">let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..count {
    println("第 \(i + 1) 个人叫 \(names[i])")
}
// 第 1 个人叫 Anna
// 第 2 个人叫 Alex
// 第 3 个人叫 Brian
// 第 4 个人叫 Jack
</code></pre>


<p>数组有4个元素，但<code>0..count</code>只数到3(最后一个元素的下标)，因为它是半闭区间。关于数组，请查阅<a href="04_Collection_Types.html#arrays">数组</a>。</p>


<p><a name="logical_operators"></a></p>


<h2 id="-">逻辑运算</h2>


<p>逻辑运算的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p>


<ul>
<li>逻辑非（<code>!a</code>）</li>
<li>逻辑与（<code>a &amp;&amp; b</code>）</li>
<li>逻辑或（<code>a || b</code>）</li>
</ul>


<h3 id="-">逻辑非</h3>


<p>逻辑非运算（<code>!a</code>）对一个布尔值取反，使得<code>true</code>变<code>false</code>，<code>false</code>变<code>true</code>。</p>


<p>它是一个前置运算符，需出现在操作数之前，且不加空格。读作<code>非 a</code>，然后我们看以下例子：</p>


<pre><code class="lang-swift">let allowedEntry = false
if !allowedEntry {
    println("ACCESS DENIED")
}
// 输出 "ACCESS DENIED"
</code></pre>


<p><code>if！allowedEntry</code>语句可以读作 &#8220;如果 非 alowed entry。&#8221;，接下一行代码只有在如果 &#8220;非 allow entry&#8221; 为<code>true</code>，即<code>allowEntry</code>为<code>false</code>时被执行。</p>


<p>在示例代码中，小心地选择布尔常量或变量有助于代码的可读性，并且避免使用双重逻辑非运算，或混乱的逻辑语句。</p>


<h3 id="-">逻辑与</h3>


<p>逻辑与（<code>a &amp;&amp; b</code>）表达了只有<code>a</code>和<code>b</code>的值都为<code>true</code>时，整个表达式的值才会是<code>true</code>。</p>


<p>只要任意一个值为<code>false</code>，整个表达式的值就为<code>false</code>。事实上，如果第一个值为<code>false</code>，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。这被称做 &#8220;短路计算（short-circuit evaluation）&#8221;。</p>


<p>以下例子，只有两个<code>Bool</code>值都为<code>true</code>值的时候才允许进入：</p>


<pre><code class="lang-swift">let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode &amp;&amp; passedRetinaScan {
    println("Welcome!")
} else {
    println("ACCESS DENIED")
}
// 输出 "ACCESS DENIED"
</code></pre>


<h3 id="-">逻辑或</h3>


<p>逻辑或（<code>a || b</code>）是一个由两个连续的<code>|</code>组成的中置运算符。它表示了两个逻辑表达式的其中一个为<code>true</code>，整个表达式就为<code>true</code>。</p>


<p>同逻辑与运算类似，逻辑或也是&#8221;短路计算&#8221;的，当左端的表达式为<code>true</code>时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。</p>


<p>以下示例代码中，第一个布尔值（<code>hasDoorKey</code>）为<code>false</code>，但第二个值（<code>knowsOverridePassword</code>）为<code>true</code>，所以整个表达是<code>true</code>，于是允许进入：</p>


<pre><code class="lang-swift">let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    println("Welcome!")
} else {
    println("ACCESS DENIED")
}
// 输出 "Welcome!"
</code></pre>


<h3 id="-">组合逻辑</h3>


<p>我们可以组合多个逻辑运算来表达一个复合逻辑：</p>


<pre><code class="lang-swift">if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {
    println("Welcome!")
} else {
    println("ACCESS DENIED")
}
// 输出 "Welcome!"
</code></pre>


<p>这个例子使用了含多个<code>&amp;&amp;</code>和<code>||</code>的复合逻辑。但无论怎样，<code>&amp;&amp;</code>和<code>||</code>始终只能操作两个值。所以这实际是三个简单逻辑连续操作的结果。我们来解读一下：</p>


<p>如果我们输入了正确的密码并通过了视网膜扫描; 或者我们有一把有效的钥匙; 又或者我们知道紧急情况下重置的密码，我们就能把门打开进入。</p>


<p>前两种情况，我们都不满足，所以前两个简单逻辑的结果是<code>false</code>，但是我们是知道紧急情况下重置的密码的，所以整个复杂表达式的值还是<code>true</code>。</p>


<h3 id="-">使用括号来明确优先级</h3>


<p>为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。在上个关于门的权限的例子中，我们给第一个部分加个括号，使用它看起来逻辑更明确：</p>


<pre><code class="lang-swift">if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    println("Welcome!")
} else {
    println("ACCESS DENIED")
}
// 输出 "Welcome!"
</code></pre>


<p>这括号使得前两个值被看成整个逻辑表达中独立的一个部分。虽然有括号和没括号的输出结果是一样的，但对于读代码的人来说有括号的代码更清晰。可读性比简洁性更重要，请在可以让你代码变清晰地地方加个括号吧！</p>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
    	<div class="date">








  



Nov 27,&nbsp 2014  </div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/Swift%E5%8D%8F%E8%AE%AE.html#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/Swift%E5%8D%8F%E8%AE%AE.html" itemprop="url">Swif协议</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><code>Protocol(协议)</code>用于<strong>统一</strong>方法和属性的名称，而不实现任何功能。<code>协议</code>能够被类，枚举，结构体实现，满足协议要求的类，枚举，结构体被称为协议的<code>遵循者</code>。</p>


<p><code>遵循者</code>需要提供<code>协议</code>指定的成员，如属性，方法，操作符，下标等。</p>


<p><a name="protocol_syntax"></a></p>


<h2 id="-">协议的语法</h2>


<p><code>协议</code>的定义与类，结构体，枚举的定义非常相似，如下所示：</p>


<pre><code>protocol SomeProtocol {
    // 协议内容
}
</code></pre>


<p>在类，结构体，枚举的名称后加上<code>协议名称</code>，中间以冒号<code>:</code>分隔即可实现协议；实现多个协议时，各协议之间用逗号<code>,</code>分隔，如下所示：</p>


<pre><code>struct SomeStructure: FirstProtocol, AnotherProtocol {
    // 结构体内容
}
</code></pre>


<p>当某个类含有父类的同时并实现了协议，应当把父类放在所有的协议之前，如下所示：</p>


<pre><code>class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
    // 类的内容
}
</code></pre>


<p><a name="property_requirements"></a></p>


<h2 id="-">属性要求</h2>


<p><code>协议</code>能够要求其<code>遵循者</code>必须含有一些<strong>特定名称和类型</strong>的<code>实例属性(instance property)</code>或<code>类属性 (type property)</code>，也能够要求属性的<code>(设置权限)settable</code> 和<code>(访问权限)gettable</code>，但它不要求<code>属性</code>是<code>存储型属性(stored property)</code>还是<code>计算型属性(calculate property)</code>。</p>


<p>通常前置<code>var</code>关键字将属性声明为变量。在属性声明后写上<code>{ get set }</code>表示属性为可读写的。<code>{ get }</code>用来表示属性为可读的。即使你为可读的属性实现了<code>setter</code>方法，它也不会出错。</p>


<pre><code>protocol SomeProtocol {
    var musBeSettable : Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>


<p>用类来实现协议时，使用<code>class</code>关键字来表示该属性为类成员；用结构体或枚举实现协议时，则使用<code>static</code>关键字来表示：</p>


<pre><code>protocol AnotherProtocol {
    class var someTypeProperty: Int { get set }
}

protocol FullyNamed {
    var fullName: String { get }
}
</code></pre>


<p><code>FullyNamed</code>协议含有<code>fullName</code>属性。因此其<code>遵循者</code>必须含有一个名为<code>fullName</code>，类型为<code>String</code>的可读属性。</p>


<pre><code>struct Person: FullyNamed{
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
//john.fullName 为 "John Appleseed"
</code></pre>


<p><code>Person</code>结构体含有一个名为<code>fullName</code>的<code>存储型属性</code>，完整的<code>遵循</code>了协议。(<em>若协议未被完整遵循，编译时则会报错</em>)。</p>


<p>如下所示，<code>Startship</code>类<code>遵循</code>了<code>FullyNamed</code>协议：</p>


<pre><code>class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: Stirng? = nil ) {
        self.anme = name
        self.prefix = prefix
    }
    var fullName: String {
    return (prefix ? prefix ! + " " : " ") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName == "USS Enterprise"
</code></pre>


<p><code>Starship</code>类将<code>fullName</code>实现为可读的<code>计算型属性</code>。它的每一个实例都有一个名为<code>name</code>的必备属性和一个名为<code>prefix</code>的可选属性。 当<code>prefix</code>存在时，将<code>prefix</code>插入到<code>name</code>之前来为<code>Starship</code>构建<code>fullName</code>。</p>


<p><a name="method_requirements"></a></p>


<h2 id="-">方法要求</h2>


<p><code>协议</code>能够要求其<code>遵循者</code>必备某些特定的<code>实例方法</code>和<code>类方法</code>。协议方法的声明与普通方法声明相似，但它不需要<code>方法</code>内容。</p>


<blockquote>
<p>注意：</p>
<p>协议方法支持<code>变长参数(variadic parameter)</code>，不支持<code>默认参数(default parameter)</code>。</p>
</blockquote>


<p>前置<code>class</code>关键字表示协议中的成员为<code>类成员</code>；当协议用于被<code>枚举</code>或<code>结构体</code>遵循时，则使用<code>static</code>关键字。如下所示：</p>


<pre><code>protocol SomeProtocol {
    class func someTypeMethod()
}

protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>


<p><code>RandomNumberGenerator</code>协议要求其<code>遵循者</code>必须拥有一个名为<code>random</code>， 返回值类型为<code>Double</code>的实例方法。(我们假设随机数在[0，1]区间内)。</p>


<p><code>LinearCongruentialGenerator</code>类<code>遵循</code>了<code>RandomNumberGenerator</code>协议，并提供了一个叫做<em>线性同余生成器(linear congruential generator)</em>的伪随机数算法。</p>


<pre><code>class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
println("Here's a random number: \(generator.random())")
// 输出 : "Here's a random number: 0.37464991998171"
println("And another one: \(generator.random())")
// 输出 : "And another one: 0.729023776863283"
</code></pre>


<p><a name="mutating_method_requirements"></a></p>


<h2 id="-">突变方法要求</h2>


<p>能在<code>方法</code>或<code>函数</code>内部改变实例类型的方法称为<code>突变方法</code>。在<code>值类型(Value Type)</code>(<em>译者注：特指结构体和枚举</em>)中的的<code>函数</code>前缀加上<code>mutating</code>关键字来表示该函数允许改变该实例和其属性的类型。 这一变换过程在<a href="11_Methods.html#instance_methods">实例方法(Instance Methods)</a>章节中有详细描述。</p>


<p>(<em>译者注：类中的成员为<code>引用类型(Reference Type)</code>，可以方便的修改实例及其属性的值而无需改变类型；而<code>结构体</code>和<code>枚举</code>中的成员均为<code>值类型(Value Type)</code>，修改变量的值就相当于修改变量的类型，而<code>Swift</code>默认不允许修改类型，因此需要前置<code>mutating</code>关键字用来表示该<code>函数</code>中能够修改类型</em>)</p>


<blockquote>
<p>注意：</p>
<p>用<code>class</code>实现协议中的<code>mutating</code>方法时，不用写<code>mutating</code>关键字；用<code>结构体</code>，<code>枚举</code>实现协议中的<code>mutating</code>方法时，必须写<code>mutating</code>关键字。</p>
</blockquote>


<p>如下所示，<code>Togglable</code>协议含有<code>toggle</code>函数。根据函数名称推测，<code>toggle</code>可能用于<strong>切换或恢复</strong>某个属性的状态。<code>mutating</code>关键字表示它为<code>突变方法</code>：</p>


<pre><code>protocol Togglable {
    mutating func toggle()
}
</code></pre>


<p>当使用<code>枚举</code>或<code>结构体</code>来实现<code>Togglabl</code>协议时，必须在<code>toggle</code>方法前加上<code>mutating</code>关键字。</p>


<p>如下所示，<code>OnOffSwitch</code>枚举<code>遵循</code>了<code>Togglable</code>协议，<code>On</code>，<code>Off</code>两个成员用于表示当前状态</p>


<pre><code>enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = On
        case On:
            self = Off
        }
    }
}
var lightSwitch = OnOffSwitch.Off
lightSwitch.toggle()
//lightSwitch 现在的值为 .On
</code></pre>


<p><a name="protocols_as_types"></a></p>


<h2 id="-">协议类型</h2>


<p><code>协议</code>本身不实现任何功能，但你可以将它当做<code>类型</code>来使用。</p>


<p>使用场景：</p>


<ul>
<li>作为函数，方法或构造器中的参数类型，返回值类型</li>
<li>作为常量，变量，属性的类型</li>
<li>作为数组，字典或其他容器中的元素类型</li>
</ul>


<blockquote>
<p>注意：</p>
<p>协议类型应与其他类型(Int，Double，String)的写法相同，使用驼峰式</p>
</blockquote>


<pre><code>class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) +1
    }
}
</code></pre>


<p>这里定义了一个名为 <code>Dice</code>的类，用来代表桌游中的N个面的骰子。</p>


<p> <code>Dice</code>含有<code>sides</code>和<code>generator</code>两个属性，前者用来表示骰子有几个面，后者为骰子提供一个随机数生成器。由于后者为<code>RandomNumberGenerator</code>的协议类型。所以它能够被赋值为任意<code>遵循</code>该协议的类型。</p>


<p>此外，使用<code>构造器(init)</code>来代替之前版本中的<code>setup</code>操作。构造器中含有一个名为<code>generator</code>，类型为<code>RandomNumberGenerator</code>的形参，使得它可以接收任意遵循<code>RandomNumberGenerator</code>协议的类型。</p>


<p><code>roll</code>方法用来模拟骰子的面值。它先使用<code>generator</code>的<code>random</code>方法来创建一个[0-1]区间内的随机数种子，然后加工这个随机数种子生成骰子的面值。</p>


<p>如下所示，<code>LinearCongruentialGenerator</code>的实例作为随机数生成器传入<code>Dice</code>的<code>构造器</code></p>


<pre><code>var d6 = Dice(sides: 6,generator: LinearCongruentialGenerator())
for _ in 1...5 {
    println("Random dice roll is \(d6.roll())")
}
//输出结果
//Random dice roll is 3
//Random dice roll is 5
//Random dice roll is 4
//Random dice roll is 5
//Random dice roll is 4
</code></pre>


<p><a name="delegation"></a></p>


<h2 id="-">委托(代理)模式</h2>


<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能<code>交由(委托)</code>给其他的类型。</p>


<p>委托模式的实现很简单： 定义<code>协议</code>来<code>封装</code>那些需要被委托的<code>函数和方法</code>， 使其<code>遵循者</code>拥有这些被委托的<code>函数和方法</code>。</p>


<p>委托模式可以用来响应特定的动作或接收外部数据源提供的数据，而无需要知道外部数据源的类型。</p>


<p>下文是两个基于骰子游戏的协议：</p>


<pre><code>protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(game: DiceGame)
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int)
    func gameDidEnd(game: DiceGame)
}
</code></pre>


<p><code>DiceGame</code>协议可以在任意含有骰子的游戏中实现，<code>DiceGameDelegate</code>协议可以用来追踪<code>DiceGame</code>的游戏过程。</p>


<p>如下所示，<code>SnakesAndLadders</code>是<code>Snakes and Ladders</code>(译者注：<a href="05_Control_Flow.html">控制流</a>章节有该游戏的详细介绍)游戏的新版本。新版本使用<code>Dice</code>作为骰子，并且实现了<code>DiceGame</code>和<code>DiceGameDelegate</code>协议</p>


<pre><code>class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dic = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: Int[]
    init() {
        board = Int[](count: finalSquare + 1, repeatedValue: 0)
        board[03] = +08; board[06] = +11; borad[09] = +09; board[10] = +02
        borad[14] = -10; board[19] = -11; borad[22] = -02; board[24] = -08
    }
     var delegate: DiceGameDelegate?
     func play() {
         square = 0
         delegate?.gameDidStart(self)
         gameLoop: while square != finalSquare {
             let diceRoll = dice.roll()
             delegate?.game(self,didStartNewTurnWithDiceRoll: diceRoll)
             switch square + diceRoll {
             case finalSquare:
                 break gameLoop
             case let newSquare where newSquare &gt; finalSquare:
                 continue gameLoop
             default:
             square += diceRoll
             square += board[square]
             }
         }
         delegate?.gameDIdEnd(self)
     }
}
</code></pre>


<p>游戏的<code>初始化设置(setup)</code>被<code>SnakesAndLadders</code>类的<code>构造器(initializer)</code>实现。所有的游戏逻辑被转移到了<code>play</code>方法中。</p>


<blockquote>
<p>注意：</p>
<p>因为<code>delegate</code>并不是该游戏的必备条件，<code>delegate</code>被定义为遵循<code>DiceGameDelegate</code>协议的可选属性</p>
</blockquote>


<p><code>DicegameDelegate</code>协议提供了三个方法用来追踪游戏过程。被放置于游戏的逻辑中，即<code>play()</code>方法内。分别在游戏开始时，新一轮开始时，游戏结束时被调用。</p>


<p>因为<code>delegate</code>是一个遵循<code>DiceGameDelegate</code>的可选属性，因此在<code>play()</code>方法中使用了<code>可选链</code>来调用委托方法。 若<code>delegate</code>属性为<code>nil</code>， 则委托调用<em>优雅地</em>失效。若<code>delegate</code>不为<code>nil</code>，则委托方法被调用</p>


<p>如下所示，<code>DiceGameTracker</code>遵循了<code>DiceGameDelegate</code>协议</p>


<pre><code>class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            println("Started a new game of Snakes and Ladders")
        }
        println("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        ++numberOfTurns
        println("Rolled a \(diceRoll)")
    }
    func gameDidEnd(game: DiceGame) {
        println("The game lasted for \(numberOfTurns) turns")
    }
}
</code></pre>


<p><code>DiceGameTracker</code>实现了<code>DiceGameDelegate</code>协议的方法要求，用来记录游戏已经进行的轮数。 当游戏开始时，<code>numberOfTurns</code>属性被赋值为0；在每新一轮中递加；游戏结束后，输出打印游戏的总轮数。</p>


<p><code>gameDidStart</code>方法从<code>game</code>参数获取游戏信息并输出。<code>game</code>在方法中被当做<code>DiceGame</code>类型而不是<code>SnakeAndLadders</code>类型，所以方法中只能访问<code>DiceGame</code>协议中的成员。</p>


<p><code>DiceGameTracker</code>的运行情况，如下所示：</p>


<pre><code>“let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns”
</code></pre>


<p><a name="adding_protocol_conformance_with_an_extension"></a></p>


<h2 id="-">在扩展中添加协议成员</h2>


<p>即便无法修改源代码，依然可以通过<code>扩展(Extension)</code>来扩充已存在类型(<em>译者注： 类，结构体，枚举等</em>)。<code>扩展</code>可以为已存在的类型添加<code>属性</code>，<code>方法</code>，<code>下标</code>，<code>协议</code>等成员。详情请在<a href="20_Extensions.html">扩展</a>章节中查看。</p>


<blockquote>
<p>注意：</p>
<p>通过<code>扩展</code>为已存在的类型<code>遵循</code>协议时，该类型的所有实例也会随之添加协议中的方法</p>
</blockquote>


<p><code>TextRepresentable</code>协议含有一个<code>asText</code>，如下所示：</p>


<pre><code>protocol TextRepresentable {
    func asText() -&gt; String
}
</code></pre>


<p>通过<code>扩展</code>为上一节中提到的<code>Dice</code>类遵循<code>TextRepresentable</code>协议</p>


<pre><code>extension Dice: TextRepresentable {
    cun asText() -&gt; String {
        return "A \(sides)-sided dice"
    }
}
</code></pre>


<p>从现在起，<code>Dice</code>类型的实例可被当作<code>TextRepresentable</code>类型：</p>


<pre><code>let d12 = Dice(sides: 12,generator: LinearCongruentialGenerator())
println(d12.asText())
// 输出 "A 12-sided dice"
</code></pre>


<p><code>SnakesAndLadders</code>类也可以通过<code>扩展</code>的方式来遵循协议：</p>


<pre><code>extension SnakeAndLadders: TextRepresentable {
    func asText() -&gt; String {
        return "A game of Snakes and Ladders with \(finalSquare) squares"
    }
}
println(game.asText())
// 输出 "A game of Snakes and Ladders with 25 squares"
</code></pre>


<p><a name="declaring_protocol_adoption_with_an_extension"></a></p>


<h2 id="-">通过延展补充协议声明</h2>


<p>当一个类型已经实现了协议中的所有要求，却没有声明时，可以通过<code>扩展</code>来补充协议声明：</p>


<pre><code>struct Hamster {
    var name: String
    func asText() -&gt; String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentabl {}
</code></pre>


<p>从现在起，<code>Hamster</code>的实例可以作为<code>TextRepresentable</code>类型使用</p>


<pre><code>let simonTheHamster = Hamster(name: "Simon")
let somethingTextRepresentable: TextRepresentabl = simonTheHamester
println(somethingTextRepresentable.asText())
// 输出 "A hamster named Simon"
</code></pre>


<blockquote>
<p>注意：</p>
<p>即时满足了协议的所有要求，类型也不会自动转变，因此你必须为它做出明显的协议声明</p>
</blockquote>


<p><a name="collections_of_protocol_types"></a></p>


<h2 id="-">集合中的协议类型</h2>


<p>协议类型可以被集合使用，表示集合中的元素均为协议类型：</p>


<pre><code>let things: TextRepresentable[] = [game,d12,simoTheHamster]
</code></pre>


<p>如下所示，<code>things</code>数组可以被直接遍历，并调用其中元素的<code>asText()</code>函数：</p>


<pre><code>for thing in things {
    println(thing.asText())
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
</code></pre>


<p><code>thing</code>被当做是<code>TextRepresentable</code>类型而不是<code>Dice</code>，<code>DiceGame</code>，<code>Hamster</code>等类型。因此能且仅能调用<code>asText</code>方法</p>


<p><a name="protocol_inheritance"></a></p>


<h2 id="-">协议的继承</h2>


<p>协议能够<em>继承</em>一到多个其他协议。语法与类的继承相似，多个协议间用逗号<code>,</code>分隔</p>


<pre><code>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 协议定义
}
</code></pre>


<p>如下所示，<code>PrettyTextRepresentable</code>协议继承了<code>TextRepresentable</code>协议</p>


<pre><code>protocol PrettyTextRepresentable: TextRepresentable {
    func asPrettyText() -&gt; String
}
</code></pre>


<p><code>遵循``PrettyTextRepresentable</code>协议的同时，也需要<code>遵循</code>TextRepresentable`协议。</p>


<p>如下所示，用<code>扩展</code>为<code>SnakesAndLadders</code>遵循<code>PrettyTextRepresentable</code>协议：</p>


<pre><code>extension SnakesAndLadders: PrettyTextRepresentable {
    func asPrettyText() -&gt; String {
        var output = asText() + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
                case let ladder where ladder &gt; 0:
                output += "▲ "
            case let snake where snake &lt; 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}
</code></pre>


<p>在<code>for in</code>中迭代出了<code>board</code>数组中的每一个元素：</p>


<ul>
<li>当从数组中迭代出的元素的值大于0时，用<code>▲</code>表示</li>
<li>当从数组中迭代出的元素的值小于0时，用<code>▼</code>表示</li>
<li>当从数组中迭代出的元素的值等于0时，用<code>○</code>表示</li>
</ul>


<p>任意<code>SankesAndLadders</code>的实例都可以使用<code>asPrettyText()</code>方法。</p>


<pre><code>println(game.asPrettyText())
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
</code></pre>


<p><a name="protocol_composition"></a></p>


<h2 id="-">协议合成</h2>


<p>一个协议可由多个协议采用<code>protocol&lt;SomeProtocol, AnotherProtocol&gt;</code>这样的格式进行组合，称为<code>协议合成(protocol composition)</code>。</p>


<p>举个例子：</p>


<pre><code>protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(celebrator: protocol&lt;Named, Aged&gt;) {
    println("Happy birthday \(celebrator.name) - you're \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Malcolm", age: 21)
wishHappyBirthday(birthdayPerson)
// 输出 "Happy birthday Malcolm - you're 21!
</code></pre>


<p><code>Named</code>协议包含<code>String</code>类型的<code>name</code>属性；<code>Aged</code>协议包含<code>Int</code>类型的<code>age</code>属性。<code>Person</code>结构体<code>遵循</code>了这两个协议。</p>


<p><code>wishHappyBirthday</code>函数的形参<code>celebrator</code>的类型为<code>protocol&lt;Named,Aged&gt;</code>。可以传入任意<code>遵循</code>这两个协议的类型的实例</p>


<blockquote>
<p>注意：</p>
<p><code>协议合成</code>并不会生成一个新协议类型，而是将多个协议合成为一个临时的协议，超出范围后立即失效。</p>
</blockquote>


<p><a name="checking_for_protocol_conformance"></a></p>


<h2 id="-">检验协议的一致性</h2>


<p>使用<code>is</code>检验协议一致性，使用<code>as</code>将协议类型<code>向下转换(downcast)</code>为的其他协议类型。检验与转换的语法和之前相同(<em>详情查看<a href="18_Type_Casting.html">类型检查</a></em>)：</p>


<ul>
<li><code>is</code>操作符用来检查实例是否<code>遵循</code>了某个<code>协议</code>。</li>
<li><code>as?</code>返回一个可选值，当实例<code>遵循</code>协议时，返回该协议类型；否则返回<code>nil</code></li>
<li><code>as</code>用以强制向下转换型。</li>
</ul>


<pre><code>@objc protocol HasArea {
    var area: Double { get }
}
</code></pre>


<blockquote>
<p>注意：</p>
<p><code>@objc</code>用来表示协议是可选的，也可以用来表示暴露给<code>Objective-C</code>的代码，此外，<code>@objc</code>型协议只对<code>类</code>有效，因此只能在<code>类</code>中检查协议的一致性。详情查看<em><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank">Using Siwft with Cocoa and Objectivei-c</a></em>。</p>
</blockquote>


<pre><code>class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area:≈radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}
</code></pre>


<p><code>Circle</code>和<code>Country</code>都遵循了<code>HasArea</code>协议，前者把<code>area</code>写为计算型属性（computed property），后者则把<code>area</code>写为存储型属性（stored property）。</p>


<p>如下所示，<code>Animal</code>类没有实现任何协议</p>


<pre><code>class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
</code></pre>


<p><code>Circle,Country,Animal</code>并没有一个相同的基类，所以采用<code>AnyObject</code>类型的数组来装载在他们的实例，如下所示：</p>


<pre><code>let objects: AnyObject[] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]
</code></pre>


<p>如下所示，在迭代时检查<code>object</code>数组的元素是否<code>遵循</code>了<code>HasArea</code>协议：</p>


<pre><code>for object in objects {
    if let objectWithArea = object as? HasArea {
        println("Area is \(objectWithArea.area)")
    } else {
        println("Something that doesn't have an area")
    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn't have an area
</code></pre>


<p>当数组中的元素遵循<code>HasArea</code>协议时，通过<code>as?</code>操作符将其<code>可选绑定(optional binding)</code>到<code>objectWithArea</code>常量上。</p>


<p><code>objects</code>数组中元素的类型并不会因为<code>向下转型</code>而改变，当它们被赋值给<code>objectWithArea</code>时只被视为<code>HasArea</code>类型，因此只有<code>area</code>属性能够被访问。</p>


<p><a name="optional_protocol_requirements"></a></p>


<h2 id="-">可选协议要求</h2>


<p>可选协议含有可选成员，其<code>遵循者</code>可以选择是否实现这些成员。在协议中使用<code>@optional</code>关键字作为前缀来定义可选成员。</p>


<p>可选协议在调用时使用<code>可选链</code>，详细内容在<a href="17_Optional_Chaining.html">可选链</a>章节中查看。</p>


<p>像<code>someOptionalMethod?(someArgument)</code>一样，你可以在可选方法名称后加上<code>?</code>来检查该方法是否被实现。<code>可选方法</code>和<code>可选属性</code>都会返回一个<code>可选值(optional value)</code>，当其不可访问时，<code>?</code>之后语句不会执行，并返回<code>nil</code>。</p>


<blockquote>
<p>注意：</p>
<p>可选协议只能在含有<code>@objc</code>前缀的协议中生效。且<code>@objc</code>的协议只能被<code>类</code>遵循。</p>
</blockquote>


<p><code>Counter</code>类使用<code>CounterDataSource</code>类型的外部数据源来提供<code>增量值(increment amount)</code>，如下所示：</p>


<pre><code>@objc protocol CounterDataSource {
    @optional func incrementForCount(count: Int) -&gt; Int
    @optional var fixedIncrement: Int { get }
}
</code></pre>


<p><code>CounterDataSource</code>含有<code>incrementForCount</code>的<code>可选方法</code>和<code>fiexdIncrement</code>的<code>可选属性</code>。</p>


<blockquote>
<p>注意：</p>
<p><code>CounterDataSource</code>中的属性和方法都是可选的，因此可以在类中声明但不实现这些成员，尽管技术上允许这样做，不过最好不要这样写。</p>
</blockquote>


<p><code>Counter</code>类含有<code>CounterDataSource?</code>类型的可选属性<code>dataSource</code>，如下所示：</p>


<pre><code>@objc class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement? {
            count += amount
        }
    }
}
</code></pre>


<p><code>count</code>属性用于存储当前的值，<code>increment</code>方法用来为<code>count</code>赋值。</p>


<p><code>increment</code>方法通过<code>可选链</code>，尝试从两种<code>可选成员</code>中获取<code>count</code>。</p>


<ol>
<li>由于<code>dataSource</code>可能为<code>nil</code>，因此在<code>dataSource</code>后边加上了<code>?</code>标记来表明只在<code>dataSource</code>非空时才去调用incrementForCount`方法。</li>
<li>即使<code>dataSource</code>存在，但是也无法保证其是否实现了<code>incrementForCount</code>方法，因此在<code>incrementForCount</code>方法后边也加有<code>?</code>标记。</li>
</ol>


<p>在调用<code>incrementForCount</code>方法后，<code>Int</code>型<code>可选值</code>通过<code>可选绑定(optional binding)</code>自动拆包并赋值给常量<code>amount</code>。</p>


<p>当<code>incrementForCount</code>不能被调用时，尝试使用<code>可选属性``fixedIncrement</code>来代替。</p>


<p><code>ThreeSource</code>实现了<code>CounterDataSource</code>协议，如下所示：</p>


<pre><code>class ThreeSource: CounterDataSource {
    let fixedIncrement = 3
}
</code></pre>


<p>使用<code>ThreeSource</code>作为数据源开实例化一个<code>Counter</code>：</p>


<pre><code>var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    println(counter.count)
}
// 3
// 6
// 9
// 12
</code></pre>


<p><code>TowardsZeroSource</code>实现了<code>CounterDataSource</code>协议中的<code>incrementForCount</code>方法，如下所示：</p>


<pre><code>class TowardsZeroSource: CounterDataSource {
func incrementForCount(count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>


<p>下边是执行的代码：</p>


<pre><code>counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    println(counter.count)
}
// -3
// -2
// -1
// 0
// 0
</code></pre>


		
		
	</div>

</article>

</div>
<nav id="pagenavi">

    
    
    
       <a href="/pages/3" class="prev">上一页</a>
    
    
        <a href="/pages/5" class="next">下一页</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    小巴


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	
</body>
</html>
