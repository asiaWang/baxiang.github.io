<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>MySQL总结</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">jvm<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label8" class="tags__li tags-btn">网络<span class="post_count"></span></li>
          <li id="js-label9" class="tags__li tags-btn">工作<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/09/11/ThreadLocal%20%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">ThreadLocal 分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/04/MapReduce%20Algorithms.html"><span class="pl__circle"></span><span class="pl__title">MapReduce Algorithms</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/09/03/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Skyline监控系统工作原理分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%20timeseries%E5%BC%82%E5%B8%B8%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Skyline timeseries异常判定算法</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">排序总结</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"><span class="pl__circle"></span><span class="pl__title">快速排序</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">几个常见的概率问题</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/31/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html"><span class="pl__circle"></span><span class="pl__title">常见的HTTP状态码</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/28/BloomFilter.html"><span class="pl__circle"></span><span class="pl__title">BloomFilter</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="jvm pl__all" href="/jvm/2014/07/27/gc.html"><span class="pl__circle"></span><span class="pl__title">JVM GC调优</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">二叉树的各种遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C总结 + 虚拟内存</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache 与 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">MySQL总结</h1>
  <div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">一. 事务</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://en.wikipedia.org/wiki/Isolation_%28database_systems%29" style="background: transparent; margin-top: 0px;" target="_blank">WIKI</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">事务并发会导致各类问题，SQL 标准预定义了4种事务隔离级别，以满足不同程度的并发。每种隔离级别都能保证解决若干并发问题。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. 事务的 ACID</h2>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead style="margin-top: 0px;">
<tr style="margin-top: 0px;">
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;"></th>
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">Explaination</th>
</tr>
</thead>
<tbody>
<tr style="margin-top: 0px;">
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;">Atomic</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">原子，要么一起完成要么都不做</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;">Consistency</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">事务开始前和结束后数据都是满足约束规则的，如外键约束</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;">Isolation</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">隔离性，并发事务之间不会互相影响，就像串行执行一样</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;">Duaration</td>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD;">持久性，事务造成的修改是持久的，故障也不会丢失</td>
</tr>
</tbody>
</table>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. 并发事务产生的问题</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">第一类丢失更新 ( <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">回滚丢失</code>)。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在 A 进行期间，B 做了更新；A 如果回滚，B 的更新丢失。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">所有隔离级别都不会发生这种现象</p>
</blockquote></li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">脏读（<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">Dirty Read</code>）：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">A 看到 B 进行中更新的数据，并以此为根据继续执行相关的操作；B 回滚，导致 A 操作的是脏数据。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">不可重复读（<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">Non-repeatable Read</code>）：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">A 先查询一次数据，然后 B 更新之并提交，A 再次查询，得到和上一次不同的查询结果。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">幻读（<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">Phantom Read</code>）：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">A 查询一批数据，B 插入或删除了某些记录并提交，A 再次查询，发现结果集中出现了上次没有的记录，或者上次有的记录消失了。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">第二类丢失更新 (<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">覆盖丢失</code>)：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">A 和 B 查询同样的记录，各自 <strong style="font-weight: bold; margin-top: 0px;">基于最初查询的结果</strong> 更新记录并提交，后提交的数据将覆盖先提交的，导致最终数据错误。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">并发进行自增 / 自减是发生覆盖丢失的一个典型场景：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1409971482166.png" name="4ab7a1fa-077a-4de4-bfb8-f54b5baae0ea" src="/assets/img/a532fd94ccd31a031bd3700865b231c9.png" style="border: 0; margin-top: 0px; max-width: 100%;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">其中一个事务的更新被另外一个覆盖了，最终导致 i 错误。</p>
</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. 4个事务隔离级别</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">read uncommited</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最弱，事务的所有动作对其他事务都是立即可见的。存在脏读、不可重复读、第二类丢失更新、幻读问题（全部并发问题都有）。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">read commited</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只能读到其他事务已提交的数据，中间状态的数据则看不到，解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">脏读</code>问题。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">repeatable read</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">InnoDB的默认隔离级别。</strong></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">不可重复读</code>的问题，保证在一个事务内，对同一条记录的重复读都是一致的。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">依然存在幻读、第二类丢失更新问题。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">InnoDB 在 Repeatable Read 隔离级别下提供了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">phantom read</code>的解决方案：</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">引入<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">range lock</code>区间锁，读/写时，除了对满足条件的记录加锁，记录之间的区间也加锁，保证不会出现区间内的插入操作。</p>
</blockquote></li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">serial</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最高，所有事务都是串行的。啥并发问题都没有。</p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">总结：</p>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead style="margin-top: 0px;">
<tr style="margin-top: 0px;">
<th style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;"></th>
<th style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">dirty read</th>
<th style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">non-repeatable read</th>
<th style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">phantom read</th>
<th style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">第二类丢失更新</th>
</tr>
</thead>
<tbody>
<tr style="margin-top: 0px;">
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;">read uncommited</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;">read commited</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">X</code></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;">repeatable read</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">X</code></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">X</code></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;">√</td>
</tr>
<tr>
<td style="padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border: 1px solid #DDD; margin-top: 0px;">serial</td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">X</code></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">X</code></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">X</code></td>
<td style="text-align: center; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #DDD;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">X</code></td>
</tr>
</tbody>
</table>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">二. 并发控制</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">数据库通常通过锁来实现上述隔离级别。数据库能够根据设置的隔离级别自动管理事务内的锁，不需要开发人员关心；不过数据库也支持显式加锁，对于当前隔离级别无法解决的并发问题，我们需要在事务中自己控制记录的锁定和解锁（悲观锁），或在程序中使用（基于版本或更新时间的）乐观锁。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">InnoDB 在锁的基础上还搭配了 MVCC 作为优化，实现以上事务隔离级别。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. 锁</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">锁优化1：拆分，读写锁</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">读锁 -- 共享锁 -- shared<br style="margin-top: 0px;"/>写锁 -- 排他锁 -- exclusive</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">锁优化2：降低粒度，表锁 &amp; 行锁</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><em style="margin-top: 0px;">表锁由 mysql服务器 实现，行锁由 存储引擎 实现。</em></p>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">表锁</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">显式的表锁：<br style="margin-top: 0px;"/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">lock table xxx read/write;</code></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MyISAM几乎完全依赖MySQL服务器提供的表锁机制。</p>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">使用MyISAM时注意对表锁的优化：</h4>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">缩短锁定时间：拆分query / 索引</li>
<li style="line-height: 1.6;">打开concurrent insert(在尾部并发insert)</li>
<li style="line-height: 1.6;">根据需要设置读写的优先级。默认写大于读</li>
</ol>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">行锁</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">InnoDB实现了行锁，基于索引的 index-row locking，<strong style="font-weight: bold; margin-top: 0px;">如果锁了次级索引中的记录，则对应主索引中的记录也会被锁住</strong>。</p>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">查询锁的争用情况</h4>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">表锁<br style="margin-top: 0px;"/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">show status like 'table%'</code><br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">Table_locks_immediate</code>:立即获得表锁的次数<br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">Table_locks_waited</code>:需要等待获得表锁的次数</li>
<li style="line-height: 1.6;">innodb的行锁<br style="margin-top: 0px;"/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">show status like 'innodb_row_lock'</code><br/>current_waits:<br/>waits:<br/>time:<br/>time_avg:<br/>time_max:</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">update/delete/insert 动作会自动加x锁。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">查询时也可以设置显式加锁：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">select... lock in shared mode</code>: s lock</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">select... for update</code>: x lock</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">two-phase locking protocol</code>：事务内部获得的锁在提交时一起释放</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. MVCC</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">InnoDB 并不仅仅使用上述的锁机制控制并发，它还搭配了另外一种用于提高并发度的被称为 “Multi-Version Concurrency Control 多版本并发控制” 机制一起使用。简单的说，MVCC为某条记录创建多个snapshot，不同事务读取各自的snapshot，互不影响，它可以认为是对锁机制的一种优化，它在很多情况下避免了锁的使用：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">使普通的select避免加锁，提高并发</li>
<li style="line-height: 1.6;">不用锁也能实现 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">read commited</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">repeatable read</code> 事务隔离级别的语义</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">MVCC 只工作在RC &amp; RR两个隔离级别下，Read uncommited 隔离级别不支持 MVCC，在这个级别下每次都是读取最新版本的数据行；Serializable 也不支持 MVCC，该级别下每个 read 动作都会为记录加上读锁。</strong></p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">MySQL的两种read方式</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">snapshot read(non-lock) / consistent read</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">current read(lock) / lock read</code>:</li>
</ol>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">a. "snapshot read"</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">普通的select就是snapshot read，读 MVCC 的快照，不加锁, 但是不同的隔离级别中的行为是不一样的:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">RC: 最近的snapshot  -- read commited，看到其他事务的动作</li>
<li style="line-height: 1.6;">RR: 事务开始时的snapshot  -- <strong style="font-weight: bold; margin-top: 0px;">repeatable  read</strong>，一致性</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">可以看到，snapshot read 在RC和RR中的工作方式都满足其隔离级别的定义。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-consistent-read.html" style="background: transparent; margin-top: 0px;" target="_blank">Consistent Nonlocking read</a></p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">If the transaction isolation level is REPEATABLE READ (the default level), all consistent reads within the same transaction read the snapshot established by the first such read in that transaction. </p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">You can get a fresher snapshot for your queries by committing the current transaction and after that issuing new queries.</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">With READ COMMITTED isolation level, each consistent read within a transaction sets and reads its own fresh snapshot.</p>
</blockquote><h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">b. "current read / lock read"</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">lock read 操作的是数据的最新版本，且对记录加锁。以下动作属于 lock read：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">select... lock in shared mode</code>: s lock</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">select... for update</code>: x lock</li>
<li style="line-height: 1.6;">DML（insert/delete/update）也属于 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">lock read</code></li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-locking-reads.html" style="background: transparent; margin-top: 0px;" target="_blank">SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE MODE Locking Reads</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在 <strong style="font-weight: bold; margin-top: 0px;">在RR隔离级别上</strong> ，lock read 除了会加记录锁，还会为记录之间的间隙加上<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">gap lock</code>，从而解决<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">phantom read</code>问题。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. gap lock &amp; phantom read</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">repeatable read</code>级别上, <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">lock read</code> 时使用了 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">gap-key lock</code> 解决 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">phathom read</code> 问题: 不仅锁找到的记录，还锁区间，保证区间内的值无法被插入。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">注意，无法使用索引时会走主索引实现全表扫描，此时会给所有的记录加上record lock，并对其所有的区间加gap lock，表完全锁死，此时只能进行 snapshot read，极大地降低并发，这就是为何update/delete尽量要走索引的原因。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">注意：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">普通的 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">snapshot read</code> 依然有<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">phantom read</code>，只能保证<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">可重复读</code>；只有 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">lock read</code> 既解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">phantom read</code>，又保证了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">可重复读</code>。</li>
<li style="line-height: 1.6;">RC级别的 lock read 没有<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">gap lock</code>，只会加 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">record lock</code>。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://hedengcheng.com/?p=771" style="background: transparent; margin-top: 0px;" target="_blank">何登成的《MySQL 加锁处理分析》</a><br/><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-record-level-locks.html" style="background: transparent;" target="_blank">innodb-record-level-locks`</a></p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">MySQL/InnoDB定义的4种隔离级别：</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Read Uncommited<br style="margin-top: 0px;"/>可以读取未提交记录。此隔离级别，不会使用，忽略。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Read Committed (RC)<br style="margin-top: 0px;"/>快照读忽略，本文不考虑。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">针对当前读，RC隔离级别保证对读取到的记录加锁 (记录锁)，存在幻读现象。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Repeatable Read (RR)<br style="margin-top: 0px;"/>快照读忽略，本文不考虑。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">针对当前读，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Serializable<br style="margin-top: 0px;"/>从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。</p>
</blockquote><hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">三. 优化query (粗略)</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">定位瓶颈</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">IO or CPU?</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">工具</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">explain &amp; profile</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">基本原则</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">join时小结果集驱动大结果集</li>
<li style="line-height: 1.6;">利用索引完成排序/分组</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">只取需要的列（？）<br style="margin-top: 0px;"/> a. network<br/> b. 不能使用Covering index<br/> c. 优化排序</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">仅仅使用最有效的过滤条件<br style="margin-top: 0px;"/> 建立索引的字段越小越好，减少IO</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">避免复杂join和子查询<br style="margin-top: 0px;"/> 对于MyISAM，join会锁住所有相关的表（s lock），可能阻塞DML其他很长时间，此时可以在程序中做join，降低对锁的占用，减少阻塞；<br/> 对应用而言，SQL的执行时间：网络/执行（CPU+IO）/锁阻塞，优化瓶颈<br/> 子查询实现不好，不一定会走索引</p>
</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">Explain</h2>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">四. 索引</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://www.percona.com/files/presentations/percona-live/london-2011/PLUK2011-practical-mysql-indexing-guidelines.pdf" style="background: transparent; margin-top: 0px;" target="_blank">Practical MySQL indexing guidelines</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MyISAM 和 InnoDB 的索引，采用的数据结构都是B+树。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. B树和B+树</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">B树</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">B树的结构类似二叉查找树，只不过节点的度远远大于2，查找的复杂度为树的高度，O(logdN)：<br style="margin-top: 0px;"/><img alt="Alt text" class="en-media" longdesc="./1402812459074.png" name="6110437c-cb5b-4148-9a0d-9cbea5a7d5fd" src="/assets/img/81bb92fa7c27d9aef499efc82c4aaa73.png" style="border: 0; max-width: 100%;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">通常会将根据硬盘上一个page的大小来调整节点的度，原因是：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">基于外存的查找数据结构中，性能的瓶颈在于IO，这样的处理一可以让一个节点只需要一次IO</li>
<li style="line-height: 1.6;">二可以显著降低树的高度，查找时只需几次page的IO即可定位到目标。</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">B+树</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">B+树是对B树的优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">只有叶子节点存data，内节点只存key；<br style="margin-top: 0px;"/>好处：<strong style="font-weight: bold;"> 提高内节点的度，降低高度 </strong></p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">叶子节点加上了next指针，形成一个链表<br style="margin-top: 0px;"/>好处：<strong style="font-weight: bold;"> 快速范围查找，只需确定起点和终点，顺序扫描即可 </strong></p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1402813534888.png" name="f3392b7b-c733-4b80-ba43-d51f8cc1cf8c" src="/assets/img/9467b1f6665fb48464f4699db1a4bec2.png" style="border: 0; margin-top: 0px; max-width: 100%;"/></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. MyISAM的索引</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">索引和数据分离，数据文件：堆表(按插入有序)</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">主键索引和非主键索引结构一致，叶子节点存储的是行的物理位置信息（row number）</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1402813593672.png" name="a8cab548-fa57-4191-90c6-5ff93e80c322" src="/assets/img/10b0700762cf9c5bfd97396ccfb7c8b3.png" style="border: 0; margin-top: 0px; max-width: 100%;"/></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. InnoDB的索引</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">primary index（主键索引）</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">数据文件就是主键索引文件，叶子节点存真实数据，这种方式称为 <strong style="font-weight: bold; margin-top: 0px;">聚集索引</strong>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果没有主键，InnoDB会试着使用一个Unique Nonnullable index代替；如果没有这种索引，会定义隐藏的主键。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1410230989377.png" name="69e914e7-8cfa-4a69-a08e-4483af84d5e5" src="/assets/img/f83dae9c2efa594efdea1adc45fb31d7.png" style="border: 0; margin-top: 0px; max-width: 100%;"/></p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">secondary index</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">非主键上的索引称为次级索引，叶子节点存 <strong style="font-weight: bold; margin-top: 0px;">主键</strong>，此时需要查找两次。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">优缺点</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优点： 将相关数据保存在一起，减少IO；MyISAM访问每个行都得访问数据文件</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">缺点：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">B+树的节点按page聚集，存储着数据，因此主索引叶子节点分裂的机会远远大于非聚集索引；split会导致 <ul style="margin-top: 0px; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">移动大量数据; </li>
<li style="line-height: 1.6;">需要更多空间（碎片）; </li>
<li style="line-height: 1.6;">split时会给整个索引加x锁，不可访问</li>
</ul>
</li>
<li style="line-height: 1.6;">按主键顺序插入最快，因为记录被顺序插到索引的最末，节点 split 的开销很小；乱序插入慢，因为新记录很大机会被插入到已满的叶子节点，引起频繁分裂，因此 InnoDB <strong style="font-weight: bold; margin-top: 0px;">更适合用自增主键</strong>；</li>
<li style="line-height: 1.6;">secondary index包含了主键，体积可能很大，因此 <strong style="font-weight: bold; margin-top: 0px;">不适合用过长字段当主键</strong>；</li>
<li style="line-height: 1.6;">在secondary index上可能需要查找两次，一次查自己，一次查主索引。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">4. 什么样的查询条件会走索引?</h2>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">区分<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">范围查询</code>和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px;">等值查询</code></p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">in</code>是多个等值查询，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px;">between</code>二者都有可能。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">范围查询</strong> 使用索引的方式，是先确定起点，再根据叶子节点组成的链表顺序扫描，直到终点。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">等值查询</strong> 则是从上到下搜索树。</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">假如有索引<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">&lt;a,b,c,d&gt;</code>：</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 最左前缀的等值查询</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">一旦出现空洞，后面的列就不能使用索引了，但空洞可以用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">in所有值</code>填充</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 范围查询</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只有第一个出现的范围查询及其前面的列（前提是要构成最左前缀）可以使用索引，后面的即使构成最左前缀也不会走索引。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">因此，较常进行范围查询的列要放在索引的后面。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 字符串<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">%</code>如果放在开头则无法走索引</h3>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">5. 建立索引时的优化</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 不适合创建索引的情况</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;"><strong style="font-weight: bold; margin-top: 0px;">唯一性太差的列</strong><br/>引擎根据统计信息会做优化，可能建了也不走</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;"><strong style="font-weight: bold; margin-top: 0px;">频繁更新的列</strong><br/>需要同时维护索引和数据    </p>
</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 前缀索引 和 selectivity（选择性）</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题：列太长，太消耗空间；解决方案：用前缀建立索引<br style="margin-top: 0px;"/>但是又要保证良好的selectivity<br/>selectivity = (distinct values) / all records</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 尽量使用多列复合索引而不是多个单列索引</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">减少维护索引的开销<br style="margin-top: 0px;"/>多个单列索引老版本只会选一个，5.0以后可以用index merge，扫描多个再合并结果（or/and）</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">d) 选择正确的列顺序</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">一般来说选择性高的放前面，在最初阶段就可以排除大部分记录，减少后续需要考察的数据量；</li>
<li style="line-height: 1.6;">最常用的放在前面，范围查询的字段尽量靠后。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">6. 查询优化</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 查询条件中不要对列做运算，否则无法使用索引；</h3>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 使用“覆盖索引”技巧</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">Covering index: 覆盖了查询的所有列，避免访问数据文件/聚集索引<br style="margin-top: 0px;"/>发起的查询被索引覆盖时，会在Extra出现Using Index</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 优化join</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MySQL只支持nested loop join，没有hash join或者sort merge join。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">数据库 join 类型：</p>
<ol style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">nested-loop join</code><br/>两层循环，分驱动表（外层，小）和被驱动表（内层）。MySQL 只有这种 join 方式。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">sort-merge join</code><br/>两边都先 sort（有索引就不用了），用两个指针指向两边的第一个元素，依次找相同值。<br/>和 nested-loop join 类似，但利用了排序的性质，内层循环从上次停止的地方开始就可以，不要从头开始找起。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">hash join</code><br/>一边构造一个哈希表（或布隆过滤器），另一边依次判断记录是否在其中</p>
</li>
</ol>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当join无法使用索引（type是all/index/range/index_merge，用到是ref）时会用到join buffer，缓存中间的结果集</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">某些情况下拆分join效率更高：<ul style="margin-top: 0px; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">在应用端可以利用缓存</li>
<li style="line-height: 1.6;">减少MyISAM的表锁时间</li>
<li style="line-height: 1.6;">对大表用in替换join，更高效</li>
</ul>
</li>
<li style="line-height: 1.6;">减小最外层循环次数，即用小结果集驱动join（优化器会帮你挑选较小的表做驱动表）</li>
<li style="line-height: 1.6;">保证被驱动表上的join字段被索引</li>
<li style="line-height: 1.6;">只 group by 或 order by 驱动表上的列，这样可以在 join 前排序</li>
<li style="line-height: 1.6;">被驱动表无法走索引时，保证join buffer足够大</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">d) 优化 order by</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当不能用索引实现排序时，mysql必须对存储引擎返回的记录排序，这个过程被称为filesort（但不一定发生在磁盘上）。纯内存时快速排序，外存时分块快速排序再归并。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">两种filesort算法：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">order by 字段和行指针取出，在sort buffer中排序；然后通过行指针取出需要的列。需要访问两次数据，但内存消耗少。</li>
<li style="line-height: 1.6;">一次性将所有需要的列取出，在sort buffer中排序，需要更多内存。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">参数：max_length_for_sort_data，结果集长度超过该参数时用第一种。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">对join的排序:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">如果只用了驱动表的字段排序：先排序，再join</li>
<li style="line-height: 1.6;">否则先join，结果集放temp table，然后再排序（Using temporary; Using filesort）</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><strong style="font-weight: bold; margin-top: 0px;">尽量走索引</strong><ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">order by时必须要能使用索引的最左前缀(order by+where条件中的常量组成最左前缀也可以)，且order by的方向都相同</li>
<li style="line-height: 1.6;">join时，order by的列如果引用第一个表（驱动表），可以在 join 前先排好序</li>
</ul>
</li>
<li style="line-height: 1.6;"><strong style="font-weight: bold; margin-top: 0px;">优化filesort</strong><ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">内存多时加大max_length_for_sort_data，返回记录小于时用新算法，大于用老算法；</li>
<li style="line-height: 1.6;">用第二种算法时，去掉不必要的返回字段（会用更多内存）</li>
<li style="line-height: 1.6;">加大sort_buffer_size，减小排序过程的IO</li>
</ul>
</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">e) 优化 group by / distinct</h3>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">group by：</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">比order by多了分组和聚合函数计算的步骤，因此优化方式和order by基本类似。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;"> 1. 走索引，可以避免额外排序</strong></p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 0px; margin-bottom: 5px; font-size: 18px;">索引访问方式</h4>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">1. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">loose index scan</code>（MySQL不支持）</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">当前对 <strong style="font-weight: bold; margin-top: 0px;">范围查询</strong> 的处理方式(range scan)是<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px;">走叶子节点链表扫描</code>，当后续有其他列上的过滤条件时，不支持在 <strong style="font-weight: bold;">从上往下搜索的时候，对一个范围内的所有子树，利用后续列的其他条件进行查找并合并结果集</strong> 的工作方式。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">举个例子，idx(a,b,c)，where a = 1 and b &lt; 3 and c = 1，不用loose index scan时的range scan方式：</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">首先定位到 a=1 的节点，然后在这个子树中搜索 b=3 的最右侧叶子节点，接着往前扫描，并用 c=1 在链表上过滤，这种方式在搜索的时候实际上只用到了ab两列;</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">但是显然有一种更好的方式，即在树上从上往下搜索到b&lt;3的所有区间后，对每个子树用c=1的条件去扫描，并合并结果。这就是所谓的loose index scan。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">这就是 idx(a,b,c)少了只有a/c当查询条件是只能用到a列；ab都有范围查询只能用到a列 的根本原因。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Mysql的B+索引只支持等值查询，<strong style="font-weight: bold; margin-top: 0px;">in实际上是和其他条件进行笛卡尔积后的多个等值查询</strong>，因此在查询b/c列时，如果用a in ('男','女')补上这个空洞时，又是可以走索引的。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">可以使用下面两种方式加速分组</strong>：</p>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">2. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">伪loose index scan</code>:</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">group by在有些情况下可以使用这种方式加速查询。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">idx(a,b,c)，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">select max(c) where ... group by a,b</code>时对每个 a 及 b 的组合，从该节点出发找到该子树的最左（右）节点，就能知道这个 group 中 c 的最大值了；最后合并结果即可。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">这种工作方式和真正的 loose scan 类似，都是合并子树的搜索结果，而且仅需扫描子树的部分节点。它的局限在于仅适用某些聚合函数如min/max，且查询字段必须在 group by 字段后面，二者一起组成最左前缀。</p>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">3. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">Tight index scan</code>:</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">其实就是利用索引的有序性，工作方式和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">伪loose index scan</code>类似，但需要扫描满足条件的组合所对应子树中的所有节点，再进行分组/聚合，而不能直接拿到结果。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><a href="http://docs.oracle.com/cd/E16655_01/server.121/e15858/tgsql_optop.htm#TGSQL95163" style="background: transparent; margin-top: 0px;" target="_blank">B+树索引访问方式</a></p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;"> 2. 不能用索引时，mysql必须先将数据放入临时表，然后filesort。</strong></p>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">distinct：</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">与group by的实现方式是一样的，因此优化方式也类似：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">伪loose index scan</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">tight index scan</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">filesort</code>，但distinct不需要排序</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">f) count</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">注意区分以下两种 count ：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">count(*)</code><br/>统计结果集的行</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">count(列/表达式)</code><br/>统计值的个数，排除null</p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MyISAM维护了表的总行数，所以没有where条件的 count(*) 很快。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">工作方式：扫描符合条件的记录，统计。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">一个sql语句统计不同值的count：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f; margin-top: 0px;"><span style="margin-top: 0px;"><span style="color: #F92672; margin-top: 0px;">SELECT</span> <span style="color: #F92672;">COUNT</span>(color = <span style="color: #e6db74;">'blue'</span> <span style="color: #F92672;">OR</span> <span style="color: #F92672;">NULL</span>) <span style="color: #F92672;">AS</span> blue, <span style="color: #F92672;">COUNT</span>(color = <span style="color: #e6db74;">'red'</span> <span style="color: #F92672;">OR</span> <span style="color: #F92672;">NULL</span>) <span style="color: #F92672;">AS</span> red <span style="color: #F92672;">FROM</span> items</span>
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">优化</strong></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">用 “covering index” 技巧让 count 利用索引就能完成，不要访问数据文件。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">g) limit &amp; offset</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">一般瓶颈在于扫描的数据太多，limit 10000,20会扫描10020行数据，再丢弃前10000行.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：利用covering index在索引上偏移，而不是全表上偏移 --  可以先在索引上偏移再join原表获取其他列。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">(没别的办法了？？)</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">h) union</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MySQL总是用temp table实现union</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">使用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">union all</code>而不是<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">union</code>，后者会对temp table做distinct操作，开销很大</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;"> 附：数据访问方式，出现在explain的type列里 </strong> </p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">(all)        Full table scan          全表扫描</li>
<li style="line-height: 1.6;">(index)      Index scan               索引全部扫描：找到最左叶子节点，然后走链表</li>
<li style="line-height: 1.6;">(range)      Range Scan               索引范围扫描：找到范围的最左（右）侧叶子，然后走链表<br style="margin-top: 0px;"/>例外：in显示的是range，但是是索引唯一扫描，等同于多个相等条件</li>
<li style="line-height: 1.6;">(ref/eq_ref) Unique Index Lookup      索引唯一扫描，走树</li>
<li style="line-height: 1.6;">(const)      Constant</li>
</ol>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">五. 可扩展设计</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">分布式事务</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">合理设计切分规则，保证事务所需数据在同一个DB上，避免分布式事务</li>
<li style="line-height: 1.6;">拆分成小事务，app保证整体事务完整性</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">最终一致性</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">为了HA/负载均衡需要冗余数据，数据冗余的地方就存在一致性的问题</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">同一个数据只要保存在多个地方，且至少有一个地方被写，就存在一致性问题<br style="margin-top: 0px;"/>如果保存在多个地方被写，情况就更复杂了，涉及到数据的传播/并发/事务，尽量避免这个情况，保证数据在一个地方被增删改。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">shard还是一个数据在一个地方</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果session是各个容器自己管理的，因为要是强一致性的，必然需要session的复制<br style="margin-top: 0px;"/>如果每个容器有自己的本地cache，且会update/remove，和cpu的L1/L2/L3缓存的情形类似，都要实现cache的传播</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">Replication</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">Master-Slaves 读写分离，负载均衡</li>
<li style="line-height: 1.6;">Dual Master 双机热备HA</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">数据切分(shard)</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">垂直</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">按业务模块切分<br style="margin-top: 0px;"/>需要程序进行不同库之间的join</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">水平</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">每个库的表结构是一样的，按id划分数据<br style="margin-top: 0px;"/>数据局部性好，很多表关联/事务能够在一个DB完成</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">结合：先垂直再水平</h3>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">切分后的整合</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">统一数据访问层 -- 路由规则/解析sql/合并结果/join/分布式事务/负载均衡都可以在这一层搞定<br style="margin-top: 0px;"/>一些开源产品：</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<ol style="margin-top: 0px; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">MySQL Proxy</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">Amoeba (JDBC以下)<br style="margin-top: 0px;"/> query路由/过滤，负载均衡，读写分离，HA<br/> 主要解决：</p>
<ol style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">数据切分后复杂数据源整合;</li>
<li style="line-height: 1.6;">提供数据切分规则并降低数据切分规则给数据库带来的影响;</li>
<li style="line-height: 1.6;">降低数据库与客户端的连接数;</li>
<li style="line-height: 1.6;">读写分离路由</li>
</ol>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Amoeba for MySQL/Aladin</p>
</li>
<li style="line-height: 1.6;">hibernate shards / ibatis shards</li>
</ol>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">分布式事务</li>
<li style="line-height: 1.6;">跨节点join</li>
<li style="line-height: 1.6;">跨节点合并排序分页<br style="margin-top: 0px;"/>都由应用解决吧</li>
</ol>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">参考书籍：</h1>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">《高性能MySQL》</li>
<li style="line-height: 1.6;">张宴的《MySQL调优与架构设计》</li>
</ol>
</div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html&text=MySQL总结" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html&title=MySQL总结" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->
<!-- 
      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">目录</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div> -->
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>
    <button id="js-toc"><span id="icon-list" class="fa fa-list-ul"></span></button>
    <div id="post__toc">
      <span id="post__toc-title">目录</span>
      <ul id="post__toc-ul"></ul>
    </div>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
