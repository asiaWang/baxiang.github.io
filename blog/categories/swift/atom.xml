<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | 小巴童鞋]]></title>
  <link href="http://baxiang123.com//blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://baxiang123.com//"/>
  <updated>2015-03-15T01:57:28+08:00</updated>
  <id>http://baxiang123.com//</id>
  <author>
    <name><![CDATA[小巴]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[swift枚举]]></title>
    <link href="http://baxiang123.com//blog/Swift%E6%9E%9A%E4%B8%BE.html"/>
    <updated>2014-11-28T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift枚举</id>
    <content type="html"><![CDATA[<p>枚举定义了一个通用类型的一组相关的值，使你可以在你的代码中以一个安全的方式来使用这些值。</p>


<p>如果你熟悉 C 语言，你就会知道，在 C 语言中枚举指定相关名称为一组整型值。Swift 中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果一个值（被认为是“原始”值）被提供给每个枚举成员，则该值可以是一个字符串，一个字符，或是一个整型值或浮点值。</p>


<p>此外，枚举成员可以指定任何类型的实例值存储到枚举成员值中，就像其他语言中的联合体（unions）和变体（variants）。你可以定义一组通用的相关成员作为枚举的一部分，每一组都有不同的一组与它相关的适当类型的数值。</p>


<p>在 Swift 中，枚举类型是一等（first-class）类型。它们采用了很多传统上只被类（class)所支持的特征，例如计算型属性（computed properties)，用于提供关于枚举当前值的附加信息， 实例方法（instance methods），用于提供和枚举所代表的值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始成员值；可以在原始的实现基础上扩展它们的功能；可以遵守协议（protocols）来提供标准的功能。</p>


<p>欲了解更多相关功能，请参见<a href="10_Properties.html">属性（Properties）</a>，<a href="11_Methods.html">方法（Methods）</a>，<a href="14_Initialization.html">构造过程（Initialization）</a>，<a href="20_Extensions.html">扩展（Extensions）</a>和<a href="21_Protocols.html">协议（Protocols）</a>。</p>


<p><a name="enumeration_syntax"></a></p>


<h2 id="-">枚举语法</h2>


<p>使用<code>enum</code>关键词并且把它们的整个定义放在一对大括号内：</p>


<pre><code>enum SomeEumeration {
    // enumeration definition goes here
}
</code></pre>


<p>以下是指南针四个方向的一个例子：</p>


<pre><code>enum CompassPoint {
    case North
    case South
    case East
    case West
}
</code></pre>


<p>一个枚举中被定义的值（例如 <code>North</code>，<code>South</code>，<code>East</code>和<code>West</code>）是枚举的<strong><em>成员值</em></strong>（或者<strong><em>成员</em></strong>）。<code>case</code>关键词表明新的一行成员值将被定义。</p>


<blockquote>
<p>注意：</p>
<p>不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值。在上面的<code>CompassPoints</code>例子中，<code>North</code>，<code>South</code>，<code>East</code>和<code>West</code>不是隐式的等于<code>0</code>，<code>1</code>，<code>2</code>和<code>3</code>。相反的，这些不同的枚举成员在<code>CompassPoint</code>的一种显示定义中拥有各自不同的值。</p>
</blockquote>


<p>多个成员值可以出现在同一行上，用逗号隔开：</p>


<pre><code>enum Planet {
    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Nepturn
}
</code></pre>


<p>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如<code>CompassPoint</code>和<code>Planet</code>）必须以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：</p>


<pre><code>var directionToHead = CompassPoint.West
</code></pre>


<p><code>directionToHead</code>的类型被推断当它被<code>CompassPoint</code>的一个可能值初始化。一旦<code>directionToHead</code>被声明为一个<code>CompassPoint</code>，你可以使用更短的点（.）语法将其设置为另一个<code>CompassPoint</code>的值：</p>


<pre><code>directionToHead = .East
</code></pre>


<p><code>directionToHead</code>的类型已知时，当设定它的值时，你可以不再写类型名。使用显示类型的枚举值可以让代码具有更好的可读性。</p>


<p><a name="matching_enumeration_values_with_a_switch_statement"></a></p>


<h2 id="-switch-">匹配枚举值和<code>Switch</code>语句</h2>


<p>你可以匹配单个枚举值和<code>switch</code>语句：</p>


<pre><code>directionToHead = .South
switch directionToHead {
case .North:
    println("Lots of planets have a north")
case .South:
    println("Watch out for penguins")
case .East:
    println("Where the sun rises")
case .West:
    println("Where the skies are blue")
}
// 输出 "Watch out for penguins”
</code></pre>


<p>你可以如此理解这段代码：</p>


<p>“考虑<code>directionToHead</code>的值。当它等于<code>.North</code>，打印<code>“Lots of planets have a north”</code>。当它等于<code>.South</code>，打印<code>“Watch out for penguins”</code>。”</p>


<p>等等依次类推。</p>


<p>正如在<a href="05_Control_Flow.html">控制流（Control Flow）</a>中介绍，当考虑一个枚举的成员们时，一个<code>switch</code>语句必须全面。如果忽略了<code>.West</code>这种情况，上面那段代码将无法通过编译，因为它没有考虑到<code>CompassPoint</code>的全部成员。全面性的要求确保了枚举成员不会被意外遗漏。</p>


<p>当不需要匹配每个枚举成员的时候，你可以提供一个默认<code>default</code>分支来涵盖所有未明确被提出的任何成员：</p>


<pre><code>let somePlanet = Planet.Earth
switch somePlanet {
case .Earth:
    println("Mostly harmless")
default:
    println("Not a safe place for humans")
}
// 输出 "Mostly harmless”
</code></pre>


<p><a name="associated_values"></a></p>


<h2 id="-associated-values-">实例值（Associated Values）</h2>


<p>上一小节的例子演示了一个枚举的成员是如何被定义（分类）的。你可以为<code>Planet.Earth</code>设置一个常量或则变量，并且在之后查看这个值。然而，有时候会很有用如果能够把其他类型的实例值和成员值一起存储起来。这能让你随着成员值存储额外的自定义信息，并且当每次你在代码中利用该成员时允许这个信息产生变化。</p>


<p>你可以定义 Swift 的枚举存储任何类型的实例值，如果需要的话，每个成员的数据类型可以是各不相同的。枚举的这种特性跟其他语言中的可辨识联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。</p>


<p>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有 UPC-A 格式的一维码，它使用数字 0 到 9。每一个条形码都有一个代表“数字系统”的数字，该数字后接 10 个代表“标识符”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：</p>


<p><img width="252" height="120" alt="" src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png"></p>


<p>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO8859-1 字符，并且可以编码一个最多拥有 2,953 字符的字符串:</p>


<p><img width="169" height="169" alt="" src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png"></p>


<p>对于库存跟踪系统来说，能够把 UPC-A 码作为三个整型值的元组，和把 QR 码作为一个任何长度的字符串存储起来是方便的。</p>


<p>在 Swift 中，用来定义两种商品条码的枚举是这样子的：</p>


<pre><code>enum Barcode {
    case UPCA(Int, Int, Int)
    case QRCode(String)
}
</code></pre>


<p>以上代码可以这么理解：</p>


<p>“定义一个名为<code>Barcode</code>的枚举类型，它可以是<code>UPCA</code>的一个实例值（<code>Int</code>，<code>Int</code>，<code>Int</code>），或者<code>QRCode</code>的一个字符串类型（<code>String</code>）实例值。”</p>


<p>这个定义不提供任何<code>Int</code>或<code>String</code>的实际值，它只是定义了，当<code>Barcode</code>常量和变量等于<code>Barcode.UPCA</code>或<code>Barcode.QRCode</code>时，实例值的类型。</p>


<p>然后可以使用任何一种条码类型创建新的条码，如：</p>


<pre><code>var productBarcode = Barcode.UPCA(8, 85909_51226, 3)
</code></pre>


<p>以上例子创建了一个名为<code>productBarcode</code>的新变量，并且赋给它一个<code>Barcode.UPCA</code>的实例元组值<code>(8, 8590951226, 3)</code>。提供的“标识符”值在整数字中有一个下划线，使其便于阅读条形码。</p>


<p>同一个商品可以被分配给一个不同类型的条形码，如：</p>


<pre><code>productBarcode = .QRCode("ABCDEFGHIJKLMNOP")
</code></pre>


<p>这时，原始的<code>Barcode.UPCA</code>和其整数值被新的<code>Barcode.QRCode</code>和其字符串值所替代。条形码的常量和变量可以存储一个<code>.UPCA</code>或者一个<code>.QRCode</code>（连同它的实例值），但是在任何指定时间只能存储其中之一。</p>


<p>像以前那样，不同的条形码类型可以使用一个 switch 语句来检查，然而这次实例值可以被提取作为 switch 语句的一部分。你可以在<code>switch</code>的 case 分支代码中提取每个实例值作为一个常量（用<code>let</code>前缀）或者作为一个变量（用<code>var</code>前缀）来使用：</p>


<pre><code>switch productBarcode {
case .UPCA(let numberSystem, let identifier, let check):
    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
case .QRCode(let productCode):
    println("QR code with value of \(productCode).")
}
// 输出 "QR code with value of ABCDEFGHIJKLMNOP.”
</code></pre>


<p>如果一个枚举成员的所有实例值被提取为常量，或者它们全部被提取为变量，为了简洁，你可以只放置一个<code>var</code>或者<code>let</code>标注在成员名称前：</p>


<pre><code>switch productBarcode {
case let .UPCA(numberSystem, identifier, check):
    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
case let .QRCode(productCode):
    println("QR code with value of \(productCode).")
}
// 输出 "QR code with value of ABCDEFGHIJKLMNOP."
</code></pre>


<p><a name="raw_values"></a></p>


<h2 id="-raw-values-">原始值（Raw Values）</h2>


<p>在实例值小节的条形码例子中演示了一个枚举的成员如何声明它们存储不同类型的实例值。作为实例值的替代，枚举成员可以被默认值（称为原始值）预先填充，其中这些原始值具有相同的类型。</p>


<p>这里是一个枚举成员存储原始 ASCII 值的例子：</p>


<pre><code>enum ASCIIControlCharacter: Character {
    case Tab = "\t"
    case LineFeed = "\n"
    case CarriageReturn = "\r"
}
</code></pre>


<p>在这里，称为<code>ASCIIControlCharacter</code>的枚举的原始值类型被定义为字符型<code>Character</code>，并被设置了一些比较常见的 ASCII 控制字符。字符值的描述请详见字符串和字符<code>Strings and Characters</code>部分。</p>


<p>注意，原始值和实例值是不相同的。当你开始在你的代码中定义枚举的时候原始值是被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终是相同的。实例值是当你在创建一个基于枚举成员的新常量或变量时才会被设置，并且每次当你这么做得时候，它的值可以是不同的。</p>


<p>原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的。当整型值被用于原始值，如果其他枚举成员没有值时，它们会自动递增。</p>


<p>下面的枚举是对之前<code>Planet</code>这个枚举的一个细化，利用原始整型值来表示每个 planet 在太阳系中的顺序：</p>


<pre><code>enum Planet: Int {
    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
</code></pre>


<p>自动递增意味着<code>Planet.Venus</code>的原始值是<code>2</code>，依次类推。</p>


<p>使用枚举成员的<code>toRaw</code>方法可以访问该枚举成员的原始值：</p>


<pre><code>let earthsOrder = Planet.Earth.toRaw()
// earthsOrder is 3
</code></pre>


<p>使用枚举的<code>fromRaw</code>方法来试图找到具有特定原始值的枚举成员。这个例子通过原始值<code>7</code>识别<code>Uranus</code>：</p>


<pre><code>let possiblePlanet = Planet.fromRaw(7)
// possiblePlanet is of type Planet? and equals Planet.Uranus
</code></pre>


<p>然而，并非所有可能的<code>Int</code>值都可以找到一个匹配的行星。正因为如此，<code>fromRaw</code>方法可以返回一个<strong><em>可选</em></strong>的枚举成员。在上面的例子中，<code>possiblePlanet</code>是<code>Planet?</code>类型，或“可选的<code>Planet</code>”。</p>


<p>如果你试图寻找一个位置为9的行星，通过<code>fromRaw</code>返回的可选<code>Planet</code>值将是<code>nil</code>：</p>


<pre><code>let positionToFind = 9
if let somePlanet = Planet.fromRaw(positionToFind) {
    switch somePlanet {
    case .Earth:
        println("Mostly harmless")
    default:
        println("Not a safe place for humans")
    }
} else {
    println("There isn't a planet at position \(positionToFind)")
}
// 输出 "There isn't a planet at position 9
</code></pre>


<p>这个范例使用可选绑定（optional binding），通过原始值<code>9</code>试图访问一个行星。<code>if let somePlanet = Planet.fromRaw(9)</code>语句获得一个可选<code>Planet</code>，如果可选<code>Planet</code>可以被获得，把<code>somePlanet</code>设置成该可选<code>Planet</code>的内容。在这个范例中，无法检索到位置为<code>9</code>的行星，所以<code>else</code>分支被执行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift泛型]]></title>
    <link href="http://baxiang123.com//blog/Swif%E6%B3%9B%E5%9E%8B.html"/>
    <updated>2014-11-27T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swif泛型</id>
    <content type="html"><![CDATA[<p><em>泛型代码</em>可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>


<p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个<code>Int</code>数组，也可创建一个<code>String</code>数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。</p>


<p><a name="the_problem_that_generics_solve"></a></p>


<h2 id="-">泛型所解决的问题</h2>


<p>这里是一个标准的，非泛型函数<code>swapTwoInts</code>,用来交换两个Int值：</p>


<pre><code>func swapTwoInts(inout a: Int, inout b: Int)
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p>这个函数使用写入读出（in-out）参数来交换<code>a</code>和<code>b</code>的值，请参考[写入读出参数][1]。</p>


<p><code>swapTwoInts</code>函数可以交换<code>b</code>的原始值到<code>a</code>，也可以交换a的原始值到<code>b</code>，你可以调用这个函数交换两个<code>Int</code>变量值：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 输出 "someInt is now 107, and anotherInt is now 3"
</code></pre>


<p><code>swapTwoInts</code>函数是非常有用的，但是它只能交换<code>Int</code>值，如果你想要交换两个<code>String</code>或者<code>Double</code>，就不得不写更多的函数，如 <code>swapTwoStrings</code>和<code>swapTwoDoublesfunctions</code>，如同如下所示：</p>


<pre><code>func swapTwoStrings(inout a: String, inout b: String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(inout a: Double, inout b: Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p>你可能注意到 <code>swapTwoInts</code>、 <code>swapTwoStrings</code>和<code>swapTwoDoubles</code>函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是<code>Int</code>、<code>String</code>和<code>Double</code>。</p>


<p>但实际应用中通常需要一个用处更强大并且尽可能的考虑到更多的灵活性单个函数，可以用来交换两个任何类型值，很幸运的是，泛型代码帮你解决了这种问题。（一个这种泛型函数后面已经定义好了。）</p>


<blockquote>
<p>注意：
在所有三个函数中，<code>a</code>和<code>b</code>的类型是一样的。如果<code>a</code>和<code>b</code>不是相同的类型，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个<code>String</code>类型的变量和一个<code>Double</code>类型的变量互相交换值。如果一定要做，Swift 将报编译错误。</p>
</blockquote>


<p><a name="generic_functions"></a></p>


<h2 id="-">泛型函数</h2>


<p><code>泛型函数</code>可以工作于任何类型，这里是一个上面<code>swapTwoInts</code>函数的泛型版本，用于交换两个值：</p>


<pre><code>func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p><code>swapTwoValues</code>函数主体和<code>swapTwoInts</code>函数是一样的，它只在第一行稍微有那么一点点不同于<code>swapTwoInts</code>，如下所示：</p>


<pre><code>func swapTwoInts(inout a: Int, inout b: Int)
func swapTwoValues&lt;T&gt;(inout a: T, inout b: T)
</code></pre>


<p>这个函数的泛型版本使用了占位类型名字（通常此情况下用字母<code>T</code>来表示）来代替实际类型名（如<code>In</code>、<code>String</code>或<code>Doubl</code>）。占位类型名没有提示<code>T</code>必须是什么类型，但是它提示了<code>a</code>和<code>b</code>必须是同一类型<code>T</code>，而不管<code>T</code>表示什么类型。只有<code>swapTwoValues</code>函数在每次调用时所传入的实际类型才能决定<code>T</code>所代表的类型。</p>


<p>另外一个不同之处在于这个泛型函数名后面跟着的展位类型名字（T）是用尖括号括起来的（<t>）。这个尖括号告诉 Swift 那个<code>T</code>是<code>swapTwoValues</code>函数所定义的一个类型。因为<code>T</code>是一个占位命名类型，Swift 不会去查找命名为T的实际类型。</t></p>


<p><code>swapTwoValues</code>函数除了要求传入的两个任何类型值是同一类型外，也可以作为<code>swapTwoInts</code>函数被调用。每次<code>swapTwoValues</code>被调用，T所代表的类型值都会传给函数。</p>


<p>在下面的两个例子中,<code>T</code>分别代表<code>Int</code>和<code>String</code>：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;someInt, &amp;anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&amp;someString, &amp;anotherString)
// someString is now "world", and anotherString is now "hello"
</code></pre>


<blockquote>
<p>注意
上面定义的函数<code>swapTwoValues</code>是受<code>swap</code>函数启发而实现的。<code>swap</code>函数存在于 Swift 标准库，并可以在其它类中任意使用。如果你在自己代码中需要类似<code>swapTwoValues</code>函数的功能，你可以使用已存在的交换函数<code>swap</code>函数。</p>
</blockquote>


<p><a name="type_parameters"></a></p>


<h2 id="-">类型参数</h2>


<p>在上面的<code>swapTwoValues</code>例子中，占位类型<code>T</code>是一种类型参数的示例。类型参数指定并命名为一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（如<t>）。</t></p>


<p>一旦一个类型参数被指定，那么其可以被使用来定义一个函数的参数类型（如<code>swapTwoValues</code>函数中的参数<code>a</code>和<code>b</code>），或作为一个函数返回类型，或用作函数主体中的注释类型。在这种情况下，被类型参数所代表的占位类型不管函数任何时候被调用，都会被实际类型所替换（在上面<code>swapTwoValues</code>例子中，当函数第一次被调用时，<code>T</code>被<code>Int</code>替换，第二次调用时，被<code>String</code>替换。）。</p>


<p>你可支持多个类型参数，命名在尖括号中，用逗号分开。</p>


<p><a name="naming_type_parameters"></a></p>


<h2 id="-">命名类型参数</h2>


<p>在简单的情况下，泛型函数或泛型类型需要指定一个占位类型（如上面的<code>swapTwoValues</code>泛型函数，或一个存储单一类型的泛型集，如数组），通常用一单个字母<code>T</code>来命名类型参数。不过，你可以使用任何有效的标识符来作为类型参数名。</p>


<p>如果你使用多个参数定义更复杂的泛型函数或泛型类型，那么使用更多的描述类型参数是非常有用的。例如，Swift 字典（Dictionary）类型有两个类型参数，一个是键，另外一个是值。如果你自己写字典，你或许会定义这两个类型参数为<code>KeyType</code>和<code>ValueType</code>，用来记住它们在你的泛型代码中的作用。</p>


<blockquote>
<p>注意
请始终使用大写字母开头的驼峰式命名法（例如<code>T</code>和<code>KeyType</code>）来给类型参数命名，以表明它们是类型的占位符，而非类型值。</p>
</blockquote>


<p><a name="generic_types"></a></p>


<h2 id="-">泛型类型</h2>


<p>通常在泛型函数中，Swift 允许你定义你自己的泛型类型。这些自定义类、结构体和枚举作用于任何类型，如同<code>Array</code>和<code>Dictionary</code>的用法。</p>


<p>这部分向你展示如何写一个泛型集类型&#8211;<code>Stack</code>（栈）。一个栈是一系列值域的集合，和<code>Array</code>（数组）类似，但其是一个比 Swift 的<code>Array</code>类型更多限制的集合。一个数组可以允许其里面任何位置的插入/删除操作，而栈，只允许在集合的末端添加新的项（如同<em>push</em>一个新值进栈）。同样的一个栈也只能从末端移除项（如同<em>pop</em>一个值出栈）。</p>


<blockquote>
<p>注意
栈的概念已被<code>UINavigationController</code>类使用来模拟试图控制器的导航结构。你通过调用<code>UINavigationController</code>的<code>pushViewController:animated:</code>方法来为导航栈添加（add）新的试图控制器；而通过<code>popViewControllerAnimated:</code>的方法来从导航栈中移除（pop）某个试图控制器。每当你需要一个严格的<code>后进先出</code>方式来管理集合，堆栈都是最实用的模型。</p>
</blockquote>


<p>下图展示了一个栈的压栈(push)/出栈(pop)的行为：</p>


<p>![此处输入图片的描述][2]</p>


<ol>
<li>现在有三个值在栈中；</li>
<li>第四个值“pushed”到栈的顶部；</li>
<li>现在有四个值在栈中，最近的那个在顶部；</li>
<li>栈中最顶部的那个项被移除，或称之为“popped”；</li>
<li>移除掉一个值后，现在栈又重新只有三个值。</li>
</ol>


<p>这里展示了如何写一个非泛型版本的栈，<code>Int</code>值型的栈：</p>


<pre><code>struct IntStack {
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
}
</code></pre>


<p>这个结构体在栈中使用一个<code>Array</code>性质的<code>items</code>存储值。<code>Stack</code>提供两个方法：<code>push</code>和<code>pop</code>，从栈中压进一个值和移除一个值。这些方法标记为可变的，因为他们需要修改（或<em>转换</em>）结构体的<code>items</code>数组。</p>


<p>上面所展现的<code>IntStack</code>类型只能用于<code>Int</code>值，不过，其对于定义一个泛型<code>Stack</code>类（可以处理<em>任何</em>类型值的栈）是非常有用的。</p>


<p>这里是一个相同代码的泛型版本：</p>


<pre><code>struct Stack&lt;T&gt; {
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
}
</code></pre>


<p>注意到<code>Stack</code>的泛型版本基本上和非泛型版本相同，但是泛型版本的占位类型参数为T代替了实际<code>Int</code>类型。这种类型参数包含在一对尖括号里（<code>&lt;T&gt;</code>），紧随在结构体名字后面。</p>


<p><code>T</code>定义了一个名为“某种类型T”的节点提供给后来用。这种将来类型可以在结构体的定义里任何地方表示为“T”。在这种情况下，<code>T</code>在如下三个地方被用作节点：</p>


<ul>
<li>创建一个名为<code>items</code>的属性，使用空的T类型值数组对其进行初始化；</li>
<li>指定一个包含一个参数名为<code>item</code>的<code>push</code>方法，该参数必须是T类型；</li>
<li>指定一个<code>pop</code>方法的返回值，该返回值将是一个T类型值。</li>
</ul>


<p>当创建一个新单例并初始化时， 通过用一对紧随在类型名后的尖括号里写出实际指定栈用到类型，创建一个<code>Stack</code>实例，同创建<code>Array</code>和<code>Dictionary</code>一样：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 现在栈已经有4个string了
</code></pre>


<p>下图将展示<code>stackOfStrings</code>如何<code>push</code>这四个值进栈的过程：</p>


<p>![此处输入图片的描述][3]</p>


<p>从栈中<code>pop</code>并移除值&#8221;cuatro&#8221;：</p>


<pre><code>let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to "cuatro", and the stack now contains 3 strings
</code></pre>


<p>下图展示了如何从栈中pop一个值的过程：
![此处输入图片的描述][4]</p>


<p>由于<code>Stack</code>是泛型类型，所以在 Swift 中其可以用来创建任何有效类型的栈，这种方式如同<code>Array</code>和<code>Dictionary</code>。</p>


<p><a name="type_constraints"></a></p>


<h2 id="-">类型约束</h2>


<p><code>swapTwoValues</code>函数和<code>Stack</code>类型可以作用于任何类型，不过，有的时候对使用在泛型函数和泛型类型上的类型强制约束为某种特定类型是非常有用的。类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成。</p>


<p>例如，Swift 的<code>Dictionary</code>类型对作用于其键的类型做了些限制。在[字典][5]的描述中，字典的键类型必须是<em>可哈希</em>，也就是说，必须有一种方法可以使其是唯一的表示。<code>Dictionary</code>之所以需要其键是可哈希是为了以便于其检查其是否包含某个特定键的值。如无此需求，<code>Dictionary</code>即不会告诉是否插入或者替换了某个特定键的值，也不能查找到已经存储在字典里面的给定键值。</p>


<p>这个需求强制加上一个类型约束作用于<code>Dictionary</code>的键上，当然其键类型必须遵循<code>Hashable</code>协议（Swift 标准库中定义的一个特定协议）。所有的 Swift 基本类型（如<code>String</code>，<code>Int</code>， <code>Double</code>和 <code>Bool</code>）默认都是可哈希。</p>


<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，当然，这些约束要支持泛型编程的强力特征中的多数。抽象概念如<code>可哈希</code>具有的类型特征是根据他们概念特征来界定的，而不是他们的直接类型特征。</p>


<h3 id="-">类型约束语法</h3>


<p>你可以写一个在一个类型参数名后面的类型约束，通过冒号分割，来作为类型参数链的一部分。这种作用于泛型函数的类型约束的基础语法如下所示（和泛型类型的语法相同）：</p>


<pre><code>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // function body goes here
}
</code></pre>


<p>上面这个假定函数有两个类型参数。第一个类型参数<code>T</code>，有一个需要<code>T</code>必须是<code>SomeClass</code>子类的类型约束；第二个类型参数<code>U</code>，有一个需要<code>U</code>必须遵循<code>SomeProtocol</code>协议的类型约束。</p>


<h3 id="-">类型约束行为</h3>


<p>这里有个名为<code>findStringIndex</code>的非泛型函数，该函数功能是去查找包含一给定<code>String</code>值的数组。若查找到匹配的字符串，<code>findStringIndex</code>函数返回该字符串在数组中的索引值（<code>Int</code>），反之则返回<code>nil</code>：</p>


<pre><code>func findStringIndex(array: String[], valueToFind: String) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findStringIndex</code>函数可以作用于查找一字符串数组中的某个字符串:</p>


<pre><code>let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findStringIndex(strings, "llama") {
    println("The index of llama is \(foundIndex)")
}
// 输出 "The index of llama is 2"
</code></pre>


<p>如果只是针对字符串而言查找在数组中的某个值的索引，用处不是很大，不过，你可以写出相同功能的泛型函数<code>findIndex</code>，用某个类型<code>T</code>值替换掉提到的字符串。</p>


<p>这里展示如何写一个你或许期望的<code>findStringIndex</code>的泛型版本<code>findIndex</code>。请注意这个函数仍然返回<code>Int</code>，是不是有点迷惑呢，而不是泛型类型?那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数不会编译，原因在例子后面会说明：</p>


<pre><code>func findIndex&lt;T&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p>上面所写的函数不会编译。这个问题的位置在等式的检查上，<code>“if value == valueToFind”</code>。不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。正因如此，这部分代码不能可能保证工作于每个可能的类型<code>T</code>，当你试图编译这部分代码时估计会出现相应的错误。</p>


<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个<code>Equatable</code>协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持<code>Equatable</code>协议。</p>


<p>任何<code>Equatable</code>类型都可以安全的使用在<code>findIndex</code>函数中，因为其保证支持等式操作。为了说明这个事实，当你定义一个函数时，你可以写一个<code>Equatable</code>类型约束作为类型参数定义的一部分：</p>


<pre><code>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findIndex</code>中这个单个类型参数写做：<code>T: Equatable</code>，也就意味着“任何T类型都遵循<code>Equatable</code>协议”。</p>


<p><code>findIndex</code>函数现在则可以成功的编译过，并且作用于任何遵循<code>Equatable</code>的类型，如<code>Double</code>或<code>String</code>:</p>


<pre><code>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
// stringIndex is an optional Int containing a value of 2
</code></pre>


<p><a name="associated_types"></a></p>


<h2 id="-">关联类型</h2>


<p>当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名（或<em>别名</em>）。作用于关联类型上实际类型是不需要指定的，直到该协议接受。关联类型被指定为<code>typealias</code>关键字。</p>


<h3 id="-">关联类型行为</h3>


<p>这里是一个<code>Container</code>协议的例子，定义了一个ItemType关联类型：</p>


<pre><code>protocol Container {
    typealias ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>


<p><code>Container</code>协议定义了三个任何容器必须支持的兼容要求：</p>


<ul>
<li>必须可能通过<code>append</code>方法添加一个新item到容器里；</li>
<li>必须可能通过使用<code>count</code>属性获取容器里items的数量，并返回一个<code>Int</code>值；</li>
<li>必须可能通过容器的<code>Int</code>索引值下标可以检索到每一个item。</li>
</ul>


<p>这个协议没有指定容器里item是如何存储的或何种类型是允许的。这个协议只指定三个任何遵循<code>Container</code>类型所必须支持的功能点。一个遵循的类型也可以提供其他额外的功能，只要满足这三个条件。</p>


<p>任何遵循<code>Container</code>协议的类型必须指定存储在其里面的值类型，必须保证只有正确类型的items可以加进容器里，必须明确可以通过其下标返回item类型。</p>


<p>为了定义这三个条件，<code>Container</code>协议需要一个方法指定容器里的元素将会保留，而不需要知道特定容器的类型。<code>Container</code>协议需要指定任何通过<code>append</code>方法添加到容器里的值和容器里元素是相同类型，并且通过容器下标返回的容器元素类型的值的类型是相同类型。</p>


<p>为了达到此目的，<code>Container</code>协议声明了一个ItemType的关联类型，写作<code>typealias ItemType</code>。The protocol does not define what ItemType is an alias for—that information is left for any conforming type to provide（这个协议不会定义<code>ItemType</code>是遵循类型所提供的何种信息的别名）。尽管如此，<code>ItemType</code>别名支持一种方法识别在一个容器里的items类型，以及定义一种使用在<code>append</code>方法和下标中的类型，以便保证任何期望的<code>Container</code>的行为是强制性的。</p>


<p>这里是一个早前IntStack类型的非泛型版本，适用于遵循Container协议：</p>


<pre><code>struct IntStack: Container {
    // original IntStack implementation
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}
</code></pre>


<p><code>IntStack</code>类型实现了<code>Container</code>协议的所有三个要求，在<code>IntStack</code>类型的每个包含部分的功能都满足这些要求。</p>


<p>此外，<code>IntStack</code>指定了<code>Container</code>的实现，适用的ItemType被用作<code>Int</code>类型。对于这个<code>Container</code>协议实现而言，定义 <code>typealias ItemType = Int</code>，将抽象的<code>ItemType</code>类型转换为具体的<code>Int</code>类型。</p>


<p>感谢Swift类型参考，你不用在<code>IntStack</code>定义部分声明一个具体的<code>Int</code>的<code>ItemType</code>。由于<code>IntStack</code>遵循<code>Container</code>协议的所有要求，只要通过简单的查找<code>append</code>方法的item参数类型和下标返回的类型，Swift就可以推断出合适的<code>ItemType</code>来使用。确实，如果上面的代码中你删除了 <code>typealias ItemType = Int</code>这一行，一切仍旧可以工作，因为它清楚的知道ItemType使用的是何种类型。</p>


<p>你也可以生成遵循<code>Container</code>协议的泛型<code>Stack</code>类型：</p>


<pre><code>struct Stack&lt;T&gt;: Container {
    // original Stack&lt;T&gt; implementation
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(item: T) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; T {
        return items[i]
    }
}
</code></pre>


<p>这个时候，占位类型参数<code>T</code>被用作<code>append</code>方法的item参数和下标的返回类型。Swift 因此可以推断出被用作这个特定容器的<code>ItemType</code>的<code>T</code>的合适类型。</p>


<h3 id="-">扩展一个存在的类型为一指定关联类型</h3>


<p>在[使用扩展来添加协议兼容性][6]中有描述扩展一个存在的类型添加遵循一个协议。这个类型包含一个关联类型的协议。</p>


<p>Swift的<code>Array</code>已经提供<code>append</code>方法，一个<code>count</code>属性和通过下标来查找一个自己的元素。这三个功能都达到<code>Container</code>协议的要求。也就意味着你可以扩展<code>Array</code>去遵循<code>Container</code>协议，只要通过简单声明<code>Array</code>适用于该协议而已。如何实践这样一个空扩展，在[使用扩展来声明协议的采纳][7]中有描述这样一个实现一个空扩展的行为：</p>


<pre><code>extension Array: Container {}
</code></pre>


<p>如同上面的泛型<code>Stack</code>类型一样，<code>Array的append</code>方法和下标保证<code>Swift</code>可以推断出<code>ItemType</code>所使用的适用的类型。定义了这个扩展后，你可以将任何<code>Array</code>当作<code>Container</code>来使用。</p>


<p><a name="where_clauses"></a></p>


<h2 id="where-">Where 语句</h2>


<p>[类型约束][8]中描述的类型约束确保你定义关于类型参数的需求和一泛型函数或类型有关联。</p>


<p>对于关联类型的定义需求也是非常有用的。你可以通过这样去定义<em>where语句</em>作为一个类型参数队列的一部分。一个<code>where</code>语句使你能够要求一个关联类型遵循一个特定的协议，以及（或）那个特定的类型参数和关联类型可以是相同的。你可写一个<code>where</code>语句，通过紧随放置<code>where</code>关键字在类型参数队列后面，其后跟着一个或者多个针对关联类型的约束，以及（或）一个或多个类型和关联类型的等于关系。</p>


<p>下面的列子定义了一个名为<code>allItemsMatch</code>的泛型函数，用来检查是否两个<code>Container</code>单例包含具有相同顺序的相同元素。如果匹配到所有的元素，那么返回一个为<code>true</code>的<code>Boolean</code>值，反之，则相反。</p>


<p>这两个容器可以被检查出是否是相同类型的容器（虽然它们可以是），但他们确实拥有相同类型的元素。这个需求通过一个类型约束和<code>where</code>语句结合来表示：</p>


<pre><code>func allItemsMatch&lt;
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;
    (someContainer: C1, anotherContainer: C2) -&gt; Bool {

        // check that both containers contain the same number of items
        if someContainer.count != anotherContainer.count {
            return false
        }

        // check each pair of items to see if they are equivalent
        for i in 0..someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }

        // all items match, so return true
        return true

}
</code></pre>


<p>这个函数用了两个参数：<code>someContainer</code>和<code>anotherContainer</code>。<code>someContainer</code>参数是类型<code>C1</code>，<code>anotherContainer</code>参数是类型<code>C2</code>。<code>C1</code>和<code>C2</code>是容器的两个占位类型参数，决定了这个函数何时被调用。</p>


<p>这个函数的类型参数列紧随在两个类型参数需求的后面：</p>


<ul>
<li><code>C1</code>必须遵循<code>Container</code>协议 (写作 <code>C1: Container</code>)。</li>
<li><code>C2</code>必须遵循<code>Container</code>协议 (写作 <code>C2: Container</code>)。</li>
<li><code>C1</code>的<code>ItemType</code>同样是C2的<code>ItemType</code>（写作 <code>C1.ItemType == C2.ItemType</code>）。</li>
<li><code>C1</code>的<code>ItemType</code>必须遵循<code>Equatable</code>协议 (写作 <code>C1.ItemType: Equatable</code>)。</li>
</ul>


<p>第三个和第四个要求被定义为一个<code>where</code>语句的一部分，写在关键字<code>where</code>后面，作为函数类型参数链的一部分。</p>


<p>这些要求意思是：</p>


<p><code>someContainer</code>是一个<code>C1</code>类型的容器。
<code>anotherContainer</code>是一个<code>C2</code>类型的容器。
<code>someContainer</code>和<code>anotherContainer</code>包含相同的元素类型。
<code>someContainer</code>中的元素可以通过不等于操作(<code>!=</code>)来检查它们是否彼此不同。</p>


<p>第三个和第四个要求结合起来的意思是<code>anotherContainer</code>中的元素也可以通过 <code>!=</code> 操作来检查，因为他们在<code>someContainer</code>中元素确实是相同的类型。</p>


<p>这些要求能够使<code>allItemsMatch</code>函数比较两个容器，即便他们是不同的容器类型。</p>


<p><code>allItemsMatch</code>首先检查两个容器是否拥有同样数目的items，如果他们的元素数目不同，没有办法进行匹配，函数就会<code>false</code>。</p>


<p>检查完之后，函数通过<code>for-in</code>循环和半闭区间操作（..）来迭代<code>someContainer</code>中的所有元素。对于每个元素，函数检查是否<code>someContainer</code>中的元素不等于对应的<code>anotherContainer</code>中的元素，如果这两个元素不等，则这两个容器不匹配，返回<code>false</code>。</p>


<p>如果循环体结束后未发现没有任何的不匹配，那表明两个容器匹配，函数返回<code>true</code>。</p>


<p>这里演示了allItemsMatch函数运算的过程：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    println("All items match.")
} else {
    println("Not all items match.")
}
// 输出 "All items match."
</code></pre>


<p> 上面的例子创建一个<code>Stack</code>单例来存储<code>String</code>，然后压了三个字符串进栈。这个例子也创建了一个<code>Array</code>单例，并初始化包含三个同栈里一样的原始字符串。即便栈和数组否是不同的类型，但他们都遵循<code>Container</code>协议，而且他们都包含同样的类型值。你因此可以调用<code>allItemsMatch</code>函数，用这两个容器作为它的参数。在上面的例子中，<code>allItemsMatch</code>函数正确的显示了所有的这两个容器的<code>items</code>匹配。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift集合类型]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.html"/>
    <updated>2014-11-27T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift集合类型</id>
    <content type="html"><![CDATA[<p>Swift 语言提供经典的数组和字典两种集合类型来存储集合数据。数组用来按顺序存储相同类型的数据。字典虽然无序存储相同类型数据值但是需要由独有的标识符引用和寻址（就是键值对）。</p>


<p>Swift 语言里的数组和字典中存储的数据值类型必须明确。 这意味着我们不能把不正确的数据类型插入其中。 同时这也说明我们完全可以对获取出的值类型非常自信。 Swift 对显式类型集合的使用确保了我们的代码对工作所需要的类型非常清楚，也让我们在开发中可以早早地找到任何的类型不匹配错误。</p>


<blockquote>
<p>注意：</p>
<p>Swift 的数组结构在被声明成常量和变量或者被传入函数与方法中时会相对于其他类型展现出不同的特性。 获取更多信息请参见<a href="#mutability_of_collections">集合的可变性</a>与<a href="09_Classes_and_Structures.html#assignment_and_copy_behavior_for_collection_types">集合在赋值和复制中的行为</a>章节。</p>
</blockquote>


<p><a name="arrays"></a></p>


<h2 id="-">数组</h2>


<p>数组使用有序列表存储相同类型的多重数据。相同的值可以多次出现在一个数组的不同位置中。</p>


<p>Swift 数组对存储数据有具体要求。 不同于 Objective-C 的<code>NSArray</code>和<code>NSMutableArray</code>类，他们可以存储任何类型的实例而且不提供他们返回对象的任何本质信息。 在 Swift 中，数据值在被存储进入某个数组之前类型必须明确，方法是通过显式的类型标注或类型推断，而且不是必须是<code>class</code>类型。例如： 如果我们创建了一个<code>Int</code>值类型的数组，我们不能往其中插入任何不是<code>Int</code>类型的数据。 Swift 中的数组是类型安全的，并且它们中包含的类型必须明确。</p>


<p><a name="array_type_shorthand_syntax"></a></p>


<h3 id="-">数组的简单语法</h3>


<p>写 Swift 数组应该遵循像<code>Array&lt;SomeType&gt;</code>这样的形式，其中<code>SomeType</code>是这个数组中唯一允许存在的数据类型。 我们也可以使用像<code>SomeType[]</code>这样的简单语法。 尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</p>


<p><a name="array_literals"></a></p>


<h3 id="-">数组构造语句</h3>


<p>我们可以使用字面语句来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。字面语句是一系列由逗号分割并由方括号包含的数值。
<code>[value 1, value 2, value 3]</code>。</p>


<p>下面这个例子创建了一个叫做<code>shoppingList</code>并且存储字符串的数组：</p>


<pre><code>var shoppingList: String[] = ["Eggs", "Milk"]
// shoppingList 已经被构造并且拥有两个初始项。
</code></pre>


<p><code>shoppingList</code>变量被声明为“字符串值类型的数组“，记作<code>String[]</code>。 因为这个数组被规定只有<code>String</code>一种数据结构，所以只有<code>String</code>类型可以在其中被存取。 在这里，<code>shoppinglist</code>数组由两个<code>String</code>值（<code>"Eggs"</code> 和<code>"Milk"</code>）构造，并且由字面语句定义。</p>


<blockquote>
<p>注意：</p>
<p><code>Shoppinglist</code>数组被声明为变量（<code>var</code>关键字创建）而不是常量（<code>let</code>创建）是因为以后可能会有更多的数据项被插入其中。</p>
</blockquote>


<p>在这个例子中，字面语句仅仅包含两个<code>String</code>值。匹配了该数组的变量声明（只能包含<code>String</code>的数组），所以这个字面语句的分配过程就是允许用两个初始项来构造<code>shoppinglist</code>。</p>


<p>由于 Swift 的类型推断机制，当我们用字面语句构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。 <code>shoppinglist</code>的构造也可以这样写：</p>


<pre><code>var shoppingList = ["Eggs", "Milk"]
</code></pre>


<p>因为所有字面语句中的值都是相同的类型，Swift 可以推断出<code>String[]</code>是<code>shoppinglist</code>中变量的正确类型。</p>


<p><a name="accessing_and_modifying_an_array"></a></p>


<h3 id="-">访问和修改数组</h3>


<p>我们可以通过数组的方法和属性来访问和修改数组，或者下标语法。
还可以使用数组的只读属性<code>count</code>来获取数组中的数据项数量。</p>


<pre><code>println("The shopping list contains \(shoppingList.count) items.")
// 输出"The shopping list contains 2 items."（这个数组有2个项）
</code></pre>


<p>使用布尔项<code>isEmpty</code>来作为检查<code>count</code>属性的值是否为 0 的捷径。</p>


<pre><code>if shoppingList.isEmpty {
    println("The shopping list is empty.")
} else {
    println("The shopping list is not empty.")
}
// 打印 "The shopping list is not empty."（shoppinglist不是空的）
</code></pre>


<p>也可以使用<code>append</code>方法在数组后面添加新的数据项：</p>


<pre><code>shoppingList.append("Flour")
// shoppingList 现在有3个数据项，有人在摊煎饼
</code></pre>


<p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加数据项：</p>


<pre><code>shoppingList += "Baking Powder"
// shoppingList 现在有四项了
</code></pre>


<p>我们也可以使用加法赋值运算符（<code>+=</code>）直接添加拥有相同类型数据的数组。</p>


<pre><code>shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
// shoppingList 现在有7项了
</code></pre>


<p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>


<pre><code>var firstItem = shoppingList[0]
// 第一项是 "Eggs"
</code></pre>


<p>注意第一项在数组中的索引值是<code>0</code>而不是<code>1</code>。 Swift 中的数组索引总是从零开始。</p>


<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>


<pre><code>shoppingList[0] = "Six eggs"
// 其中的第一项现在是 "Six eggs" 而不是 "Eggs"
</code></pre>


<p>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把<code>"Chocolate Spread"</code>，<code>"Cheese"</code>，和<code>"Butter"</code>替换为<code>"Bananas"</code>和 <code>"Apples"</code>：</p>


<pre><code>shoppingList[4...6] = ["Bananas", "Apples"]
// shoppingList 现在有六项
</code></pre>


<blockquote>
<p>注意：</p>
<p>我们不能使用下标语法在数组尾部添加新项。如果我们试着用这种方法对索引越界的数据进行检索或者设置新值的操作，我们会引发一个运行期错误。我们可以使用索引值和数组的<code>count</code>属性进行比较来在使用某个索引之前先检验是否有效。除了当<code>count</code>等于 0 时（说明这是个空数组），最大索引值一直是<code>count - 1</code>，因为数组都是零起索引。</p>
</blockquote>


<p>调用数组的<code>insert(atIndex:)</code>方法来在某个具体索引值之前添加数据项：</p>


<pre><code>shoppingList.insert("Maple Syrup", atIndex: 0)
// shoppingList 现在有7项
// "Maple Syrup" 现在是这个列表中的第一项
</code></pre>


<p>这次<code>insert</code>函数调用把值为<code>"Maple Syrup"</code>的新数据项插入列表的最开始位置，并且使用<code>0</code>作为索引值。</p>


<p>类似的我们可以使用<code>removeAtIndex</code>方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）:</p>


<pre><code>let mapleSyrup = shoppingList.removeAtIndex(0)
//索引值为0的数据项被移除
// shoppingList 现在只有6项，而且不包括Maple Syrup
// mapleSyrup常量的值等于被移除数据项的值 "Maple Syrup"
</code></pre>


<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为<code>0</code>的数据项的值再次等于<code>"Six eggs"</code>:</p>


<pre><code>firstItem = shoppingList[0]
// firstItem 现在等于 "Six eggs"
</code></pre>


<p>如果我们只想把数组中的最后一项移除，可以使用<code>removeLast</code>方法而不是<code>removeAtIndex</code>方法来避免我们需要获取数组的<code>count</code>属性。就像后者一样，前者也会返回被移除的数据项：</p>


<pre><code>let apples = shoppingList.removeLast()
// 数组的最后一项被移除了
// shoppingList现在只有5项，不包括cheese
//  apples 常量的值现在等于"Apples" 字符串
</code></pre>


<p><a name="iterating_over_an_array"></a></p>


<h3 id="-">数组的遍历</h3>


<p>我们可以使用<code>for-in</code>循环来遍历所有数组中的数据项：</p>


<pre><code>for item in shoppingList {
    println(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
</code></pre>


<p>如果我们同时需要每个数据项的值和索引值，可以使用全局<code>enumerate</code>函数来进行数组遍历。<code>enumerate</code>返回一个由每一个数据项索引值和数据值组成的键值对组。我们可以把这个键值对组分解成临时常量或者变量来进行遍历：</p>


<pre><code>for (index, value) in enumerate(shoppingList) {
    println("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
</code></pre>


<p>更多关于<code>for-in</code>循环的介绍请参见<a href="05_Control_Flow.html#for_loops">for 循环</a>。</p>


<p><a name="creating_and_initializing_an_array"></a></p>


<h3 id="-">创建并且构造一个数组</h3>


<p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>


<pre><code>var someInts = Int[]()
println("someInts is of type Int[] with \(someInts。count) items。")
// 打印 "someInts is of type Int[] with 0 items。"（someInts是0数据项的Int[]数组）
</code></pre>


<p>注意<code>someInts</code>被设置为一个<code>Int[]</code>构造函数的输出所以它的变量类型被定义为<code>Int[]</code>。</p>


<p>除此之外，如果代码上下文中提供了类型信息， 例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：<code>[]</code>（一对空方括号）：</p>


<pre><code>someInts.append(3)
// someInts 现在包含一个INT值
someInts = []
// someInts 现在是空数组，但是仍然是Int[]类型的。
</code></pre>


<p>Swift 中的<code>Array</code>类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（<code>count</code>）和适当类型的初始值（<code>repeatedValue</code>）传入数组构造函数：</p>


<pre><code>var threeDoubles = Double[](count: 3, repeatedValue:0.0)
// threeDoubles 是一种 Double[]数组, 等于 [0.0, 0.0, 0.0]
</code></pre>


<p>因为类型推断的存在，我们使用这种构造方法的时候不需要特别指定数组中存储的数据类型，因为类型可以从默认值推断出来：</p>


<pre><code>var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]
</code></pre>


<p>最后，我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>


<pre><code>var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles 被推断为 Double[], 等于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
</code></pre>


<p><a name="dictionaries"></a></p>


<h2 id="-">字典</h2>


<p>字典是一种存储相同类型多重数据的存储器。每个值（value）都关联独特的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>


<p>Swift 的字典使用时需要具体规定可以存储键和值类型。不同于 Objective-C 的<code>NSDictionary</code>和<code>NSMutableDictionary</code> 类可以使用任何类型的对象来作键和值并且不提供任何关于这些对象的本质信息。在 Swift 中，在某个特定字典中可以存储的键和值必须提前定义清楚，方法是通过显性类型标注或者类型推断。</p>


<p>Swift 的字典使用<code>Dictionary&lt;KeyType, ValueType&gt;</code>定义,其中<code>KeyType</code>是字典中键的数据类型，<code>ValueType</code>是字典中对应于这些键所存储值的数据类型。</p>


<p><code>KeyType</code>的唯一限制就是可哈希的，这样可以保证它是独一无二的，所有的 Swift 基本类型（例如<code>String</code>，<code>Int</code>， <code>Double</code>和<code>Bool</code>）都是默认可哈希的，并且所有这些类型都可以在字典中当做键使用。未关联值的枚举成员（参见<a href="08_Enumerations.html">枚举</a>）也是默认可哈希的。</p>


<p><a name="dictionary_literals"></a></p>


<h2 id="-">字典字面语句</h2>


<p>我们可以使用字典字面语句来构造字典，他们和我们刚才介绍过的数组字面语句拥有相似语法。一个字典字面语句是一个定义拥有一个或者多个键值对的字典集合的简单语句。</p>


<p>一个键值对是一个<code>key</code>和一个<code>value</code>的结合体。在字典字面语句中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含并且由逗号分割：</p>


<pre><code>[key 1: value 1, key 2: value 2, key 3: value 3]
</code></pre>


<p>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>


<pre><code>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]
</code></pre>


<p><code>airports</code>字典被定义为一种<code>Dictionary&lt;String, String&gt;</code>,它意味着这个字典的键和值都是<code>String</code>类型。</p>


<blockquote>
<p>注意：</p>
<p><code>airports</code>字典被声明为变量（用<code>var</code>关键字）而不是常量（<code>let</code>关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
</blockquote>


<p><code>airports</code>字典使用字典字面语句初始化，包含两个键值对。第一对的键是<code>TYO</code>，值是<code>Tokyo</code>。第二对的键是<code>DUB</code>，值是<code>Dublin</code>。</p>


<p>这个字典语句包含了两个<code>String: String</code>类型的键值对。他们对应<code>airports</code>变量声明的类型（一个只有<code>String</code>键和<code>String</code>值的字典）所以这个字典字面语句是构造两个初始数据项的<code>airport</code>字典。</p>


<p>和数组一样，如果我们使用字面语句构造字典就不用把类型定义清楚。<code>airports</code>的也可以用这种方法简短定义：</p>


<pre><code>var airports = ["TYO": "Tokyo", "DUB": "Dublin"]
</code></pre>


<p>因为这个语句中所有的键和值都分别是相同的数据类型，Swift 可以推断出<code>Dictionary&lt;String, String&gt;</code>是<code>airports</code>字典的正确类型。</p>


<p><a name="accessing_and_modifying_a_dictionary"></a></p>


<h3 id="-">读取和修改字典</h3>


<p>我们可以通过字典的方法和属性来读取和修改字典，或者使用下标语法。和数组一样，我们可以通过字典的只读属性<code>count</code>来获取某个字典的数据项数量：</p>


<pre><code>println("The dictionary of airports contains \(airports.count) items.")
// 打印 "The dictionary of airports contains 2 items."（这个字典有两个数据项）
</code></pre>


<p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个合适类型的 key 作为下标索引，并且分配新的合适类型的值：</p>


<pre><code>airports["LHR"] = "London"
// airports 字典现在有三个数据项
</code></pre>


<p>我们也可以使用下标语法来改变特定键对应的值：</p>


<pre><code>airports["LHR"] = "London Heathrow"
// "LHR"对应的值 被改为 "London Heathrow
</code></pre>


<p>作为另一种下标方法，字典的<code>updateValue(forKey:)</code>方法可以设置或者更新特定键对应的值。就像上面所示的示例，<code>updateValue(forKey:)</code>方法在这个键不存在对应值的时候设置值或者在存在时更新已存在的值。和上面的下标方法不一样，这个方法返回更新值之前的原值。这样方便我们检查更新是否成功。</p>


<p><code>updateValue(forKey:)</code>函数会返回包含一个字典值类型的可选值。举例来说：对于存储<code>String</code>值的字典，这个函数会返回一个<code>String?</code>或者“可选 <code>String</code>”类型的值。如果值存在，则这个可选值值等于被替换的值，否则将会是<code>nil</code>。</p>


<pre><code>if let oldValue = airports.updateValue("Dublin Internation", forKey: "DUB") {
    println("The old value for DUB was \(oldValue).")
}
// 输出 "The old value for DUB was Dublin."（dub原值是dublin）
</code></pre>


<p>我们也可以使用下标语法来在字典中检索特定键对应的值。由于使用一个没有值的键这种情况是有可能发生的，可选类型返回这个键存在的相关值，否则就返回<code>nil</code>：</p>


<pre><code>if let airportName = airports["DUB"] {
    println("The name of the airport is \(airportName).")
} else {
    println("That airport is not in the airports dictionary.")
}
// 打印 "The name of the airport is Dublin INTernation."（机场的名字是都柏林国际）
</code></pre>


<p>我们还可以使用下标语法来通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对：</p>


<pre><code>airports["APL"] = "Apple Internation"
// "Apple Internation"不是真的 APL机场, 删除它
airports["APL"] = nil
// APL现在被移除了
</code></pre>


<p>另外，<code>removeValueForKey</code>方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的value或者在没有值的情况下返回<code>nil</code>：</p>


<pre><code>if let removedValue = airports.removeValueForKey("DUB") {
    println("The removed airport's name is \(removedValue).")
} else {
    println("The airports dictionary does not contain a value for DUB.")
}
// prints "The removed airport's name is Dublin International."
</code></pre>


<p><a name="iterating_over_a_dictionary"></a></p>


<h3 id="-">字典遍历</h3>


<p>我们可以使用<code>for-in</code>循环来遍历某个字典中的键值对。每一个字典中的数据项都由<code>(key, value)</code>元组形式返回，并且我们可以使用暂时性常量或者变量来分解这些元组：</p>


<pre><code>for (airportCode, airportName) in airports {
    prINTln("\(airportCode): \(airportName)")
}
// TYO: Tokyo
// LHR: London Heathrow
</code></pre>


<p><code>for-in</code>循环请参见<a href="05_Control_Flow.html#for_loops">For 循环</a>。</p>


<p>我们也可以通过访问他的<code>keys</code>或者<code>values</code>属性（都是可遍历集合）检索一个字典的键或者值：</p>


<pre><code>for airportCode in airports.keys {
    prINTln("Airport code: \(airportCode)")
}
// Airport code: TYO
// Airport code: LHR

for airportName in airports.values {
    prINTln("Airport name: \(airportName)")
}
// Airport name: Tokyo
// Airport name: London Heathrow
</code></pre>


<p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受<code>Array</code>实例 API 的参数，可以直接使用<code>keys</code>或者<code>values</code>属性直接构造一个新数组：</p>


<pre><code>let airportCodes = Array(airports.keys)
// airportCodes is ["TYO", "LHR"]

let airportNames = Array(airports.values)
// airportNames is ["Tokyo", "London Heathrow"]
</code></pre>


<blockquote>
<p>注意：</p>
<p>Swift 的字典类型是无序集合类型。其中字典键，值，键值对在遍历的时候会重新排列，而且其中顺序是不固定的。</p>
</blockquote>


<p><a name="creating_an_empty_dictionary"></a></p>


<h3 id="-">创建一个空字典</h3>


<p>我们可以像数组一样使用构造语法创建一个空字典：</p>


<pre><code>var namesOfIntegers = Dictionary&lt;Int, String&gt;()
// namesOfIntegers 是一个空的 Dictionary&lt;Int, String&gt;
</code></pre>


<p>这个例子创建了一个<code>Int, String</code>类型的空字典来储存英语对整数的命名。他的键是<code>Int</code>型，值是<code>String</code>型。</p>


<p>如果上下文已经提供了信息类型，我们可以使用空字典字面语句来创建一个空字典，记作<code>[:]</code>（中括号中放一个冒号）：</p>


<pre><code>namesOfIntegers[16] = "sixteen"
// namesOfIntegers 现在包含一个键值对
namesOfIntegers = [:]
// namesOfIntegers 又成为了一个 Int, String类型的空字典
</code></pre>


<blockquote>
<p>注意：</p>
<p>在后台，Swift 的数组和字典都是由泛型集合来实现的，想了解更多泛型和集合信息请参见<a href="22_Generics.html">泛型</a>。</p>
</blockquote>


<p><a name="mutability_of_collections"></a></p>


<h2 id="-">集合的可变性</h2>


<p>数组和字典都是在单个集合中存储可变值。如果我们创建一个数组或者字典并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小。与此相反，如果我们把数组或字典分配成常量，那么他就是不可变的，它的大小不能被改变。</p>


<p>对字典来说，不可变性也意味着我们不能替换其中任何现有键所对应的值。不可变字典的内容在被首次设定之后不能更改。
不可变行对数组来说有一点不同，当然我们不能试着改变任何不可变数组的大小，但是我们·可以重新设定相对现存索引所对应的值。这使得 Swift 数组在大小被固定的时候依然可以做的很棒。</p>


<p>Swift 数组的可变性行为同时影响了数组实例如何被分配和修改，想获取更多信息，请参见<a href="09_Classes_and_Structures.html#assignment_and_copy_behavior_for_collection_types">集合在赋值和复制中的行为</a>。</p>


<blockquote>
<p>注意：</p>
<p>在我们不需要改变数组大小的时候创建不可变数组是很好的习惯。如此 Swift 编译器可以优化我们创建的集合。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift附属脚本]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%99%84%E5%B1%9E%E8%84%9A%E6%9C%AC.html"/>
    <updated>2014-11-27T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift附属脚本</id>
    <content type="html"><![CDATA[<p><em>附属脚本</em> 可以定义在类（Class）、结构体（structure）和枚举（enumeration）这些目标中，可以认为是访问对象、集合或序列的快捷方式，不需要再调用实例的特定的赋值和访问方法。举例来说，用附属脚本访问一个数组(Array)实例中的元素可以这样写 <code>someArray[index]</code> ，访问字典(Dictionary)实例中的元素可以这样写 <code>someDictionary[key]</code>。</p>


<p>对于同一个目标可以定义多个附属脚本，通过索引值类型的不同来进行重载，而且索引值的个数可以是多个。</p>


<blockquote>
<p>译者：这里附属脚本重载在本小节中原文并没有任何演示</p>
</blockquote>


<p><a name="subscript_syntax"></a></p>


<h2 id="-">附属脚本语法</h2>


<p>附属脚本允许你通过在实例后面的方括号中传入一个或者多个的索引值来对实例进行访问和赋值。语法类似于实例方法和计算型属性的混合。与定义实例方法类似，定义附属脚本使用<code>subscript</code>关键字，显式声明入参（一个或多个）和返回类型。与实例方法不同的是附属脚本可以设定为读写或只读。这种方式又有点像计算型属性的getter和setter：</p>


<pre><code>subscript(index: Int) -&gt; Int {
    get {
        // 返回与入参匹配的Int类型的值
    }

    set(newValue) {
        // 执行赋值操作
    }
}
</code></pre>


<p><code>newValue</code>的类型必须和附属脚本定义的返回类型相同。与计算型属性相同的是set的入参声明<code>newValue</code>就算不写，在set代码块中依然可以使用默认的<code>newValue</code>这个变量来访问新赋的值。</p>


<p>与只读计算型属性一样，可以直接将原本应该写在<code>get</code>代码块中的代码写在<code>subscript</code>中：</p>


<pre><code>subscript(index: Int) -&gt; Int {
    // 返回与入参匹配的Int类型的值
}
</code></pre>


<p>下面代码演示了一个在<code>TimesTable</code>结构体中使用只读附属脚本的用法，该结构体用来展示传入整数的<em>n</em>倍。</p>


<pre><code>struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
println("3的6倍是\(threeTimesTable[6])")
// 输出 "3的6倍是18"
</code></pre>


<p>在上例中，通过<code>TimesTable</code>结构体创建了一个用来表示索引值三倍的实例。数值<code>3</code>作为结构体<code>构造函数</code>入参初始化实例成员<code>multiplier</code>。</p>


<p>你可以通过附属脚本来来得到结果，比如<code>threeTimesTable[6]</code>。这句话访问了<code>threeTimesTable</code>的第六个元素，返回<code>18</code>或者<code>6</code>的<code>3</code>倍。</p>


<blockquote>
<p>注意：</p>
<p><code>TimesTable</code>例子是基于一个固定的数学公式。它并不适合开放写权限来对<code>threeTimesTable[someIndex]</code>进行赋值操作，这也是为什么附属脚本只定义为只读的原因。</p>
</blockquote>


<p><a name="subscript_usage"></a></p>


<h2 id="-">附属脚本用法</h2>


<p>根据使用场景不同附属脚本也具有不同的含义。通常附属脚本是用来访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。你可以在你自己特定的类或结构体中自由的实现附属脚本来提供合适的功能。</p>


<p>例如，Swift 的字典（Dictionary）实现了通过附属脚本来对其实例中存放的值进行存取操作。在附属脚本中使用和字典索引相同类型的值，并且把一个字典值类型的值赋值给这个附属脚本来为字典设值：</p>


<pre><code>var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
numberOfLegs["bird"] = 2
</code></pre>


<p>上例定义一个名为<code>numberOfLegs</code>的变量并用一个字典字面量初始化出了包含三对键值的字典实例。<code>numberOfLegs</code>的字典存放值类型推断为<code>Dictionary&lt;String, Int&gt;</code>。字典实例创建完成之后通过附属脚本的方式将整型值<code>2</code>赋值到字典实例的索引为<code>bird</code>的位置中。</p>


<p>更多关于字典（Dictionary）附属脚本的信息请参考<a href="../chapter2/04_Collection_Types.html">读取和修改字典</a></p>


<blockquote>
<p>注意：</p>
<p>Swift 中字典的附属脚本实现中，在<code>get</code>部分返回值是<code>Int?</code>，上例中的<code>numberOfLegs</code>字典通过下边返回的是一个<code>Int?</code>或者说“可选的int”，不是每个字典的索引都能得到一个整型值，对于没有设过值的索引的访问返回的结果就是<code>nil</code>；同样想要从字典实例中删除某个索引下的值也只需要给这个索引赋值为<code>nil</code>即可。</p>
</blockquote>


<p><a name="subscript_options"></a></p>


<h2 id="-">附属脚本选项</h2>


<p>附属脚本允许任意数量的入参索引，并且每个入参类型也没有限制。附属脚本的返回值也可以是任何类型。附属脚本可以使用变量参数和可变参数，但使用写入读出（in-out）参数或给参数设置默认值都是不允许的。</p>


<p>一个类或结构体可以根据自身需要提供多个附属脚本实现，在定义附属脚本时通过入参个类型进行区分，使用附属脚本时会自动匹配合适的附属脚本实现运行，这就是<em>附属脚本的重载</em>。</p>


<p>一个附属脚本入参是最常见的情况，但只要有合适的场景也可以定义多个附属脚本入参。如下例定义了一个<code>Matrix</code>结构体，将呈现一个<code>Double</code>类型的二维矩阵。<code>Matrix</code>结构体的附属脚本需要两个整型参数：</p>


<pre><code>struct Matrix {
    let rows: Int, columns: Int
    var grid: Double[]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            return grid[(row * columns) + column]
        }
        set {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            grid[(row * columns) + columns] = newValue
        }
    }
}
</code></pre>


<p><code>Matrix</code>提供了一个两个入参的构造方法，入参分别是<code>rows</code>和<code>columns</code>，创建了一个足够容纳<code>rows * columns</code>个数的<code>Double</code>类型数组。为了存储，将数组的大小和数组每个元素初始值0.0，都传入数组的构造方法中来创建一个正确大小的新数组。关于数组的构造方法和析构方法请参考<a href="../chapter2/04_Collection_Types.html">创建并且构造一个数组</a>。</p>


<p>你可以通过传入合适的<code>row</code>和<code>column</code>的数量来构造一个新的<code>Matrix</code>实例：</p>


<pre><code>var matrix = Matrix(rows: 2, columns: 2)
</code></pre>


<p>上例中创建了一个新的两行两列的<code>Matrix</code>实例。在阅读顺序从左上到右下的<code>Matrix</code>实例中的数组实例<code>grid</code>是矩阵二维数组的扁平化存储：</p>


<pre><code>// 示意图
grid = [0.0, 0.0, 0.0, 0.0]

        col0     col1
row0   [0.0,     0.0,
row1    0.0,     0.0]
</code></pre>


<p>将值赋给带有<code>row</code>和<code>column</code>附属脚本的<code>matrix</code>实例表达式可以完成赋值操作，附属脚本入参使用逗号分割</p>


<pre><code>matrix[0, 1] = 1.5
matrix[1, 0] = 3.2
</code></pre>


<p>上面两条语句分别<code>让matrix</code>的右上值为 1.5，坐下值为 3.2：</p>


<pre><code>[0.0, 1.5,
 3.2, 0.0]
</code></pre>


<p><code>Matrix</code>附属脚本的<code>getter</code>和<code>setter</code>中同时调用了附属脚本入参的<code>row</code>和<code>column</code>是否有效的判断。为了方便进行断言，<code>Matrix</code>包含了一个名为<code>indexIsValid</code>的成员方法，用来确认入参的<code>row</code>或<code>column</code>值是否会造成数组越界：</p>


<pre><code>func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
    return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
}
</code></pre>


<p>断言在附属脚本越界时触发：</p>


<pre><code>let someValue = matrix[2, 2]
// 断言将会触发，因为 [2, 2] 已经超过了matrix的最大长度
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift闭包]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%97%AD%E5%8C%85.html"/>
    <updated>2014-11-27T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift闭包</id>
    <content type="html"><![CDATA[<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。
Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 lambdas 函数比较相似。</p>


<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。
这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。</p>


<blockquote>
<p>注意：</p>
<p>如果您不熟悉捕获（capturing）这个概念也不用担心，您可以在 <a href="#capturing_values">值捕获</a> 章节对其进行详细了解。</p>
</blockquote>


<p>在<a href="../chapter2/06_Function.html">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：</p>


<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>


<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>


<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随（Trailing）闭包语法</li>
</ul>


<p><a name="closure_expressions"></a></p>


<h2 id="-closure-expressions-">闭包表达式（Closure Expressions）</h2>


<p><a href="../chapter2/06_Function.html#nested_function">嵌套函数</a> 是一个在较复杂函数中方便进行命名和定义自包含代码模块的方式。
当然，有时候撰写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在您处理一些函数并需要将另外一些函数作为该函数的参数时。</p>


<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。
闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。
下面闭包表达式的例子通过使用几次迭代展示了<code>sort</code>函数定义和语法优化的方式。
每一次迭代都用更简洁的方式描述了相同的功能。</p>


<p><a name="the_sort_function"></a></p>


<h3 id="sort-the-sort-function-">sort 函数（The Sort Function）</h3>


<p>Swift 标准库提供了<code>sort</code>函数，会根据您提供的基于输出类型排序的闭包函数将已知类型数组中的值进行排序。
一旦排序完成，函数会返回一个与原数组大小相同的新数组，该数组中包含已经正确排序的同类型元素。</p>


<p>下面的闭包表达式示例使用<code>sort</code>函数对一个<code>String</code>类型的数组进行字母逆序排序，以下是初始数组值：</p>


<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</code></pre>


<p><code>sort</code>函数需要传入两个参数：</p>


<ul>
<li>已知类型的数组</li>
<li>闭包函数，该闭包函数需要传入与数组类型相同的两个值，并返回一个布尔类型值来告诉<code>sort</code>函数当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回<code>true</code>，反之返回<code>false</code>。</li>
</ul>


<p>该例子对一个<code>String</code>类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p>


<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为<code>sort</code>函数的第二个参数传入：</p>


<pre><code>func backwards(s1: String, s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversed = sort(names, backwards)
// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
</code></pre>


<p>如果第一个字符串 (<code>s1</code>) 大于第二个字符串 (<code>s2</code>)，<code>backwards</code>函数返回<code>true</code>，表示在新的数组中<code>s1</code>应该出现在<code>s2</code>前。
对于字符串中的字符来说，“大于” 表示 “按照字母顺序较晚出现”。
这意味着字母<code>"B"</code>大于字母<code>"A"</code>，字符串<code>"Tom"</code>大于字符串<code>"Tim"</code>。
其将进行字母逆序排序，<code>"Barry"</code>将会排在<code>"Alex"</code>之后。</p>


<p>然而，这是一个相当冗长的方式，本质上只是写了一个单表达式函数 (a &gt; b)。
在下面的例子中，利用闭合表达式语法可以更好的构造一个内联排序闭包。</p>


<p><a name="closure_expression_syntax"></a></p>


<h3 id="-closure-expression-syntax-">闭包表达式语法（Closure Expression Syntax）</h3>


<p>闭包表达式语法有如下一般形式：</p>


<pre><code>{ (parameters) -&gt; returnType in
    statements
}
</code></pre>


<p>闭包表达式语法可以使用常量、变量和<code>inout</code>类型作为参数，不提供默认值。
也可以在参数列表的最后使用可变参数。
元组也可以作为参数和返回值。</p>


<p>下面的例子展示了之前<code>backwards</code>函数对应的闭包表达式版本的代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
    })
</code></pre>


<p>需要注意的是内联闭包参数和返回值类型声明与<code>backwards</code>函数类型声明相同。
在这两种方式中，都写成了<code>(s1: String, s2: String) -&gt; Bool</code>。
然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>


<p>闭包的函数体部分由关键字<code>in</code>引入。
该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>


<p>因为这个闭包的函数体部分如此短以至于可以将其改写成一行代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )
</code></pre>


<p>这说明<code>sort</code>函数的整体调用保持不变，一对圆括号仍然包裹住了函数中整个参数集合。而其中一个参数现在变成了内联闭包（相比于<code>backwards</code>版本的代码）。</p>


<p><a name="inferring_type_from_context"></a></p>


<h3 id="-inferring-type-from-context-">根据上下文推断类型（Inferring Type From Context）</h3>


<p>因为排序闭包函数是作为<code>sort</code>函数的参数进行传入的，Swift可以推断其参数和返回值的类型。
<code>sort</code>期望第二个参数是类型为<code>(String, String) -&gt; Bool</code>的函数，因此实际上<code>String</code>,<code>String</code>和<code>Bool</code>类型并不需要作为闭包表达式定义中的一部分。
因为所有的类型都可以被正确推断，返回箭头 (<code>-&gt;</code>) 和围绕在参数周围的括号也可以被省略：</p>


<pre><code>reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )
</code></pre>


<p>实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数时，都可以推断出闭包的参数和返回值类型，这意味着您几乎不需要利用完整格式构造任何内联闭包。</p>


<p><a name="implicit_returns_from_single_expression_closures"></a></p>


<h3 id="-implicit-return-from-single-expression-clossures-">单表达式闭包隐式返回（Implicit Return From Single-Expression Clossures）</h3>


<p>单行表达式闭包可以通过隐藏<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>


<pre><code>reversed = sort(names, { s1, s2 in s1 &gt; s2 } )
</code></pre>


<p>在这个例子中，<code>sort</code>函数的第二个参数函数类型明确了闭包必须返回一个<code>Bool</code>类型值。
因为闭包函数体只包含了一个单一表达式 (<code>s1 &gt; s2</code>)，该表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略。</p>


<p><a name="shorthand_argument_names"></a></p>


<h3 id="-shorthand-argument-names-">参数名称缩写（Shorthand Argument Names）</h3>


<p>Swift 自动为内联函数提供了参数名称缩写功能，您可以直接通过<code>$0</code>,<code>$1</code>,<code>$2</code>来顺序调用闭包的参数。</p>


<p>如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。
<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>


<pre><code>reversed = sort(names, { $0 &gt; $1 } )
</code></pre>


<p>在这个例子中，<code>$0</code>和<code>$1</code>表示闭包中第一个和第二个<code>String</code>类型的参数。</p>


<p><a name="operator_functions"></a></p>


<h3 id="-operator-functions-">运算符函数（Operator Functions）</h3>


<p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。
Swift 的<code>String</code>类型定义了关于大于号 (<code>&gt;</code>) 的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。
而这正好与<code>sort</code>函数的第二个参数需要的函数类型相符合。
因此，您可以简单地传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现：</p>


<pre><code>reversed = sort(names, &gt;)
</code></pre>


<p>更多关于运算符表达式的内容请查看 <a href="../chapter2/23_Advanced_Operators.html#operator_functions">运算符函数</a>。</p>


<p><a name="trailing_closures"></a></p>


<h2 id="-trailing-closures-">尾随闭包（Trailing Closures）</h2>


<p>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。
尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</p>


<pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; ()) {
    // 函数体部分
}

// 以下是不使用尾随闭包进行函数调用

someFunctionThatTakesAClosure({
    // 闭包主体部分
    })

// 以下是使用尾随闭包进行函数调用

someFunctionThatTakesAClosure() {
    // 闭包主体部分
}
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把<code>()</code>省略掉。</p>
</blockquote>


<p>在上例中作为<code>sort</code>函数参数的字符串排序闭包可以改写为：</p>


<pre><code>reversed = sort(names) { $0 &gt; $1 }
</code></pre>


<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。
举例来说，Swift 的<code>Array</code>类型有一个<code>map</code>方法，其获取一个闭包表达式作为其唯一参数。
数组中的每一个元素调用一次该闭包函数，并返回该元素所映射的值(也可以是不同类型的值)。
具体的映射方式和返回值类型由闭包来指定。</p>


<p>当提供给数组闭包函数后，<code>map</code>方法将返回一个新的数组，数组中包含了与原数组一一对应的映射后的值。</p>


<p>下例介绍了如何在<code>map</code>方法中使用尾随闭包将<code>Int</code>类型数组<code>[16,58,510]</code>转换为包含对应<code>String</code>类型的数组<code>["OneSix", "FiveEight", "FiveOneZero"]</code>:</p>


<pre><code>let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
</code></pre>


<p>如上代码创建了一个数字位和他们名字映射的英文版本字典。
同时定义了一个准备转换为字符串的整型数组。</p>


<p>您现在可以通过传递一个尾随闭包给<code>numbers</code>的<code>map</code>方法来创建对应的字符串版本数组。
需要注意的时调用<code>numbers.map</code>不需要在<code>map</code>后面包含任何括号，因为其只需要传递闭包表达式这一个参数，并且该闭包表达式参数通过尾随方式进行撰写：</p>


<pre><code>let strings = numbers.map {
    (var number) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
// strings 常量被推断为字符串类型数组，即 String[]
// 其值为 ["OneSix", "FiveEight", "FiveOneZero"]
</code></pre>


<p><code>map</code>在数组中为每一个元素调用了闭包表达式。
您不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行推断。</p>


<p>闭包<code>number</code>参数被声明为一个变量参数（变量的具体描述请参看<a href="../chapter2/06_Functions.html#closure_expression_syntax">常量参数和变量参数</a>），因此可以在闭包函数体内对其进行修改。
闭包表达式制定了返回类型为<code>String</code>，以表明存储映射值的新数组类型为<code>String</code>。</p>


<p>闭包表达式在每次被调用的时候创建了一个字符串并返回。
其使用求余运算符 (number % 10) 计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。</p>


<blockquote>
<p>注意：</p>
<p>字典<code>digitNames</code>下标后跟着一个叹号 (!)，因为字典下标返回一个可选值 (optional value)，表明即使该 key 不存在也不会查找失败。
在上例中，它保证了<code>number % 10</code>可以总是作为一个<code>digitNames</code>字典的有效下标 key。
因此叹号可以用于强制解析 (force-unwrap) 存储在可选下标项中的<code>String</code>类型值。</p>
</blockquote>


<p>从<code>digitNames</code>字典中获取的字符串被添加到输出的前部，逆序建立了一个字符串版本的数字。
（在表达式<code>number % 10</code>中，如果number为16，则返回6，58返回8，510返回0）。</p>


<p><code>number</code>变量之后除以10。
因为其是整数，在计算过程中未除尽部分被忽略。
因此 16变成了1，58变成了5，510变成了51。</p>


<p>整个过程重复进行，直到<code>number /= 10</code>为0，这时闭包会将字符串输出，而<code>map</code>函数则会将字符串添加到所映射的数组中。</p>


<p>上例中尾随闭包语法在函数后整洁封装了具体的闭包功能，而不再需要将整个闭包包裹在<code>map</code>函数的括号内。</p>


<p><a name="capturing_values"></a></p>


<h2 id="-capturing-values-">捕获值（Capturing Values）</h2>


<p>闭包可以在其定义的上下文中捕获常量或变量。
即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>


<p>Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>


<p>下例为一个叫做<code>makeIncrementor</code>的函数，其包含了一个叫做<code>incrementor</code>嵌套函数。
嵌套函数<code>incrementor</code>从上下文中捕获了两个值，<code>runningTotal</code>和<code>amount</code>。
之后<code>makeIncrementor</code>将<code>incrementor</code>作为闭包返回。
每次调用<code>incrementor</code>时，其会以<code>amount</code>作为增量增加<code>runningTotal</code>的值。</p>


<pre><code>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}
</code></pre>


<p><code>makeIncrementor</code>返回类型为<code>() -&gt; Int</code>。
这意味着其返回的是一个函数，而不是一个简单类型值。
该函数在每次调用时不接受参数只返回一个<code>Int</code>类型的值。
关于函数返回其他函数的内容，请查看<a href="../chapter2/06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>


<p><code>makeIncrementor</code>函数定义了一个整型变量<code>runningTotal</code>(初始为0) 用来存储当前跑步总数。
该值通过<code>incrementor</code>返回。</p>


<p><code>makeIncrementor</code>有一个<code>Int</code>类型的参数，其外部命名为<code>forIncrement</code>， 内部命名为<code>amount</code>，表示每次<code>incrementor</code>被调用时<code>runningTotal</code>将要增加的量。</p>


<p><code>incrementor</code>函数用来执行实际的增加操作。
该函数简单地使<code>runningTotal</code>增加<code>amount</code>，并将其返回。</p>


<p>如果我们单独看这个函数，会发现看上去不同寻常：</p>


<pre><code>func incrementor() -&gt; Int {
    runningTotal += amount
    return runningTotal
}
</code></pre>


<p><code>incrementor</code>函数并没有获取任何参数，但是在函数体内访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为其通过捕获在包含它的函数体内已经存在的<code>runningTotal</code>和<code>amount</code>变量而实现。</p>


<p>由于没有修改<code>amount</code>变量，<code>incrementor</code>实际上捕获并存储了该变量的一个副本，而该副本随着<code>incrementor</code>一同被存储。</p>


<p>然而，因为每次调用该函数的时候都会修改<code>runningTotal</code>的值，<code>incrementor</code>捕获了当前<code>runningTotal</code>变量的引用，而不是仅仅复制该变量的初始值。捕获一个引用保证了当<code>makeIncrementor</code>结束时候并不会消失，也保证了当下一次执行<code>incrementor</code>函数时，<code>runningTotal</code>可以继续增加。</p>


<blockquote>
<p>注意：</p>
<p>Swift 会决定捕获引用还是拷贝值。
您不需要标注<code>amount</code>或者<code>runningTotal</code>来声明在嵌入的<code>incrementor</code>函数中的使用方式。
Swift 同时也处理<code>runingTotal</code>变量的内存管理操作，如果不再被<code>incrementor</code>函数使用，则会被清除。</p>
</blockquote>


<p>下面代码为一个使用<code>makeIncrementor</code>的例子：</p>


<pre><code>let incrementByTen = makeIncrementor(forIncrement: 10)
</code></pre>


<p>该例子定义了一个叫做<code>incrementByTen</code>的常量，该常量指向一个每次调用会加10的<code>incrementor</code>函数。
调用这个函数多次可以得到以下结果：</p>


<pre><code>incrementByTen()
// 返回的值为10
incrementByTen()
// 返回的值为20
incrementByTen()
// 返回的值为30
</code></pre>


<p>如果您创建了另一个<code>incrementor</code>，其会有一个属于自己的独立的<code>runningTotal</code>变量的引用。
下面的例子中，<code>incrementBySevne</code>捕获了一个新的<code>runningTotal</code>变量，该变量和<code>incrementByTen</code>中捕获的变量没有任何联系：</p>


<pre><code>let incrementBySeven = makeIncrementor(forIncrement: 7)
incrementBySeven()
// 返回的值为7
incrementByTen()
// 返回的值为40
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果您闭包分配给一个类实例的属性，并且该闭包通过指向该实例或其成员来捕获了该实例，您将创建一个在闭包和实例间的强引用环。
Swift 使用捕获列表来打破这种强引用环。更多信息，请参考 <a href="../chapter2/16_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>


<p><a name="closures_are_reference_types"></a></p>


<h2 id="-closures-are-reference-types-">闭包是引用类型（Closures Are Reference Types）</h2>


<p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。
这是因为函数和闭包都是引用类型。</p>


<p>无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。
上面的例子中，<code>incrementByTen</code>指向闭包的引用是一个常量，而并非闭包内容本身。</p>


<p>这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包：</p>


<pre><code>let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// 返回的值为50
</code></pre>

]]></content>
  </entry>
  
</feed>
