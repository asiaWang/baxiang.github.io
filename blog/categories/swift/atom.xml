<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | 小巴童鞋]]></title>
  <link href="http://baxiang123.com//blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://baxiang123.com//"/>
  <updated>2015-03-15T05:16:02+08:00</updated>
  <id>http://baxiang123.com//</id>
  <author>
    <name><![CDATA[小巴]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Objective-C特性编写Swift类]]></title>
    <link href="http://baxiang123.com//blog/Writing%20Swift%20Classes%20with%20Objective-C%20Behavior.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Writing Swift Classes with Objective-C Behavior</id>
    <content type="html"><![CDATA[<p>互用性（互操作性）使开发者可以定义融合了 Objective-C 语言特性的Swift类。编写 Swift 类时，不仅可以继承 Objective-C 语言编写的父类，采用 Objective-C 的协议，还可以利用 Objective-C 的一些其它功能。这意味着，开发者可以基于 Objective-C 中已有的熟悉、可靠的类、方法和框架来创建 Swift 类，并结合 Swift 提供的现代化和更有效的语言特点对其进行优化。</p>

<!--more-->


<p><a name="inheriting_from_objective-c_classes"></a></p>

<h3>继承Objective-C的类</h3>

<p>在 Swift 中，开发者可以定义一个子类，该子类继承自使用 Objective-C 编写的类。创建该子类的方法是，在 Swift 的类名后面加上一个冒号（:），冒号后面跟上 Objective-C 的类名。</p>

<pre><code class="swift">import UIKit

class MySwiftViewController: UIViewController {
    // 定义类
}
</code></pre>

<p>开发者能够从 Objective-C 的父类中继承所有的功能。如果开发者要覆盖父类中的方法，不要忘记使用<code>override</code>关键字。</p>

<p><a name="adopting_protocols"></a></p>

<h3>采用协议</h3>

<p>在 Swift 中，开发者可以采用 Objective-C 中定义好的协议。和 Swift 协议一样，所有 Objective-C 协议都写在一个用逗号隔开的列表中，跟在所在类的父类名后面（如果它有父类的话）。</p>

<pre><code class="swift">class MySwiftViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
    // 定义类
}
</code></pre>

<p>Objective-C 协议与 Swift 协议使用上是一致的。如果开发者想在 Swift 代码中引用 <code>UITableViewDelegate</code>协议，可以直接使用<code>UITableViewDelegate</code>（跟在 Objective-C 中引用<code>id&lt;UITableViewDelegate&gt;</code>是等价的）。</p>

<p><a name="writing_initializers_and_deinitializers"></a></p>

<h3>编写构造器和析构器</h3>

<p>Swift 的编译器确保在初始化时，构造器不允许类里有任何未初始化的属性，这样做能够增加代码的安全性和可预测性。另外，与 Objective-C 语言不同，Swift 不提供单独的内存分配方法供开发者调用。当你使用原生的 Swift 初始化方法时（即使是和 Objective-C 类协作），Swift 会将 Objective-C 的初始化方法转换为 Swift 的初始化方法。关于如何实现开发者自定义构造器的更多信息，请查看<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/14Initialization.md">构造器</a>。</p>

<p>当开发者希望在类被释放前，执行额外的清理工作时，需要执行一个析构过程来代替<code>dealloc</code>方法。在实例被释放前，Swift 会自动调用析构器来执行析构过程。Swift 调用完子类的析构器后，会自动调用父类的析构器。当开发者使用 Objective-C 类或者是继承自 Objective-C 类的 Swift 类时，Swift 也会自动为开发者调用这个类的父类里的<code>dealloc</code>方法。关于如何实现开发者自定义析构器的更多信息，请查看<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/15Deinitialization.md">析构器</a>。</p>

<p><a name="integrating_with_interface_builder"></a></p>

<h3>集成Interface Builder</h3>

<p>Swift 编译器包含一些属性，使得开发者的 Swift 类集成了 Interface Builder 里的一些特色功能。和 Objective-C 里一样，你能在 Swift 里面使用 outlets，actions 和实时渲染（live rendering）。</p>

<h3>使用Outlets和Action</h3>

<p>使用 Outlets 和 Action 可以连接源代码和 Interface Builder 的 UI 对象。在Swift里面使用 Outlets 和 Action，需要在属性和方法声明前插入<code>@IBOutlet</code>或者<code>@IBAction</code>关键字。声明一个 Outlet 集合同样是用<code>@IBOutlet</code>属性，即为类型指定一个数组。</p>

<p>当开发者在 Swift 里面声明了一个 Outlet 时，Swift 编译器会自动将该类型转换为弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional（Objective-C 里面对应指针类型）数据类型，并为它分配一个初始化的空值<code>nil</code>。实际上，编译器使用<code>@IBOutlet weak var name: Type! = nil</code>来代替 <code>@IBOutlet var name: Type</code>。编译器将该类型转换成了弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional 类型，因此开发者就不需要在构造器中为该类型分配一个初始值了。当开发者从故事板（storyboard）或者<code>xib</code>文件里面初始化对象 class 后，定义好的 Outlet 和这些对象连接在一起了，所以，这些 Outlet 是隐式的，未包装的。由于创建的 outlets 一般都是弱关系，因此默认 outlets 是弱类型。</p>

<p>例如，下面的 Swift 代码声明了一个拥有 Outlet、Outlet 集合和 Action 的类：</p>

<pre><code class="swift">
class MyViewController: UIViewController {

    @IBOutlet var button: UIButton

    @IBOutlet var textFields: UITextField[]

    @IBAction func buttonTapped(AnyObject) {
        println("button tapped!")
    }
}
</code></pre>

<p>在<code>buttonTapped</code>方法中，消息发送者的信息没有被使用，因此可以省略该方法的参数名。</p>

<h4>实时渲染（live rendering）</h4>

<p>开发者可以在 Interface Builder 中用<code>@IBDesignable</code>和<code>@IBInspectable</code>来创建生动、可交互的自定义视图（view）。开发者继承<code>UIView</code>或者<code>NSView</code>来自定义一个视图（view）时，可以在类声明前添加<code>@IBDesignable</code>属性。当你在 Interface Builder 里添加了自定义的视图后（在监视器面板的自定义视图类中进行设置），Interface Builder 将在画布上渲染你自定义的视图。</p>

<blockquote><p>注意：只能针对框架里对象进行实时渲染</p></blockquote>

<p>你也可以将<code>@IBInspectable</code>属性添加到和用户定义的运行时属性兼容的类型属性里。这样，当开发者将自定义的视图添加到 Interface Builder 里后，就可以在监视器面板中编辑这些属性。</p>

<pre><code class="swift">@IBDesignable

class MyCustomView: UIView {
    @IBInspectable var textColor: UIColor
    @IBInspectable var iconHeight: CGFloat
    /* ... */
}
</code></pre>

<p><a name="specifying_property_attributes"></a></p>

<h3>指明属性特性</h3>

<p>在 Objective-C 中，属性通常都有一组特性（Attributes）说明来指明该属性的一些附加信息。在 Swift 中，开发者可以通过不同的方法来指明属性的这些特性。</p>

<h4>强类型和弱类型</h4>

<p>Swift 里属性默认都是强类型的。使用<code>weak</code>关键字修饰一个属性，能指明其对象存储时是一个弱引用。该关键字仅能修饰 optional 对象类型。更多的信息，请查阅<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/09Classes%20and%20Structures.md">特性</a>。</p>

<h4>读／写和只读</h4>

<p>在 Swift 中，没有<code>readwrite</code>和<code>readonly</code>特性。当声明一个存储型属性时，使用<code>let</code>修饰其为只读；使用<code>var</code>修饰其为可读／写。当声明一个计算型属性时，为其提供一个 getter 方法，使其成为只读的；提供 getter 方法和 setter 方法，使其成为可读／写的。更多信息，请查阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13">属性</a>。</p>

<h4>拷贝</h4>

<p>在 Swift 中，Objective-C 的<code>copy</code>特性被转换为<code>@NSCopying</code>属性。这一类的属性必须遵守 <code>NSCopying</code>协议。更多信息，请查阅<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/09Classes%20and%20Structures.md">特性</a>。</p>

<p><a name="implementing_core_data_managed_object_subclasses"></a></p>

<h3>实现Core Data Managed Object子类</h3>

<p>Core Data 提供了基本存储和实现<code>NSManagedObject</code>子类的一组属性。在与Core Data 模型中管理对象子类相关的特性或者关系的每个属性定义之前，将<code>@NSmanaged</code>特性加入。与 Objective-C 里面的 <code>@dynamic</code>特性类似，<code>@NSManaged</code>特性告知 Swift 编译器，这个属性的存储和实现将在运行时完成。但是，与<code>@dynamic</code>不同的是，<code>@NSManaged</code>特性仅在 Core Data 支持中可用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与 Cocoa 数据类型共舞]]></title>
    <link href="http://baxiang123.com//blog/Working%20with%20Cocoa%20Data%20Types.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Working with Cocoa Data Types</id>
    <content type="html"><![CDATA[<p>作为对 Objective-C 互用性（互操作性）的一部分，Swift提供快捷高效的方式来处理 Cocoa 数据类型。</p>

<p>Swift 会自动将一些 Objective-C 类型转换为 Swift 类型，以及将 Swift 类型转换为 Objective-C 类型。在 Objective-C 和 Swift 中也有一些具有互用性的数据类型。那些可转换的数据类型或者具有互用性的数据类型被称为<em>bridged</em>数据类型。举个例子，在 Swift 中，您可以将一个<code>Array</code>值传递给一个要求为<code>NSArray</code>对象的方法。你也可以转换一个 bridged 类型和它的副本。当你使用<code>as</code>转换 bridged 类型或者那些由常量和变量所提供的类型时，Swift 会桥接它们的数据类型。</p>

<p>Swift 也提供一种简单便捷的覆盖方法来连接 Foundation 的数据类型，在后面的 Swift 语言中，你能在它的句法中感受到自然和统一。</p>

<!--more-->


<p><a name = "strings"></a></p>

<h3>字符串</h3>

<p>Swift会在<code>String</code>类型和<code>NSString</code>类型中自动转换。这意味着在可以使用<code>NSString</code>对象的地方，您可以使用一个属于 Swift 的<code>String</code>类型代替它，这样做会同时拥有它们数据类型的特点，<code>String</code>类型的插值，基于Swift设计的APIs以及<code>NSString</code>类更广的适用范围。因此，您几乎不必再在你的代码中使用<code>NSString</code>类。事实上，当 Swift 接入 Objective-C APIs 时，它将把所有<code>NSString</code>类型替换为<code>String</code>类型。当您在您的Objective-C代码中使用 Swift 类时，接入的API会将所有<code>String</code>类型替换成<code>NSString</code>类型。</p>

<p>为了允许字符串转换，只需接入 Foundation。举个例子，您在 Swift 的一个字符串中调用了<code>capitalizedString</code>&ndash;一个<code>NSString</code>类的方法，此后 Swift 会自动将<code>String</code>转换为一个<code>NSString</code>对象并调用方法。这个方法甚至会返回一个 Swift 的<code>String</code>类型，因为它在接入的时候被替换了。</p>

<pre><code class="swift">import Foundation
let greeting = "hello, world!"
let capitalizedGreeting = greeting.capitalizedString
// capitalizedGreeting: String = Hello, World!
</code></pre>

<p>如果您确实需要用到一个<code>NSString</code>对象，您可以用一个 Swift 的<code>String</code>值并转换它。<code>String</code>类型总是可以从一个<code>NSString</code>对象转换为一个Swift的<code>String</code>的值，因此，再没有必要去使用一个可选的类型转换器<code>()as?)</code>。您也可以在一个字符串中通过定义常量和变量来创建一个<code>NSString</code>对象。</p>

<pre><code class="swift">import Foundation
let myString: NSString = "123"
if let integerValue = (myString as String).toInt()){
    println("\(myString) is the integer \(integerValue)") 
}
</code></pre>

<h4>本地化</h4>

<p>在Objective-C中，常用<code>NSLocalizedString</code>类的宏来定位一个字符串。这集合的宏包括<code>NSLocalizedStringFromTableInBundle</code>和<code>NSLocalizedStringWithDefaultValue</code>。而在Swift中，只用一个函数就可以实现跟整个<code>NSLocalizedString</code>集一样的功能，即<code>NSLocalizedString(key:tableName:bundle:value:comment:)</code>。这个<code>NSLocalizedString</code>函数分别为<code>tableName</code>，<code>bundle</code>和<code>value</code>参数提供了一个默认值。你可以用它来替换宏。</p>

<p><a name = "numbers"></a></p>

<h3>数字</h3>

<p>Swift会自动将已确定的数字类型<code>Int</code>和<code>Float</code>转换为<code>NSNumber</code>。这样的转换允许你基于其中一种类型创建一个<code>NSNumber</code>：</p>

<pre><code>let n = 42
let m: NSNumber = n
</code></pre>

<p>你也能传递一个<code>Int</code>类型的值，比如传递给一个要求为<code>NSNumber</code>类型的参数。同时需要注意的是，<code>NSNumber</code>可以包含多种不同的类型，因此您不能把它传递给单一的一个<code>Int</code>值。</p>

<p>下面所列出的类型都会自动转换为<code>NSNumber</code>：</p>

<ul>
<li><code>Int</code></li>
<li><code>UInt</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Bool</code></li>
</ul>


<p><a name = "collection_classes"></a></p>

<h3>类集合</h3>

<p>Swift 会自动将<code>NSArray</code>和<code>NSDictionary</code>类转换为Swift里等价的类。这意味着你将受益于Swift强大的算法和得天独厚的语法来处理集合&ndash;可互相转换的 Foundation 和 Swift 集合类型。</p>

<h4>数组</h4>

<p>Swift 会在<code>Array</code>类型和<code>NSArray</code>类型中自动转换。当你从一个 Swift 数组转换到一个<code>NSArray</code>对象，转换后的数组是一个<code>AnyObject[]</code>类型的数组。如果某个对象是 Objective-C 或者 Swift 类的实例，或者这个对象可以转换成另一种类型，那么这个对象则属于<code>AnyObject</code>类型的对象。你可以将任一<code>NSArray</code>对象转换成一个 Swift 数组，因为所有 Objective-C 的对象都是<code>AnyObject</code>类型的。正因如此，Swift 的编译器会在接入 Objective-C APIs 的时候将<code>NSArray</code>类替换成<code>AnyObject[]</code>。</p>

<p>当你将一个<code>NSArray</code>对象转换成一个 Swift 数组后，你也可以将数组强制类型转换成一个特定的类型。与从<code>NSArray</code>类转换到<code>AnyObject[]</code>不同的是，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功。由于直到运行时编译器才知道<code>AnyObject</code>的对象能否被强制转换为特定的类型，因此，从<code>AnyObject[]</code>转换为<code>SomeType[]</code>会返回一个 optional 的值。举个例子，如果你知道一个Swift数组只包含<code>UIView</code>类的实例(或者一个<code>UIView</code>类的子类)，你可以将<code>AnyObject</code>类型的数组元素强制转换为<code>UIView</code>对象。如果Swift数组中的元素在运行时不是<code>UIView</code>类型的对象，那么转换则会返回<code>nil</code>。</p>

<pre><code class="swift">let swiftyArray = foundationArray as AnyObject[]
if let downcastedSwiftArray = swiftArray as? UIView[] {
    // downcastedSwiftArray contains only UIView objects
}
</code></pre>

<p>你也可以在for循环中将NSArray对象定向地强制转换为特定类型的Swift数组:</p>

<pre><code class="swift">for aView: UIView! in foundationArray {
     // aView is of type UIView
}
</code></pre>

<blockquote><p>注意：这种转换是强制转换，如果转换不成功则会在运行时产生错误信息。</p></blockquote>

<p>当你从 Swift 数组转换为<code>NSArray</code>对象时，Swift 数组里的元素必须是属于<code>AnyObject</code>的。例如，一个<code>Int[]</code>类型的 Swift 数组包含<code>Int</code>结构的元素。<code>Int</code>类型并不是一个类的实例，但由于<code>Int</code>类型转换成了<code>NSNumber</code>类，<code>Int</code>类型属于<code>AnyObject</code>类型的。因此，你可以将一个<code>Int[]</code>类型的Swift数组转换为<code>NSArray</code>对象。如果 Swift 数组里的一个元素不属于<code>AnyObject</code>类型，那么在运行时就会产生错误。</p>

<p>你也可以从 Swift 数组中创建一个<code>NSArray</code>对象。当你将一个常量或变量定义为一个<code>NSArray</code>对象并分配一个数组给它作为实例变量时，Swift 将会创建 <code>NSArray</code>对象，而不是 Swift 数组。</p>

<pre><code class="swift">let schoolSupplies: NSArray = ["Pencil", "Eraser", "Notebkko"]
// schoolSupplies is an NSArray object containing NSString objects
</code></pre>

<p>上面的例子中，Swift 数组包含包含三个<code>String</code>字符串。由于从<code>String</code>类型转换为<code>NSString</code>类，数组字面量被转换成一个<code>NSArray</code>对象，并成功分配给<code>schoolSupplies</code>变量。</p>

<p>当您在 Objective-C 代码中使用 Swift 类或者协议时，接入的API会将全部所有类型的Swift数组代替为<code>NSArray</code>。若您将一个<code>NSArray</code>对象传递给Swift的API并要求数组元素为一个新的类型，运行时就会产生错误。如果 Swift API 返回一个不能被转换为<code>NSArray</code>类型的 Swift 数组，错误也会随之产生。</p>

<h4>字典</h4>

<p>敬请期待</p>

<p><a name = "foundation_data_types"></a></p>

<h3>Foundation数据类型</h3>

<p>Swift 也提供一种简单便捷的覆盖方法来连接定义在 Foundation 框架中的数据类型。在<code>NSSize</code>和<code>NSPoint</code>中使用覆盖方法，在剩下的 Swift 语言中，你能在它的句法中感受到自然和统一。比如，你可以使用如下语法创建一个<code>NSSize</code>类型的结构:</p>

<pre><code class="swift">let size = NSSize(width: 20, height: 40)
</code></pre>

<p>覆盖方法也允许你以一种自然的方式调用 Foundation 的结构函数。</p>

<pre><code class="swift">let rect = NSRect(x: 50, y: 50, width: 100, height: 100)
let width = rect.width    // equivalent of NSWidth(rect)
let maxX = rect.maxY      // equivalent of NSMaxY(rect)
</code></pre>

<p>Swift可以将<code>NSUInteger</code>和<code>NSInteger</code>转换为<code>Int</code>类型。这些类型都会在 Foundation APIs 中变为<code>Int</code>类型。在 Swift 中<code>Int</code>常被尽可能地用以连贯性，同时当你要求一个无符号整数类型时，<code>UInt</code>类型总是可使用的。</p>

<p><a name = "foundation_functions"></a></p>

<h3>Foundation函数</h3>

<p>在 Swift 中，<code>NSLog</code>可在系统控制台输出信息。您可以像在 Objective-C 中使用过的语法格式那样使用此函数。</p>

<pre><code class="swift">NSLog("%.7f", pi)         // Logs "3.1415927" to the console
</code></pre>

<p>同时，Swift 也提供像<code>print</code>和<code>println</code>那样的输出函数。多归于 Swift 的字符插值机制才让这些函数简单，粗暴，多效。这些函数不会在系统控制台输出信息，但在需要调用的时候却是可用的。</p>

<p>Swift 中不再存在<code>NSAssert</code>函数，取而代之的是<code>assert</code>函数。</p>

<p><a name = "core_foundation"></a></p>

<h3>Core Foundation</h3>

<p>Swift中的 Core Foundation 类型是一个成熟的类。当出现内存管理注释时，Swift 会自动地管理 Core Foundation 对象的内存，这其中包括你实例化了的 Core Foundation 对象。在 Swift 中，你可以自由变换 Fundation 和 Core Foundation 类型。如果你想先转换为桥接 Foundation 类型时，你也可以桥接一些 toll-free bridged Core Foundation 类型到 Swift 标准库类型。</p>

<h4>重定义类型</h4>

<p>当 Swift 导入 Core Foundation 类型时，编译器会重映射导入的类型名字。编译器会从每个类型名字的末端移除 <em>Ref</em>，这是因为所有的 Swift 类都属于引用类型，因此后缀是多余的。</p>

<p>Core Foundation 中的<code>CFTypeRef</code>类型会对<code>Anyobject</code>类型重映射。所以你以前使用的<code>CFTypeRef</code>，现在该换成<code>AnyObject</code>了。</p>

<h4>内存管理对象</h4>

<p>在 Swift 中，从 annotated APIs 返回的 Core Foundation 对象能够自动进行内存管理&ndash;你不再需要调用自身的<code>CFRetain</code>，<code>CFRelease</code>，或者<code>CFAutorelease</code>函数。如果你从自身的C函数和 Objective-C 方法中返回一个 Core Foundation 对象，你需要用<code>CF_RETURNS_RETAINED</code>或者<code>CF_RETURNS_NOT_RETAINED</code>注释这个对象。当 Swift 代码中包含这些 APIs 时，编译器会在编译时自动调用内存管理。如果你只调用那些不会间接返回 Core Foundation 对象的 annotated APIs，那么现在你可以跳过本节的剩余部分了。否则，下面我们继续学习非托管的 Core Foundation 对象。</p>

<h4>非托管对象</h4>

<p>当 Swift 导入 unannotated 的APIs时，编译器将不会自动地对返回的 Core Foundation 对象进行内存管理托管。Swift 将这些返回的 Core Foundation 对象封闭在一个<code>Unmanaged&lt;T&gt;</code>结构中。那些间接返回 Core Foundation 的对象也是非托管的。举个例子，这里有一个 unannotated 的 C 函数:</p>

<pre><code class="swift">CFStringRef StringByAddingTwoStrings(CFStringRef string1, CFStringRef string2)
</code></pre>

<p>这里说明了Swift是怎么导入的:</p>

<pre><code class="swift">func StringByAddingTwoStrings(CFString!, CFString!) -&gt; Unmanaged&lt;CFString&gt;!
</code></pre>

<p>假设您从 unannotated APIs 接收了非托管的对象，在使用它之前，你必须将它转换为能够内存管理的对象。在这方面，Swift 可以帮你进行内存管理而不用自己动手。同时，<code>Unmanaged&lt;T&gt;</code>结构也提供了两个方法来把一个非托管对象转换为一个可内存管理的对象&ndash;<code>takeUnretainedValue()</code>方法和<code>takeRetainedValue()</code>方法。这两个方法会返回原始的，非封闭的对象类型。您可以根据您实际调用的APIs返回的unretained或retained的对象，来选择哪一方法更合适。</p>

<p>比如，假设这里有一个 C 函数，这个函数在返回值前不会释放<code>CFString</code>对象。在使用这个对象前，您使用<code>takeUnretainedValue()</code>函数，以将它转换为一个能够内存管理托管的对象。</p>

<pre><code class="swift">let memoryManagedResult = StringByAddingTwoStrings(str1, str2).takeUnretainedValue()
// memoryManagedResult is a memory managed CFString
</code></pre>

<p>您也可以在一个非托管的对象中使用<code>retain()</code>，<code>release()</code>和<code>autorelease()</code>方法，但是这种做法并不值得推荐。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在同个工程中使用 Swift 和 Objective-C]]></title>
    <link href="http://baxiang123.com//blog/SwiftAndObjectc.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/SwiftAndObjectc</id>
    <content type="html"><![CDATA[<p>Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 <code>mix and match</code> 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。</p>

<h3>Mix and Match 概述</h3>

<p>Objective-C 和 Swift 文件可以在一个工程中并存，不管这个工程原本是基于 Objective-C 还是 Swift。你可以直接往现有工程中简单地添加另一种语言的源文件。这种自然的工作流使得创建混合语言的应用或框架 target，与用单独一种语言时一样简单。</p>

<!-- more -->


<p>混合语言的工作流程只有一点点区别，这取决于你是在写应用还是写框架。下面描述了普通的用两种语言在一个 target 中导入模型的情况，后续章节会有更多细节。</p>

<p><img src="https://raw.githubusercontent.com/haolloyin/Welcome-to-Swift/translate/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/DAG_2x.png?raw=true" alt="DAG_2x.png" /></p>

<p><a name="importing_code_from_within_the_same_app_target"></a></p>

<h3>在同个应用的 target 中导入</h3>

<p>如果你在写混合语言的应用，可能需要用 Swift 代码访问 Objective-C 代码，或者反之。下面的流程描述了在非框架 target 中的应用。</p>

<h4>将 Objective-C 导入 Swift</h4>

<p>在一个应用的 target 中导入一些 Objective-C 文件供 Swift 代码使用时，你需要依赖于 Objective-C 的桥接头文件（<code>bridging header</code>）来暴露给 Swift。当你添加 Swift 文件到现有的 Objective-C 应用（或反之）时，Xcode 会自动创建这些头文件。</p>

<p><img src="https://raw.githubusercontent.com/haolloyin/Welcome-to-Swift/translate/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/bridgingheader_2x.png?raw=true" alt="bridgingheader_2x.png" /></p>

<p>如果你同意，Xcode 会在源文件创建的同时生成头文件，并用 product 的模块名加上 <code>-Bridging-Header.h</code> 命名。关于 product 的模块名，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85">Naming Your Product Module</a>。</p>

<p>你应该编辑这个头文件来对 Swift 暴露出 Objective-C 代码。</p>

<h5>在同一 target 中将 Objective-C 代码导入到 Swift 中</h5>

<ol>
<li>在 Objective-C 桥接头文件中，import 任何你想暴露给 Swift 的头文件，例如：</li>
</ol>


<pre><code class="objective-c">// OBJECTIVE-C

#import "XYZCustomCell.h"
#import "XYZCustomView.h"
#import "XYZCustomViewController.h"
</code></pre>

<ol>
<li>确保在 <code>Build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
</ol>


<p>这个路径应该是你工程的相对路径，类似 <code>Info.plist</code> 在 <code>Build Settings</code> 中指定的路径。在大多数情况下，你不需要修改这个设置。</p>

<p>在这个桥接头文件中列出的所有 public 的 Objective-C 头文件都会对 Swift 可见。之后当前 target 的所有 Swift 文件都可以使用这些头文件中的方法，不需要任何 import 语句。用 Swift 语法使用这些 Objective-C 代码，就像使用系统自带的 Swift 类一样。</p>

<pre><code class="swift">// SWIFT

let myCell = XYZCustomCell()
myCell.subtitle = "A custom cell"
</code></pre>

<h4>将 Swift 导入 Objective-C</h4>

<p>向 Objective-C 中导入Swift 代码时，你依赖 Xcode 生成的头文件来向 Objective-C 暴露 Swift 代码。这是自动生成 Objective-C 头文件，它包含了你的 target 中所有 Swift 代码中定义的接口。可以把这个 Objective-C 头文件看作 Swift 代码的 <code>umbrella header</code>。它以 product 模块名加 <code>-Swift.h</code> 来命名。关于 product 的模块名，详见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85">Naming Your Product Module</a>。</p>

<p>你不需要做任何事情来生成这个头文件，只需要将它导入到你的 Objective-C 代码来使用它。注意这个头文件中的 Swift 接口包含了它所使用到的所有 Objective-C 类型。如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</p>

<h5>在同一 target 中将 Swift 代码导入到 Objective-C 中</h5>

<ul>
<li>在相同 target 的 Objective-C .m 源文件中，用下面的语法来导入Swift 代码：</li>
</ul>


<pre><code class="objective-c">// OBJECTIVE-C

#import "ProductModuleName-Swift.h"
</code></pre>

<p>target 中任何 Swift 文件将会对 Objective-C .m 源文件可见，包括这个 import 语句。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84">Using Swift from Objective-C</a>。</p>

<table>
<thead>
<tr>
<th>              </th>
<th style="text-align:center;"> 导入到 Swift </th>
<th style="text-align:center;"> 导入到 Objective-C  </th>
</tr>
</thead>
<tbody>
<tr>
<td> Swift 代码    </td>
<td style="text-align:center;"> 不需要import语句  </td>
<td style="text-align:center;"> #import &ldquo;ProductModuleName-Swift.h”  </td>
</tr>
<tr>
<td> Objective-C 代码     </td>
<td style="text-align:center;"> 不需要import语句；需要 Objective-C bridging头文件</td>
<td style="text-align:center;"> #import &ldquo;Header.h&rdquo;     </td>
</tr>
</tbody>
</table>


<p><a name="importing_code_from_within_the_same_framework_target"></a></p>

<h3>在同个 Framework 的 target 中导入</h3>

<p>如果你在写一个混合语言的框架，可能会从 Swift 代码访问 Objective-C 代码，或者反之。</p>

<h4>将 Objective-C 导入 Swift</h4>

<p>要将一些 Objective-C 文件导入到同个框架 target 的 Swift 代码中去，你需要将这些文件导入到 Objective-C 的 <code>umbrella header</code> 来供框架使用。</p>

<h6>在同一 framework 中将 Objective-C 代码导入到 Swift 中</h6>

<p>确保将框架 target 的 <code>Build Settings &gt; Packaging &gt; Defines Module</code> 设置为 <code>Yes</code>。然后在你的 <code>umbrella header</code> 头文件中导入你想暴露给 Swift 访问的 Objective-C 头文件，例如：</p>

<pre><code class="objective-c">// OBJECTIVE-C
#import &lt;XYZ/XYZCustomCell.h&gt;
#import &lt;XYZ/XYZCustomView.h&gt;
#import &lt;XYZ/XYZCustomViewController.h&gt;
</code></pre>

<p>Swift 将会看到所有你在 <code>umbrella header</code> 中公开暴露出来的头文件，框架 target 中的所有 Swift 文件都可以访问你 Objective-C 文件的内容，不需要任何 import 语句。</p>

<pre><code class="swift">// SWIFT

let myCell = XYZCustomCell()
myCell.subtitle = "A custom cell"
</code></pre>

<h4>将 Swift 导入 Objective-C</h4>

<p>要将一些 Swift 文件导入到同个框架的 target 的 Objective-C 代码去，你不需要导入任何东西到 <code>umbrella header</code> 文件，而是将 Xcode 为你的 Swift 代码自动生成的头文件导入到你的 Obj .m 源文件去，以便在 Objective-C 代码中访问 Swift 代码。</p>

<h6>在同一 framework 中将 Swift 代码导入到 Objective-C 中</h6>

<p>确保将框架 target 的 <code>Build Settings &gt; Packaging</code> 中的 <code>Defines Module</code> 设置为 <code>Yes</code>。用下面的语法将 Swift 代码导入到同个框架 target 下的 Objective-C .m 源文件去。</p>

<pre><code class="objective-c">// OBJECTIVE-C
#import &lt;ProductName/ProductModuleName-Swift.h&gt;
</code></pre>

<p>这个 import 语句所包含的 Swift 文件都可以被同个框架 target 下的 Objective-C .m 源文件访问。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84">Using Swift from Objective-C</a>。</p>

<table>
<thead>
<tr>
<th>              </th>
<th style="text-align:center;"> 导入到 Swift </th>
<th style="text-align:center;"> 导入到 Objective-C  </th>
</tr>
</thead>
<tbody>
<tr>
<td> Swift 代码    </td>
<td style="text-align:center;"> 不需要import语句  </td>
<td style="text-align:center;"> #import &ldquo;ProductName/ProductModuleName-Swift.h&rdquo;  </td>
</tr>
<tr>
<td> Objective-C 代码     </td>
<td style="text-align:center;"> 不需要import语句；需要 Objective-C umbrella头文件</td>
<td style="text-align:center;"> #import &ldquo;Header.h&rdquo;     </td>
</tr>
</tbody>
</table>


<p><a name="importing_external_frameworks"></a></p>

<h3>导入外部 Framework</h3>

<p>你可以导入外部框架，不管这个框架是纯 Objective-C，纯 Swift，还是混合语言的。import 外部框架的流程都是一样的，不管这个框架是用一种语言写的，还是包含两种语言。当你导入外部框架时，确保 <code>Build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>。</p>

<p>用下面的语法将框架导入到不同 target 的 Swift 文件中：</p>

<pre><code class="swift">// SWIFT

import FrameworkName
</code></pre>

<p>用下面的语法将框架导入到不同 target 的 Objective-C .m 文件中：</p>

<pre><code class="objective-c">// OBJECTIVE-C

@import FrameworkName;
</code></pre>

<table>
<thead>
<tr>
<th>           </th>
<th style="text-align:center;"> 导入到 Swift </th>
<th style="text-align:center;"> 导入到 Objective-C  </th>
</tr>
</thead>
<tbody>
<tr>
<td>任意语言框架 </td>
<td style="text-align:center;"> import FrameworkName </td>
<td style="text-align:center;"> @import FrameworkName; </td>
</tr>
</tbody>
</table>


<p><a name="using_swift_from_objective-c"></a></p>

<h3>在 Objective-C 中使用 Swift</h3>

<p>当你将 Swift 代码导入 Objective-C 文件之后，用普通的 Objective-C 语法使用 Swift 类。</p>

<pre><code class="objective-c">// OBJECTIVE-C

MySwiftClass *swiftObject = [[MySwiftClass alloc] init];
[swiftObject swiftMethod];
</code></pre>

<p>Swift 的类或协议必须用 <code>@Objective-C attribute</code> 来标记，以便在 Objective-C 中可访问。这个 attribute 告诉编译器这个 Swift 代码可以从 Objective-C 代码中访问。如果你的 Swift 类是 Objective-C 类的子类，编译器会自动为你添加 <code>@Objective-C attribute</code>。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_36">Swift Type Compatibility</a>。</p>

<p>你可以访问 Swift 类或协议中用 <code>@Objective-C attribute</code> 标记过东西，只要它和 Objective-C 兼容。不包括以下这些 Swift 独有的特性：</p>

<ul>
<li><p>Generics - 范型</p></li>
<li><p>Tuples - 元组</p></li>
<li><p>Enumerations defined in Swift - Swift 中定义的枚举</p></li>
<li><p>Structures defined in Swift - Swift 中定义的结构体</p></li>
<li><p>Top-level functions defined in Swift - Swift 中定义的顶层函数</p></li>
<li><p>Global variables defined in Swift - Swift 中定义的全局变量</p></li>
<li><p>Typealiases defined in Swift - Swift 中定义的类型别名</p></li>
<li><p>Swift-style variadics  - Swift风格可变参数</p></li>
<li><p>Nested types - 嵌套类型</p></li>
<li><p>Curried functions - 柯里化后的函数</p></li>
</ul>


<p>例如带有范型类型作为参数，或者返回元组的方法不能在 Objective-C 中使用。</p>

<p>为了避免循环引用，不要将 Swift 代码导入到 Objective-C 头文件中。但是你可以在 Objective-C 头文件中前向声明（<code>forward declare</code>）一个 Swift 类来使用它，然而，注意<strong>不能在 Objective-C 中继承一个 Swift 类</strong>。</p>

<h3>在 Objective-C 头文件中引用 Swift 类</h3>

<p>这样前向声明 Swift 类：</p>

<pre><code class="objective-c">// OBJECTIVE-C
// MyObjective-CClass.h

@class MySwiftClass;

@interface MyObjective-CClass : NSObject
- (MySwiftClass *)returnSwiftObject;
/* ... */
@end
</code></pre>

<p><a name="naming_your_product_module"></a></p>

<h3>Product 模块命名</h3>

<p>Xcode 为 Swift 代码生成的头文件的名称，以及 Xcode 创建的 Objective-C 桥接头文件名称，都是从你的 product 模块名生成的。默认你的 product 模块名和 product 名一样。然而，如果你的 product 名有特殊字符（nonalphanumeric，非数字、字母的字符），例如点号，那么它们会被下划线（<code>_</code>）替换之后作为你的 product 模块名。如果 product 名以数字开头，那么第一个数字会用下划线替换掉。</p>

<p>你可以给 product 模块名提供一个自定义的名称，Xcode 会用这个名称来命名桥接的和自动生成的头文件。你只需要在修改在 <code>build setting</code> 中的 <code>Product Module Name</code> 即可。</p>

<p><a name="troubleshooting_tips_and_reminders"></a></p>

<h3>问题解决提示</h3>

<ul>
<li>把 Swift 和 Objective-C 文件看作相同的代码集合，并注意命名冲突；</li>
<li>如果你用框架，确保 <code>Build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>；</li>
<li>如果你使用 Objective-C 桥接头文件，确保在 <code>Build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录；</li>
<li>Xcode 使用你的 product 模块名，而不是 target 名来命名 Objective-C 桥接头文件和为 Swift 自动生成的头文件。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85">Naming Your Product Module</a>；</li>
<li>为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 <code>@Objective-C</code> 标记；</li>
<li>当你将 Swift 导入到 Objective-C 中时，记住 Objective-C 不会将 Swift 独有的特性翻译成 Objective-C 对应的特性。详见列表 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84">Using Swift from Objective-C</a>；</li>
<li>如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件 import 到 Objective-C .m 源文件中来访问 Swift 代码。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与 C 语言交互编程]]></title>
    <link href="http://baxiang123.com//blog/Interacting%20with%20C%20APIs.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Interacting with C APIs</id>
    <content type="html"><![CDATA[<p>作为一种可与 Objective-C 相互调用的语言，Swift 也具有一些与 C 语言的类型和特性，如果你的代码有需要，Swift 也提供了和常见的 C 代码结构混合编程的编程方式。<!--more--></p>

<h3>基本数据类型</h3>

<p>Swift 提供了一些和 C 语言的基本类型如<code>char</code>，<code>int</code>，<code>float</code>，<code>double</code>等价的 Swift 基本数据类型。然而，这些 Swift 的核心基本类型之间并不能隐式的相互转换，如 Int。因此，只有你的代码明确要求它们时再使用这些类型，而 Int 可以在任何你想使用它的时候使用。</p>

<table>
<thead>
<tr>
<th> C 类型 </th>
<th> Swift 类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td> bool </td>
<td> CBool </td>
</tr>
<tr>
<td> char, signed char </td>
<td> CChar </td>
</tr>
<tr>
<td> unsigned char </td>
<td> CUnsignedChar </td>
</tr>
<tr>
<td> short </td>
<td> CShort </td>
</tr>
<tr>
<td> unsigned short </td>
<td> CUnsignedShort </td>
</tr>
<tr>
<td> int </td>
<td> CInt </td>
</tr>
<tr>
<td> unsigned int </td>
<td> CUnsignedInt </td>
</tr>
<tr>
<td> long </td>
<td> CLong </td>
</tr>
<tr>
<td> unsigned long </td>
<td> CUnsignedLong </td>
</tr>
<tr>
<td> long long </td>
<td> CLongLong </td>
</tr>
<tr>
<td> unsigned long long </td>
<td> CUnsignedLongLong </td>
</tr>
<tr>
<td> wchar_t </td>
<td> CWideChar </td>
</tr>
<tr>
<td> char16_t </td>
<td> CChar16 </td>
</tr>
<tr>
<td> char32_t </td>
<td> CChar32 </td>
</tr>
<tr>
<td> float </td>
<td> CFloat </td>
</tr>
<tr>
<td> double </td>
<td> CDouble </td>
</tr>
</tbody>
</table>


<p><a name="enumerations"></a></p>

<h3>枚举</h3>

<p>Swift 引进了用宏<code>NS_ENUM</code>来标记的任何 C 风格的枚举类型。这意味着无论枚举值是在系统框架还是在自定义的代码中定义的，当他们导入到 Swift 时，他们的前缀名称将被截断。例如，看这个 Objective-C 枚举：</p>

<pre><code class="objective-c">//Objective-C
typedef NS_ENUM(NSInteger, UITableViewCellStyle) {
    UITableViewCellStyleDefault,
    UITableViewCellStyleValue1,
    UITableViewCellStyleValue2,
    UITableViewCellStyleSubtitle
};
</code></pre>

<p>在 Swift 中这样来实现：</p>

<pre><code class="swift">//Swift
enum UITableViewCellStyle: Int {
    case Default
    case Value1
    case Value2
    case Subtitle
    }
</code></pre>

<p>当您需要指向一个枚举值时，使用以点（.）开头的枚举名称：</p>

<pre><code class="swift">//Swift
let cellStyle: UITableViewCellStyle = .Default
</code></pre>

<p>Swift 也引进了标有<code>NS_OPTIONS</code>宏选项。而选项的行为类似于引进的枚举，选项还可以支持一些位操作，如 ＆，| 和 〜。在 Objective-C 中，你用一个空的选项设置标示恒为零（0）。在 Swift 中，使用 <code>nil</code>代表没有任何选项。</p>

<p><a name="pointer"></a></p>

<h3>指针</h3>

<p>Swift 尽可能避免让您直接访问指针。然而，当您需要直接操作内存的时候，Swift 也为您提供了多种指针类型。下面的表使用 Type 作为占位符类型名称来表示语法的映射。</p>

<p>对于参数，使用以下映射：</p>

<table>
<thead>
<tr>
<th> C 句法 </th>
<th> Swift 句法 </th>
</tr>
</thead>
<tbody>
<tr>
<td> const void * </td>
<td> CConstVoidPointer </td>
</tr>
<tr>
<td> void * </td>
<td> CMutableVoidPointer </td>
</tr>
<tr>
<td> const Type * </td>
<td> CConstPointer\&lt;Type> </td>
</tr>
<tr>
<td> Type * </td>
<td> CMutablePointer\&lt;Type> </td>
</tr>
</tbody>
</table>


<p>对于返回类型，变量和参数类型的多层次指针，使用以下映射：</p>

<table>
<thead>
<tr>
<th> C 句法 </th>
<th> Swift 句法 </th>
</tr>
</thead>
<tbody>
<tr>
<td> void * </td>
<td> COpaquePointer </td>
</tr>
<tr>
<td> Type * </td>
<td> UnsafePointer\&lt;Type> </td>
</tr>
</tbody>
</table>


<p>对于类（class）类型，使用以下映射：</p>

<table>
<thead>
<tr>
<th> C 句法 </th>
<th> Swift 句法 </th>
</tr>
</thead>
<tbody>
<tr>
<td> Type * const * </td>
<td> CConstPointer\&lt;Type> </td>
</tr>
<tr>
<td> Type * __strong * </td>
<td> CMutablePointer\&lt;Type> </td>
</tr>
<tr>
<td> Type ** </td>
<td> AutoreleasingUnsafePointer\&lt;Type> </td>
</tr>
</tbody>
</table>


<h4>C 可变指针</h4>

<p>当一个函数被声明为接受<code>CMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>

<ul>
<li><code>nil</code>，作为空指针传入</li>
<li>一个<code>CMutablePointer&lt;Type&gt;</code>类型的值</li>
<li>一个操作数是 <code>Type</code> 类型的左值的输入输出表达式，作为这个左值的内存地址传入</li>
<li>一个输入输出 <code>Type[]</code> 值，作为一个数组的起始指针传入，并且它的生命周期将在这个调用期间被延长</li>
</ul>


<p>如果您像这样声明了一个函数：</p>

<pre><code class="swift">//Swift
func takesAMutablePointer(x: CMutablePointer&lt;Float&gt;) { /*...*/ }
</code></pre>

<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<pre><code class="swift">//Swift
var x: Float = 0.0
var p: CMutablePointer&lt;Float&gt; = nil
var a: Float[] = [1.0, 2.0, 3.0]

takesAMutablePointer(nil)
takesAMutablePointer(p)
takesAMutablePointer(&amp;x)
takesAMutablePointer(&amp;a)
</code></pre>

<p>当函数被声明使用一个<code>CMutableVoidPointer</code>参数，那么这个函数接受任何和<code>CMutablePointer&lt;Type&gt;</code>相似类型的<code>Type</code>操作数。</p>

<p>如果您这样定义了一个函数：</p>

<pre><code class="swift">//Swift
func takesAMutableVoidPointer(x: CMutableVoidPointer) { /* ... */ }
</code></pre>

<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<pre><code class="swift">//Swift
var x: Float = 0.0, y: Int = 0
var p: CMutablePointer&lt;Float&gt; = nil, q: CMutablePointer&lt;Int&gt; = nil
var a: Float[] = [1.0, 2.0, 3.0], b: Int[] = [1, 2, 3]

takesAMutableVoidPointer(nil)
takesAMutableVoidPointer(p)
takesAMutableVoidPointer(q)
takesAMutableVoidPointer(&amp;x)
takesAMutableVoidPointer(&amp;y)
takesAMutableVoidPointer(&amp;a)
takesAMutableVoidPointer(&amp;b)
</code></pre>

<h4>C 常指针</h4>

<p>当一个函数被声明为接受<code>CConstPointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>

<ul>
<li><code>nil</code>，作为空指针传入</li>
<li>一个<code>CMutablePointer&lt;Type&gt;</code>, <code>CMutableVoidPointer</code>, <code>CConstPointer&lt;Type&gt;</code>, <code>CConstVoidPointer</code>,  或者在必要情况下转换成<code>CConstPointer&lt;Type&gt;</code>的<code>AutoreleasingUnsafePointer&lt;Type&gt;</code>值</li>
<li>一个操作数是 <code>Type</code> 类型的左值的输入输出表达式，作为这个左值的内存地址传入</li>
<li>一个<code>Type[]</code>数组值，作为一个数组的起始指针传入，并且它的生命周期将在这个调用期间被延长</li>
</ul>


<p>如果您这样定义了一个函数：</p>

<pre><code class="swift">//Swift
func takesAConstPointer(x: CConstPointer&lt;Float&gt;) { /*...*/ }
</code></pre>

<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<pre><code class="swift">//Swift
var x: Float = 0.0
var p: CConstPointer&lt;Float&gt; = nil

takesAConstPointer(nil)
takesAConstPointer(p)
takesAConstPointer(&amp;x)
takesAConstPointer([1.0, 2.0, 3.0])
</code></pre>

<p>当函数被声明使用一个<code>CConstVoidPointer</code>参数，那么这个函数接受任何和<code>CConstPointer&lt;Type&gt;</code> 相似类型的<code>Type</code>操作数。
￼
如果您这样定义了一个函数：</p>

<pre><code class="swift">//Swift
￼￼￼￼func takesAConstVoidPointer(x: CConstVoidPointer) { /* ... */ }
</code></pre>

<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<pre><code class="swift">//Swift
var x: Float = 0.0, y: Int = 0
var p: CConstPointer&lt;Float&gt; = nil, q: CConstPointer&lt;Int&gt; = nil 

takesAConstVoidPointer(nil)
takesAConstVoidPointer(p)
takesAConstVoidPointer(q)
takesAConstVoidPointer(&amp;x)
takesAConstVoidPointer(&amp;y)
takesAConstVoidPointer([1.0, 2.0, 3.0]) 
takesAConstVoidPointer([1, 2, 3])
</code></pre>

<h4>自动释放不安全指针</h4>

<p>当一个函数被声明为接受<code>AutoreleasingUnsafePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>

<ul>
<li><code>nil</code>，作为空指针传入</li>
<li>一个<code>AutoreleasingUnsafePointer&lt;Type&gt;</code>值</li>
<li>其操作数是原始的，复制到一个临时的没有所有者的缓冲区的一个输入输出表达式，该缓冲区的地址传递给调用，并返回时，缓冲区中的值加载，保存，并重新分配到操作数。</li>
</ul>


<p><strong>注意：这个列表没有包含数组。</strong></p>

<p>如果您这样定义了一个函数：</p>

<pre><code class="swift">//Swift
func takesAnAutoreleasingPointer(x: AutoreleasingUnsafePointer&lt;NSDate?&gt;) { /* ... */ }
</code></pre>

<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<pre><code class="swift">//Swift
var x: NSDate? = nil
var p: AutoreleasingUnsafePointer&lt;NSDate?&gt; = nil
￼￼￼￼￼
takesAnAutoreleasingPointer(nil)
takesAnAutoreleasingPointer(p)
takesAnAutoreleasingPointer(&amp;x)
</code></pre>

<p><strong>注意：C 语言函数指针没有被 Swift 引进。</strong></p>

<p><a name="global_constants"></a></p>

<h3>全局常量</h3>

<p>在 C 和 Objective-C 语言源文件中定义的全局常量会自动地被 Swift 编译引进并做为 Swift 的全局常量。</p>

<p><a name="preprocessor_directives"></a></p>

<h3>预处理指令</h3>

<p>Swift 编译器不包含预处理器。取而代之的是，它充分利用了编译时属性，生成配置，和语言特性来完成相同的功能。因此，Swift 没有引进预处理指令。</p>

<h4>简单宏</h4>

<p>在 C 和 Objective-C，您通常使用的#define指令定义的一个宏常数，在 Swift，您可以使用全局常量来代替。例如：一个全局定义<code>#define FADE_ANIMATION_DURATION 0.35</code>，在 Swift 可以使用<code>let FADE_ANIMATION_DURATION = 0.35</code>来更好的表述。由于简单的用于定义常量的宏会被直接被映射成 Swift 全局量，Swift 编译器会自动引进在 C 或 Objective-C 源文件中定义的简单宏。</p>

<h4>复杂宏</h4>

<p>在 C 和 Objective-C 中使用的复杂宏在 Swift 中并没有与之对应的定义。复杂宏是那些不用来定义常量的宏，而是用来定义包含小括号（），函数的宏。您在 C 和 Objective-C 使用复杂的宏是用来避免类型检查的限制和相同代码的重复劳动。然而，宏也会产生Bug和重构的困难。在 Swift 中你可以直接使用函数和泛型来达到同样的效果。因此，在 C 和 Objective-C 源文件中定义的复杂宏在 Swift 是不能使用的。</p>

<h4>编译配置</h4>

<p>Swift 代码和 Objective-C 代码以不同的方式进行条件编译。Swift 代码可以根据生成配置的评价配进行有条件的编译。生成配置包括 <code>true</code> 和 <code>false</code> 字面值，命令行标志，和下表中的平台测试函数。您可以使用-D \&lt;＃Flag＃>指定命令行标志。</p>

<table>
<thead>
<tr>
<th> 函数 </th>
<th> 有效参数 </th>
</tr>
</thead>
<tbody>
<tr>
<td> os() </td>
<td> OSX, iOS </td>
</tr>
<tr>
<td> arch() </td>
<td> x86_64, arm, arm64, i386 </td>
</tr>
</tbody>
</table>


<blockquote><p>注意</p>

<p>arch(arm) 的生成配置不会为64位 ARM 设备返回<code>true</code>，当代码运行在为32位的 iOS 模拟器器时，arch(i386) 的生成配置返回<code>true</code>。</p></blockquote>

<p>一个简单的条件编译需要以下代码格式：</p>

<pre><code class="swift">#if build configuration
    statements
#else
    statements
#endif
</code></pre>

<p>一个由零个或多个有效的 Swift 语句声明的<code>statements</code>，可以包括表达式，语句和控制流语句。您可以添加额外的构建配置要求，条件编译说明用 &amp;&amp; 和 | | 操作符以及 ！ 操作符，添加条件控制块用 ＃elseif：</p>

<pre><code class="swift">#if build configuration &amp;&amp; !build configuration
    statements
#elseif build configuration
    statements
#else
    statements
#endif 
</code></pre>

<p>与 C 语言编译器的条件编译相反，Swift 条件编译语句必须完全是自包含和语法有效的代码块。这是因为 Swift 代码即使没有被编译，也要全部进行语法检查。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift泛型]]></title>
    <link href="http://baxiang123.com//blog/Swif%E6%B3%9B%E5%9E%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swif泛型</id>
    <content type="html"><![CDATA[<p><em>泛型代码</em>可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>


<p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个<code>Int</code>数组，也可创建一个<code>String</code>数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。</p>


<!-- more -->


<p><a name="the_problem_that_generics_solve"></a></p>


<h2 id="-">泛型所解决的问题</h2>


<p>这里是一个标准的，非泛型函数<code>swapTwoInts</code>,用来交换两个Int值：</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>这个函数使用写入读出（in-out）参数来交换<code>a</code>和<code>b</code>的值，请参考[写入读出参数][1]。</p></p>

<p><code>swapTwoInts</code>函数可以交换<code>b</code>的原始值到<code>a</code>，也可以交换a的原始值到<code>b</code>，你可以调用这个函数交换两个<code>Int</code>变量值：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 输出 "someInt is now 107, and anotherInt is now 3"
</code></pre>


<p><code>swapTwoInts</code>函数是非常有用的，但是它只能交换<code>Int</code>值，如果你想要交换两个<code>String</code>或者<code>Double</code>，就不得不写更多的函数，如 <code>swapTwoStrings</code>和<code>swapTwoDoublesfunctions</code>，如同如下所示：</p>


<pre><code>func swapTwoStrings(inout a: String, inout b: String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(inout a: Double, inout b: Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p>你可能注意到 <code>swapTwoInts</code>、 <code>swapTwoStrings</code>和<code>swapTwoDoubles</code>函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是<code>Int</code>、<code>String</code>和<code>Double</code>。</p>


<p>但实际应用中通常需要一个用处更强大并且尽可能的考虑到更多的灵活性单个函数，可以用来交换两个任何类型值，很幸运的是，泛型代码帮你解决了这种问题。（一个这种泛型函数后面已经定义好了。）</p>


<blockquote>
<p>注意：
在所有三个函数中，<code>a</code>和<code>b</code>的类型是一样的。如果<code>a</code>和<code>b</code>不是相同的类型，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个<code>String</code>类型的变量和一个<code>Double</code>类型的变量互相交换值。如果一定要做，Swift 将报编译错误。</p>
</blockquote>


<p><a name="generic_functions"></a></p>


<h2 id="-">泛型函数</h2>


<p><code>泛型函数</code>可以工作于任何类型，这里是一个上面<code>swapTwoInts</code>函数的泛型版本，用于交换两个值：</p>


<pre><code>func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p><code>swapTwoValues</code>函数主体和<code>swapTwoInts</code>函数是一样的，它只在第一行稍微有那么一点点不同于<code>swapTwoInts</code>，如下所示：</p>


<pre><code>func swapTwoInts(inout a: Int, inout b: Int)
func swapTwoValues&lt;T&gt;(inout a: T, inout b: T)
</code></pre>


<p>这个函数的泛型版本使用了占位类型名字（通常此情况下用字母<code>T</code>来表示）来代替实际类型名（如<code>In</code>、<code>String</code>或<code>Doubl</code>）。占位类型名没有提示<code>T</code>必须是什么类型，但是它提示了<code>a</code>和<code>b</code>必须是同一类型<code>T</code>，而不管<code>T</code>表示什么类型。只有<code>swapTwoValues</code>函数在每次调用时所传入的实际类型才能决定<code>T</code>所代表的类型。</p>


<p>另外一个不同之处在于这个泛型函数名后面跟着的展位类型名字（T）是用尖括号括起来的（<t>）。这个尖括号告诉 Swift 那个<code>T</code>是<code>swapTwoValues</code>函数所定义的一个类型。因为<code>T</code>是一个占位命名类型，Swift 不会去查找命名为T的实际类型。</t></p>


<p><code>swapTwoValues</code>函数除了要求传入的两个任何类型值是同一类型外，也可以作为<code>swapTwoInts</code>函数被调用。每次<code>swapTwoValues</code>被调用，T所代表的类型值都会传给函数。</p>


<p>在下面的两个例子中,<code>T</code>分别代表<code>Int</code>和<code>String</code>：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;someInt, &amp;anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&amp;someString, &amp;anotherString)
// someString is now "world", and anotherString is now "hello"
</code></pre>


<blockquote>
<p>注意
上面定义的函数<code>swapTwoValues</code>是受<code>swap</code>函数启发而实现的。<code>swap</code>函数存在于 Swift 标准库，并可以在其它类中任意使用。如果你在自己代码中需要类似<code>swapTwoValues</code>函数的功能，你可以使用已存在的交换函数<code>swap</code>函数。</p>
</blockquote>


<p><a name="type_parameters"></a></p>


<h2 id="-">类型参数</h2>


<p>在上面的<code>swapTwoValues</code>例子中，占位类型<code>T</code>是一种类型参数的示例。类型参数指定并命名为一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（如<t>）。</t></p>


<p>一旦一个类型参数被指定，那么其可以被使用来定义一个函数的参数类型（如<code>swapTwoValues</code>函数中的参数<code>a</code>和<code>b</code>），或作为一个函数返回类型，或用作函数主体中的注释类型。在这种情况下，被类型参数所代表的占位类型不管函数任何时候被调用，都会被实际类型所替换（在上面<code>swapTwoValues</code>例子中，当函数第一次被调用时，<code>T</code>被<code>Int</code>替换，第二次调用时，被<code>String</code>替换。）。</p>


<p>你可支持多个类型参数，命名在尖括号中，用逗号分开。</p>


<p><a name="naming_type_parameters"></a></p>


<h2 id="-">命名类型参数</h2>


<p>在简单的情况下，泛型函数或泛型类型需要指定一个占位类型（如上面的<code>swapTwoValues</code>泛型函数，或一个存储单一类型的泛型集，如数组），通常用一单个字母<code>T</code>来命名类型参数。不过，你可以使用任何有效的标识符来作为类型参数名。</p>


<p>如果你使用多个参数定义更复杂的泛型函数或泛型类型，那么使用更多的描述类型参数是非常有用的。例如，Swift 字典（Dictionary）类型有两个类型参数，一个是键，另外一个是值。如果你自己写字典，你或许会定义这两个类型参数为<code>KeyType</code>和<code>ValueType</code>，用来记住它们在你的泛型代码中的作用。</p>


<blockquote>
<p>注意
请始终使用大写字母开头的驼峰式命名法（例如<code>T</code>和<code>KeyType</code>）来给类型参数命名，以表明它们是类型的占位符，而非类型值。</p>
</blockquote>


<p><a name="generic_types"></a></p>


<h2 id="-">泛型类型</h2>


<p>通常在泛型函数中，Swift 允许你定义你自己的泛型类型。这些自定义类、结构体和枚举作用于任何类型，如同<code>Array</code>和<code>Dictionary</code>的用法。</p>


<p>这部分向你展示如何写一个泛型集类型&#8211;<code>Stack</code>（栈）。一个栈是一系列值域的集合，和<code>Array</code>（数组）类似，但其是一个比 Swift 的<code>Array</code>类型更多限制的集合。一个数组可以允许其里面任何位置的插入/删除操作，而栈，只允许在集合的末端添加新的项（如同<em>push</em>一个新值进栈）。同样的一个栈也只能从末端移除项（如同<em>pop</em>一个值出栈）。</p>


<blockquote>
<p>注意
栈的概念已被<code>UINavigationController</code>类使用来模拟试图控制器的导航结构。你通过调用<code>UINavigationController</code>的<code>pushViewController:animated:</code>方法来为导航栈添加（add）新的试图控制器；而通过<code>popViewControllerAnimated:</code>的方法来从导航栈中移除（pop）某个试图控制器。每当你需要一个严格的<code>后进先出</code>方式来管理集合，堆栈都是最实用的模型。</p>
</blockquote>


<p>下图展示了一个栈的压栈(push)/出栈(pop)的行为：</p>


<p>![此处输入图片的描述][2]</p>


<ol>
<li>现在有三个值在栈中；</li>
<li>第四个值“pushed”到栈的顶部；</li>
<li>现在有四个值在栈中，最近的那个在顶部；</li>
<li>栈中最顶部的那个项被移除，或称之为“popped”；</li>
<li>移除掉一个值后，现在栈又重新只有三个值。</li>
</ol>


<p>这里展示了如何写一个非泛型版本的栈，<code>Int</code>值型的栈：</p>


<pre><code>struct IntStack {
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
}
</code></pre>


<p>这个结构体在栈中使用一个<code>Array</code>性质的<code>items</code>存储值。<code>Stack</code>提供两个方法：<code>push</code>和<code>pop</code>，从栈中压进一个值和移除一个值。这些方法标记为可变的，因为他们需要修改（或<em>转换</em>）结构体的<code>items</code>数组。</p>


<p>上面所展现的<code>IntStack</code>类型只能用于<code>Int</code>值，不过，其对于定义一个泛型<code>Stack</code>类（可以处理<em>任何</em>类型值的栈）是非常有用的。</p>


<p>这里是一个相同代码的泛型版本：</p>


<pre><code>struct Stack&lt;T&gt; {
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
}
</code></pre>


<p>注意到<code>Stack</code>的泛型版本基本上和非泛型版本相同，但是泛型版本的占位类型参数为T代替了实际<code>Int</code>类型。这种类型参数包含在一对尖括号里（<code>&lt;T&gt;</code>），紧随在结构体名字后面。</p>


<p><code>T</code>定义了一个名为“某种类型T”的节点提供给后来用。这种将来类型可以在结构体的定义里任何地方表示为“T”。在这种情况下，<code>T</code>在如下三个地方被用作节点：</p>


<ul>
<li>创建一个名为<code>items</code>的属性，使用空的T类型值数组对其进行初始化；</li>
<li>指定一个包含一个参数名为<code>item</code>的<code>push</code>方法，该参数必须是T类型；</li>
<li>指定一个<code>pop</code>方法的返回值，该返回值将是一个T类型值。</li>
</ul>


<p>当创建一个新单例并初始化时， 通过用一对紧随在类型名后的尖括号里写出实际指定栈用到类型，创建一个<code>Stack</code>实例，同创建<code>Array</code>和<code>Dictionary</code>一样：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 现在栈已经有4个string了
</code></pre>


<p>下图将展示<code>stackOfStrings</code>如何<code>push</code>这四个值进栈的过程：</p>


<p>![此处输入图片的描述][3]</p>


<p>从栈中<code>pop</code>并移除值&#8221;cuatro&#8221;：</p>


<pre><code>let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to "cuatro", and the stack now contains 3 strings
</code></pre>


<p>下图展示了如何从栈中pop一个值的过程：
![此处输入图片的描述][4]</p>


<p>由于<code>Stack</code>是泛型类型，所以在 Swift 中其可以用来创建任何有效类型的栈，这种方式如同<code>Array</code>和<code>Dictionary</code>。</p>


<p><a name="type_constraints"></a></p>


<h2 id="-">类型约束</h2>


<p><code>swapTwoValues</code>函数和<code>Stack</code>类型可以作用于任何类型，不过，有的时候对使用在泛型函数和泛型类型上的类型强制约束为某种特定类型是非常有用的。类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成。</p>


<p>例如，Swift 的<code>Dictionary</code>类型对作用于其键的类型做了些限制。在[字典][5]的描述中，字典的键类型必须是<em>可哈希</em>，也就是说，必须有一种方法可以使其是唯一的表示。<code>Dictionary</code>之所以需要其键是可哈希是为了以便于其检查其是否包含某个特定键的值。如无此需求，<code>Dictionary</code>即不会告诉是否插入或者替换了某个特定键的值，也不能查找到已经存储在字典里面的给定键值。</p>


<p>这个需求强制加上一个类型约束作用于<code>Dictionary</code>的键上，当然其键类型必须遵循<code>Hashable</code>协议（Swift 标准库中定义的一个特定协议）。所有的 Swift 基本类型（如<code>String</code>，<code>Int</code>， <code>Double</code>和 <code>Bool</code>）默认都是可哈希。</p>


<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，当然，这些约束要支持泛型编程的强力特征中的多数。抽象概念如<code>可哈希</code>具有的类型特征是根据他们概念特征来界定的，而不是他们的直接类型特征。</p>


<h3 id="-">类型约束语法</h3>


<p>你可以写一个在一个类型参数名后面的类型约束，通过冒号分割，来作为类型参数链的一部分。这种作用于泛型函数的类型约束的基础语法如下所示（和泛型类型的语法相同）：</p>


<pre><code>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // function body goes here
}
</code></pre>


<p>上面这个假定函数有两个类型参数。第一个类型参数<code>T</code>，有一个需要<code>T</code>必须是<code>SomeClass</code>子类的类型约束；第二个类型参数<code>U</code>，有一个需要<code>U</code>必须遵循<code>SomeProtocol</code>协议的类型约束。</p>


<h3 id="-">类型约束行为</h3>


<p>这里有个名为<code>findStringIndex</code>的非泛型函数，该函数功能是去查找包含一给定<code>String</code>值的数组。若查找到匹配的字符串，<code>findStringIndex</code>函数返回该字符串在数组中的索引值（<code>Int</code>），反之则返回<code>nil</code>：</p>


<pre><code>func findStringIndex(array: String[], valueToFind: String) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findStringIndex</code>函数可以作用于查找一字符串数组中的某个字符串:</p>


<pre><code>let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findStringIndex(strings, "llama") {
    println("The index of llama is \(foundIndex)")
}
// 输出 "The index of llama is 2"
</code></pre>


<p>如果只是针对字符串而言查找在数组中的某个值的索引，用处不是很大，不过，你可以写出相同功能的泛型函数<code>findIndex</code>，用某个类型<code>T</code>值替换掉提到的字符串。</p>


<p>这里展示如何写一个你或许期望的<code>findStringIndex</code>的泛型版本<code>findIndex</code>。请注意这个函数仍然返回<code>Int</code>，是不是有点迷惑呢，而不是泛型类型?那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数不会编译，原因在例子后面会说明：</p>


<pre><code>func findIndex&lt;T&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p>上面所写的函数不会编译。这个问题的位置在等式的检查上，<code>“if value == valueToFind”</code>。不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。正因如此，这部分代码不能可能保证工作于每个可能的类型<code>T</code>，当你试图编译这部分代码时估计会出现相应的错误。</p>


<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个<code>Equatable</code>协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持<code>Equatable</code>协议。</p>


<p>任何<code>Equatable</code>类型都可以安全的使用在<code>findIndex</code>函数中，因为其保证支持等式操作。为了说明这个事实，当你定义一个函数时，你可以写一个<code>Equatable</code>类型约束作为类型参数定义的一部分：</p>


<pre><code>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findIndex</code>中这个单个类型参数写做：<code>T: Equatable</code>，也就意味着“任何T类型都遵循<code>Equatable</code>协议”。</p>


<p><code>findIndex</code>函数现在则可以成功的编译过，并且作用于任何遵循<code>Equatable</code>的类型，如<code>Double</code>或<code>String</code>:</p>


<pre><code>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
// stringIndex is an optional Int containing a value of 2
</code></pre>


<p><a name="associated_types"></a></p>


<h2 id="-">关联类型</h2>


<p>当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名（或<em>别名</em>）。作用于关联类型上实际类型是不需要指定的，直到该协议接受。关联类型被指定为<code>typealias</code>关键字。</p>


<h3 id="-">关联类型行为</h3>


<p>这里是一个<code>Container</code>协议的例子，定义了一个ItemType关联类型：</p>


<pre><code>protocol Container {
    typealias ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>


<p><code>Container</code>协议定义了三个任何容器必须支持的兼容要求：</p>


<ul>
<li>必须可能通过<code>append</code>方法添加一个新item到容器里；</li>
<li>必须可能通过使用<code>count</code>属性获取容器里items的数量，并返回一个<code>Int</code>值；</li>
<li>必须可能通过容器的<code>Int</code>索引值下标可以检索到每一个item。</li>
</ul>


<p>这个协议没有指定容器里item是如何存储的或何种类型是允许的。这个协议只指定三个任何遵循<code>Container</code>类型所必须支持的功能点。一个遵循的类型也可以提供其他额外的功能，只要满足这三个条件。</p>


<p>任何遵循<code>Container</code>协议的类型必须指定存储在其里面的值类型，必须保证只有正确类型的items可以加进容器里，必须明确可以通过其下标返回item类型。</p>


<p>为了定义这三个条件，<code>Container</code>协议需要一个方法指定容器里的元素将会保留，而不需要知道特定容器的类型。<code>Container</code>协议需要指定任何通过<code>append</code>方法添加到容器里的值和容器里元素是相同类型，并且通过容器下标返回的容器元素类型的值的类型是相同类型。</p>


<p>为了达到此目的，<code>Container</code>协议声明了一个ItemType的关联类型，写作<code>typealias ItemType</code>。The protocol does not define what ItemType is an alias for—that information is left for any conforming type to provide（这个协议不会定义<code>ItemType</code>是遵循类型所提供的何种信息的别名）。尽管如此，<code>ItemType</code>别名支持一种方法识别在一个容器里的items类型，以及定义一种使用在<code>append</code>方法和下标中的类型，以便保证任何期望的<code>Container</code>的行为是强制性的。</p>


<p>这里是一个早前IntStack类型的非泛型版本，适用于遵循Container协议：</p>


<pre><code>struct IntStack: Container {
    // original IntStack implementation
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}
</code></pre>


<p><code>IntStack</code>类型实现了<code>Container</code>协议的所有三个要求，在<code>IntStack</code>类型的每个包含部分的功能都满足这些要求。</p>


<p>此外，<code>IntStack</code>指定了<code>Container</code>的实现，适用的ItemType被用作<code>Int</code>类型。对于这个<code>Container</code>协议实现而言，定义 <code>typealias ItemType = Int</code>，将抽象的<code>ItemType</code>类型转换为具体的<code>Int</code>类型。</p>


<p>感谢Swift类型参考，你不用在<code>IntStack</code>定义部分声明一个具体的<code>Int</code>的<code>ItemType</code>。由于<code>IntStack</code>遵循<code>Container</code>协议的所有要求，只要通过简单的查找<code>append</code>方法的item参数类型和下标返回的类型，Swift就可以推断出合适的<code>ItemType</code>来使用。确实，如果上面的代码中你删除了 <code>typealias ItemType = Int</code>这一行，一切仍旧可以工作，因为它清楚的知道ItemType使用的是何种类型。</p>


<p>你也可以生成遵循<code>Container</code>协议的泛型<code>Stack</code>类型：</p>


<pre><code>struct Stack&lt;T&gt;: Container {
    // original Stack&lt;T&gt; implementation
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(item: T) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; T {
        return items[i]
    }
}
</code></pre>


<p>这个时候，占位类型参数<code>T</code>被用作<code>append</code>方法的item参数和下标的返回类型。Swift 因此可以推断出被用作这个特定容器的<code>ItemType</code>的<code>T</code>的合适类型。</p>


<h3 id="-">扩展一个存在的类型为一指定关联类型</h3>


<p>在[使用扩展来添加协议兼容性][6]中有描述扩展一个存在的类型添加遵循一个协议。这个类型包含一个关联类型的协议。</p>


<p>Swift的<code>Array</code>已经提供<code>append</code>方法，一个<code>count</code>属性和通过下标来查找一个自己的元素。这三个功能都达到<code>Container</code>协议的要求。也就意味着你可以扩展<code>Array</code>去遵循<code>Container</code>协议，只要通过简单声明<code>Array</code>适用于该协议而已。如何实践这样一个空扩展，在[使用扩展来声明协议的采纳][7]中有描述这样一个实现一个空扩展的行为：</p>


<pre><code>extension Array: Container {}
</code></pre>


<p>如同上面的泛型<code>Stack</code>类型一样，<code>Array的append</code>方法和下标保证<code>Swift</code>可以推断出<code>ItemType</code>所使用的适用的类型。定义了这个扩展后，你可以将任何<code>Array</code>当作<code>Container</code>来使用。</p>


<p><a name="where_clauses"></a></p>


<h2 id="where-">Where 语句</h2>


<p>[类型约束][8]中描述的类型约束确保你定义关于类型参数的需求和一泛型函数或类型有关联。</p>


<p>对于关联类型的定义需求也是非常有用的。你可以通过这样去定义<em>where语句</em>作为一个类型参数队列的一部分。一个<code>where</code>语句使你能够要求一个关联类型遵循一个特定的协议，以及（或）那个特定的类型参数和关联类型可以是相同的。你可写一个<code>where</code>语句，通过紧随放置<code>where</code>关键字在类型参数队列后面，其后跟着一个或者多个针对关联类型的约束，以及（或）一个或多个类型和关联类型的等于关系。</p>


<p>下面的列子定义了一个名为<code>allItemsMatch</code>的泛型函数，用来检查是否两个<code>Container</code>单例包含具有相同顺序的相同元素。如果匹配到所有的元素，那么返回一个为<code>true</code>的<code>Boolean</code>值，反之，则相反。</p>


<p>这两个容器可以被检查出是否是相同类型的容器（虽然它们可以是），但他们确实拥有相同类型的元素。这个需求通过一个类型约束和<code>where</code>语句结合来表示：</p>


<pre><code>func allItemsMatch&lt;
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;
    (someContainer: C1, anotherContainer: C2) -&gt; Bool {

        // check that both containers contain the same number of items
        if someContainer.count != anotherContainer.count {
            return false
        }

        // check each pair of items to see if they are equivalent
        for i in 0..someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }

        // all items match, so return true
        return true

}
</code></pre>


<p>这个函数用了两个参数：<code>someContainer</code>和<code>anotherContainer</code>。<code>someContainer</code>参数是类型<code>C1</code>，<code>anotherContainer</code>参数是类型<code>C2</code>。<code>C1</code>和<code>C2</code>是容器的两个占位类型参数，决定了这个函数何时被调用。</p>


<p>这个函数的类型参数列紧随在两个类型参数需求的后面：</p>


<ul>
<li><code>C1</code>必须遵循<code>Container</code>协议 (写作 <code>C1: Container</code>)。</li>
<li><code>C2</code>必须遵循<code>Container</code>协议 (写作 <code>C2: Container</code>)。</li>
<li><code>C1</code>的<code>ItemType</code>同样是C2的<code>ItemType</code>（写作 <code>C1.ItemType == C2.ItemType</code>）。</li>
<li><code>C1</code>的<code>ItemType</code>必须遵循<code>Equatable</code>协议 (写作 <code>C1.ItemType: Equatable</code>)。</li>
</ul>


<p>第三个和第四个要求被定义为一个<code>where</code>语句的一部分，写在关键字<code>where</code>后面，作为函数类型参数链的一部分。</p>


<p>这些要求意思是：</p>


<p><code>someContainer</code>是一个<code>C1</code>类型的容器。
<code>anotherContainer</code>是一个<code>C2</code>类型的容器。
<code>someContainer</code>和<code>anotherContainer</code>包含相同的元素类型。
<code>someContainer</code>中的元素可以通过不等于操作(<code>!=</code>)来检查它们是否彼此不同。</p>


<p>第三个和第四个要求结合起来的意思是<code>anotherContainer</code>中的元素也可以通过 <code>!=</code> 操作来检查，因为他们在<code>someContainer</code>中元素确实是相同的类型。</p>


<p>这些要求能够使<code>allItemsMatch</code>函数比较两个容器，即便他们是不同的容器类型。</p>


<p><code>allItemsMatch</code>首先检查两个容器是否拥有同样数目的items，如果他们的元素数目不同，没有办法进行匹配，函数就会<code>false</code>。</p>


<p>检查完之后，函数通过<code>for-in</code>循环和半闭区间操作（..）来迭代<code>someContainer</code>中的所有元素。对于每个元素，函数检查是否<code>someContainer</code>中的元素不等于对应的<code>anotherContainer</code>中的元素，如果这两个元素不等，则这两个容器不匹配，返回<code>false</code>。</p>


<p>如果循环体结束后未发现没有任何的不匹配，那表明两个容器匹配，函数返回<code>true</code>。</p>


<p>这里演示了allItemsMatch函数运算的过程：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    println("All items match.")
} else {
    println("Not all items match.")
}
// 输出 "All items match."
</code></pre>


<p> 上面的例子创建一个<code>Stack</code>单例来存储<code>String</code>，然后压了三个字符串进栈。这个例子也创建了一个<code>Array</code>单例，并初始化包含三个同栈里一样的原始字符串。即便栈和数组否是不同的类型，但他们都遵循<code>Container</code>协议，而且他们都包含同样的类型值。你因此可以调用<code>allItemsMatch</code>函数，用这两个容器作为它的参数。在上面的例子中，<code>allItemsMatch</code>函数正确的显示了所有的这两个容器的<code>items</code>匹配。</p>

]]></content>
  </entry>
  
</feed>
