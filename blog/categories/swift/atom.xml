<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | 小巴童鞋]]></title>
  <link href="http://baxiang123.com//blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://baxiang123.com//"/>
  <updated>2015-03-15T03:08:57+08:00</updated>
  <id>http://baxiang123.com//</id>
  <author>
    <name><![CDATA[小巴]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[swift泛型]]></title>
    <link href="http://baxiang123.com//blog/Swif%E6%B3%9B%E5%9E%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swif泛型</id>
    <content type="html"><![CDATA[<p><em>泛型代码</em>可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>


<p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个<code>Int</code>数组，也可创建一个<code>String</code>数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。</p>


<!-- more -->


<p><a name="the_problem_that_generics_solve"></a></p>


<h2 id="-">泛型所解决的问题</h2>


<p>这里是一个标准的，非泛型函数<code>swapTwoInts</code>,用来交换两个Int值：</p>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>这个函数使用写入读出（in-out）参数来交换<code>a</code>和<code>b</code>的值，请参考[写入读出参数][1]。</p></p>

<p><code>swapTwoInts</code>函数可以交换<code>b</code>的原始值到<code>a</code>，也可以交换a的原始值到<code>b</code>，你可以调用这个函数交换两个<code>Int</code>变量值：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 输出 "someInt is now 107, and anotherInt is now 3"
</code></pre>


<p><code>swapTwoInts</code>函数是非常有用的，但是它只能交换<code>Int</code>值，如果你想要交换两个<code>String</code>或者<code>Double</code>，就不得不写更多的函数，如 <code>swapTwoStrings</code>和<code>swapTwoDoublesfunctions</code>，如同如下所示：</p>


<pre><code>func swapTwoStrings(inout a: String, inout b: String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(inout a: Double, inout b: Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p>你可能注意到 <code>swapTwoInts</code>、 <code>swapTwoStrings</code>和<code>swapTwoDoubles</code>函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是<code>Int</code>、<code>String</code>和<code>Double</code>。</p>


<p>但实际应用中通常需要一个用处更强大并且尽可能的考虑到更多的灵活性单个函数，可以用来交换两个任何类型值，很幸运的是，泛型代码帮你解决了这种问题。（一个这种泛型函数后面已经定义好了。）</p>


<blockquote>
<p>注意：
在所有三个函数中，<code>a</code>和<code>b</code>的类型是一样的。如果<code>a</code>和<code>b</code>不是相同的类型，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个<code>String</code>类型的变量和一个<code>Double</code>类型的变量互相交换值。如果一定要做，Swift 将报编译错误。</p>
</blockquote>


<p><a name="generic_functions"></a></p>


<h2 id="-">泛型函数</h2>


<p><code>泛型函数</code>可以工作于任何类型，这里是一个上面<code>swapTwoInts</code>函数的泛型版本，用于交换两个值：</p>


<pre><code>func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p><code>swapTwoValues</code>函数主体和<code>swapTwoInts</code>函数是一样的，它只在第一行稍微有那么一点点不同于<code>swapTwoInts</code>，如下所示：</p>


<pre><code>func swapTwoInts(inout a: Int, inout b: Int)
func swapTwoValues&lt;T&gt;(inout a: T, inout b: T)
</code></pre>


<p>这个函数的泛型版本使用了占位类型名字（通常此情况下用字母<code>T</code>来表示）来代替实际类型名（如<code>In</code>、<code>String</code>或<code>Doubl</code>）。占位类型名没有提示<code>T</code>必须是什么类型，但是它提示了<code>a</code>和<code>b</code>必须是同一类型<code>T</code>，而不管<code>T</code>表示什么类型。只有<code>swapTwoValues</code>函数在每次调用时所传入的实际类型才能决定<code>T</code>所代表的类型。</p>


<p>另外一个不同之处在于这个泛型函数名后面跟着的展位类型名字（T）是用尖括号括起来的（<t>）。这个尖括号告诉 Swift 那个<code>T</code>是<code>swapTwoValues</code>函数所定义的一个类型。因为<code>T</code>是一个占位命名类型，Swift 不会去查找命名为T的实际类型。</t></p>


<p><code>swapTwoValues</code>函数除了要求传入的两个任何类型值是同一类型外，也可以作为<code>swapTwoInts</code>函数被调用。每次<code>swapTwoValues</code>被调用，T所代表的类型值都会传给函数。</p>


<p>在下面的两个例子中,<code>T</code>分别代表<code>Int</code>和<code>String</code>：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;someInt, &amp;anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&amp;someString, &amp;anotherString)
// someString is now "world", and anotherString is now "hello"
</code></pre>


<blockquote>
<p>注意
上面定义的函数<code>swapTwoValues</code>是受<code>swap</code>函数启发而实现的。<code>swap</code>函数存在于 Swift 标准库，并可以在其它类中任意使用。如果你在自己代码中需要类似<code>swapTwoValues</code>函数的功能，你可以使用已存在的交换函数<code>swap</code>函数。</p>
</blockquote>


<p><a name="type_parameters"></a></p>


<h2 id="-">类型参数</h2>


<p>在上面的<code>swapTwoValues</code>例子中，占位类型<code>T</code>是一种类型参数的示例。类型参数指定并命名为一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（如<t>）。</t></p>


<p>一旦一个类型参数被指定，那么其可以被使用来定义一个函数的参数类型（如<code>swapTwoValues</code>函数中的参数<code>a</code>和<code>b</code>），或作为一个函数返回类型，或用作函数主体中的注释类型。在这种情况下，被类型参数所代表的占位类型不管函数任何时候被调用，都会被实际类型所替换（在上面<code>swapTwoValues</code>例子中，当函数第一次被调用时，<code>T</code>被<code>Int</code>替换，第二次调用时，被<code>String</code>替换。）。</p>


<p>你可支持多个类型参数，命名在尖括号中，用逗号分开。</p>


<p><a name="naming_type_parameters"></a></p>


<h2 id="-">命名类型参数</h2>


<p>在简单的情况下，泛型函数或泛型类型需要指定一个占位类型（如上面的<code>swapTwoValues</code>泛型函数，或一个存储单一类型的泛型集，如数组），通常用一单个字母<code>T</code>来命名类型参数。不过，你可以使用任何有效的标识符来作为类型参数名。</p>


<p>如果你使用多个参数定义更复杂的泛型函数或泛型类型，那么使用更多的描述类型参数是非常有用的。例如，Swift 字典（Dictionary）类型有两个类型参数，一个是键，另外一个是值。如果你自己写字典，你或许会定义这两个类型参数为<code>KeyType</code>和<code>ValueType</code>，用来记住它们在你的泛型代码中的作用。</p>


<blockquote>
<p>注意
请始终使用大写字母开头的驼峰式命名法（例如<code>T</code>和<code>KeyType</code>）来给类型参数命名，以表明它们是类型的占位符，而非类型值。</p>
</blockquote>


<p><a name="generic_types"></a></p>


<h2 id="-">泛型类型</h2>


<p>通常在泛型函数中，Swift 允许你定义你自己的泛型类型。这些自定义类、结构体和枚举作用于任何类型，如同<code>Array</code>和<code>Dictionary</code>的用法。</p>


<p>这部分向你展示如何写一个泛型集类型&#8211;<code>Stack</code>（栈）。一个栈是一系列值域的集合，和<code>Array</code>（数组）类似，但其是一个比 Swift 的<code>Array</code>类型更多限制的集合。一个数组可以允许其里面任何位置的插入/删除操作，而栈，只允许在集合的末端添加新的项（如同<em>push</em>一个新值进栈）。同样的一个栈也只能从末端移除项（如同<em>pop</em>一个值出栈）。</p>


<blockquote>
<p>注意
栈的概念已被<code>UINavigationController</code>类使用来模拟试图控制器的导航结构。你通过调用<code>UINavigationController</code>的<code>pushViewController:animated:</code>方法来为导航栈添加（add）新的试图控制器；而通过<code>popViewControllerAnimated:</code>的方法来从导航栈中移除（pop）某个试图控制器。每当你需要一个严格的<code>后进先出</code>方式来管理集合，堆栈都是最实用的模型。</p>
</blockquote>


<p>下图展示了一个栈的压栈(push)/出栈(pop)的行为：</p>


<p>![此处输入图片的描述][2]</p>


<ol>
<li>现在有三个值在栈中；</li>
<li>第四个值“pushed”到栈的顶部；</li>
<li>现在有四个值在栈中，最近的那个在顶部；</li>
<li>栈中最顶部的那个项被移除，或称之为“popped”；</li>
<li>移除掉一个值后，现在栈又重新只有三个值。</li>
</ol>


<p>这里展示了如何写一个非泛型版本的栈，<code>Int</code>值型的栈：</p>


<pre><code>struct IntStack {
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
}
</code></pre>


<p>这个结构体在栈中使用一个<code>Array</code>性质的<code>items</code>存储值。<code>Stack</code>提供两个方法：<code>push</code>和<code>pop</code>，从栈中压进一个值和移除一个值。这些方法标记为可变的，因为他们需要修改（或<em>转换</em>）结构体的<code>items</code>数组。</p>


<p>上面所展现的<code>IntStack</code>类型只能用于<code>Int</code>值，不过，其对于定义一个泛型<code>Stack</code>类（可以处理<em>任何</em>类型值的栈）是非常有用的。</p>


<p>这里是一个相同代码的泛型版本：</p>


<pre><code>struct Stack&lt;T&gt; {
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
}
</code></pre>


<p>注意到<code>Stack</code>的泛型版本基本上和非泛型版本相同，但是泛型版本的占位类型参数为T代替了实际<code>Int</code>类型。这种类型参数包含在一对尖括号里（<code>&lt;T&gt;</code>），紧随在结构体名字后面。</p>


<p><code>T</code>定义了一个名为“某种类型T”的节点提供给后来用。这种将来类型可以在结构体的定义里任何地方表示为“T”。在这种情况下，<code>T</code>在如下三个地方被用作节点：</p>


<ul>
<li>创建一个名为<code>items</code>的属性，使用空的T类型值数组对其进行初始化；</li>
<li>指定一个包含一个参数名为<code>item</code>的<code>push</code>方法，该参数必须是T类型；</li>
<li>指定一个<code>pop</code>方法的返回值，该返回值将是一个T类型值。</li>
</ul>


<p>当创建一个新单例并初始化时， 通过用一对紧随在类型名后的尖括号里写出实际指定栈用到类型，创建一个<code>Stack</code>实例，同创建<code>Array</code>和<code>Dictionary</code>一样：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 现在栈已经有4个string了
</code></pre>


<p>下图将展示<code>stackOfStrings</code>如何<code>push</code>这四个值进栈的过程：</p>


<p>![此处输入图片的描述][3]</p>


<p>从栈中<code>pop</code>并移除值&#8221;cuatro&#8221;：</p>


<pre><code>let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to "cuatro", and the stack now contains 3 strings
</code></pre>


<p>下图展示了如何从栈中pop一个值的过程：
![此处输入图片的描述][4]</p>


<p>由于<code>Stack</code>是泛型类型，所以在 Swift 中其可以用来创建任何有效类型的栈，这种方式如同<code>Array</code>和<code>Dictionary</code>。</p>


<p><a name="type_constraints"></a></p>


<h2 id="-">类型约束</h2>


<p><code>swapTwoValues</code>函数和<code>Stack</code>类型可以作用于任何类型，不过，有的时候对使用在泛型函数和泛型类型上的类型强制约束为某种特定类型是非常有用的。类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成。</p>


<p>例如，Swift 的<code>Dictionary</code>类型对作用于其键的类型做了些限制。在[字典][5]的描述中，字典的键类型必须是<em>可哈希</em>，也就是说，必须有一种方法可以使其是唯一的表示。<code>Dictionary</code>之所以需要其键是可哈希是为了以便于其检查其是否包含某个特定键的值。如无此需求，<code>Dictionary</code>即不会告诉是否插入或者替换了某个特定键的值，也不能查找到已经存储在字典里面的给定键值。</p>


<p>这个需求强制加上一个类型约束作用于<code>Dictionary</code>的键上，当然其键类型必须遵循<code>Hashable</code>协议（Swift 标准库中定义的一个特定协议）。所有的 Swift 基本类型（如<code>String</code>，<code>Int</code>， <code>Double</code>和 <code>Bool</code>）默认都是可哈希。</p>


<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，当然，这些约束要支持泛型编程的强力特征中的多数。抽象概念如<code>可哈希</code>具有的类型特征是根据他们概念特征来界定的，而不是他们的直接类型特征。</p>


<h3 id="-">类型约束语法</h3>


<p>你可以写一个在一个类型参数名后面的类型约束，通过冒号分割，来作为类型参数链的一部分。这种作用于泛型函数的类型约束的基础语法如下所示（和泛型类型的语法相同）：</p>


<pre><code>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // function body goes here
}
</code></pre>


<p>上面这个假定函数有两个类型参数。第一个类型参数<code>T</code>，有一个需要<code>T</code>必须是<code>SomeClass</code>子类的类型约束；第二个类型参数<code>U</code>，有一个需要<code>U</code>必须遵循<code>SomeProtocol</code>协议的类型约束。</p>


<h3 id="-">类型约束行为</h3>


<p>这里有个名为<code>findStringIndex</code>的非泛型函数，该函数功能是去查找包含一给定<code>String</code>值的数组。若查找到匹配的字符串，<code>findStringIndex</code>函数返回该字符串在数组中的索引值（<code>Int</code>），反之则返回<code>nil</code>：</p>


<pre><code>func findStringIndex(array: String[], valueToFind: String) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findStringIndex</code>函数可以作用于查找一字符串数组中的某个字符串:</p>


<pre><code>let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findStringIndex(strings, "llama") {
    println("The index of llama is \(foundIndex)")
}
// 输出 "The index of llama is 2"
</code></pre>


<p>如果只是针对字符串而言查找在数组中的某个值的索引，用处不是很大，不过，你可以写出相同功能的泛型函数<code>findIndex</code>，用某个类型<code>T</code>值替换掉提到的字符串。</p>


<p>这里展示如何写一个你或许期望的<code>findStringIndex</code>的泛型版本<code>findIndex</code>。请注意这个函数仍然返回<code>Int</code>，是不是有点迷惑呢，而不是泛型类型?那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数不会编译，原因在例子后面会说明：</p>


<pre><code>func findIndex&lt;T&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p>上面所写的函数不会编译。这个问题的位置在等式的检查上，<code>“if value == valueToFind”</code>。不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。正因如此，这部分代码不能可能保证工作于每个可能的类型<code>T</code>，当你试图编译这部分代码时估计会出现相应的错误。</p>


<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个<code>Equatable</code>协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持<code>Equatable</code>协议。</p>


<p>任何<code>Equatable</code>类型都可以安全的使用在<code>findIndex</code>函数中，因为其保证支持等式操作。为了说明这个事实，当你定义一个函数时，你可以写一个<code>Equatable</code>类型约束作为类型参数定义的一部分：</p>


<pre><code>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findIndex</code>中这个单个类型参数写做：<code>T: Equatable</code>，也就意味着“任何T类型都遵循<code>Equatable</code>协议”。</p>


<p><code>findIndex</code>函数现在则可以成功的编译过，并且作用于任何遵循<code>Equatable</code>的类型，如<code>Double</code>或<code>String</code>:</p>


<pre><code>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
// stringIndex is an optional Int containing a value of 2
</code></pre>


<p><a name="associated_types"></a></p>


<h2 id="-">关联类型</h2>


<p>当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名（或<em>别名</em>）。作用于关联类型上实际类型是不需要指定的，直到该协议接受。关联类型被指定为<code>typealias</code>关键字。</p>


<h3 id="-">关联类型行为</h3>


<p>这里是一个<code>Container</code>协议的例子，定义了一个ItemType关联类型：</p>


<pre><code>protocol Container {
    typealias ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>


<p><code>Container</code>协议定义了三个任何容器必须支持的兼容要求：</p>


<ul>
<li>必须可能通过<code>append</code>方法添加一个新item到容器里；</li>
<li>必须可能通过使用<code>count</code>属性获取容器里items的数量，并返回一个<code>Int</code>值；</li>
<li>必须可能通过容器的<code>Int</code>索引值下标可以检索到每一个item。</li>
</ul>


<p>这个协议没有指定容器里item是如何存储的或何种类型是允许的。这个协议只指定三个任何遵循<code>Container</code>类型所必须支持的功能点。一个遵循的类型也可以提供其他额外的功能，只要满足这三个条件。</p>


<p>任何遵循<code>Container</code>协议的类型必须指定存储在其里面的值类型，必须保证只有正确类型的items可以加进容器里，必须明确可以通过其下标返回item类型。</p>


<p>为了定义这三个条件，<code>Container</code>协议需要一个方法指定容器里的元素将会保留，而不需要知道特定容器的类型。<code>Container</code>协议需要指定任何通过<code>append</code>方法添加到容器里的值和容器里元素是相同类型，并且通过容器下标返回的容器元素类型的值的类型是相同类型。</p>


<p>为了达到此目的，<code>Container</code>协议声明了一个ItemType的关联类型，写作<code>typealias ItemType</code>。The protocol does not define what ItemType is an alias for—that information is left for any conforming type to provide（这个协议不会定义<code>ItemType</code>是遵循类型所提供的何种信息的别名）。尽管如此，<code>ItemType</code>别名支持一种方法识别在一个容器里的items类型，以及定义一种使用在<code>append</code>方法和下标中的类型，以便保证任何期望的<code>Container</code>的行为是强制性的。</p>


<p>这里是一个早前IntStack类型的非泛型版本，适用于遵循Container协议：</p>


<pre><code>struct IntStack: Container {
    // original IntStack implementation
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}
</code></pre>


<p><code>IntStack</code>类型实现了<code>Container</code>协议的所有三个要求，在<code>IntStack</code>类型的每个包含部分的功能都满足这些要求。</p>


<p>此外，<code>IntStack</code>指定了<code>Container</code>的实现，适用的ItemType被用作<code>Int</code>类型。对于这个<code>Container</code>协议实现而言，定义 <code>typealias ItemType = Int</code>，将抽象的<code>ItemType</code>类型转换为具体的<code>Int</code>类型。</p>


<p>感谢Swift类型参考，你不用在<code>IntStack</code>定义部分声明一个具体的<code>Int</code>的<code>ItemType</code>。由于<code>IntStack</code>遵循<code>Container</code>协议的所有要求，只要通过简单的查找<code>append</code>方法的item参数类型和下标返回的类型，Swift就可以推断出合适的<code>ItemType</code>来使用。确实，如果上面的代码中你删除了 <code>typealias ItemType = Int</code>这一行，一切仍旧可以工作，因为它清楚的知道ItemType使用的是何种类型。</p>


<p>你也可以生成遵循<code>Container</code>协议的泛型<code>Stack</code>类型：</p>


<pre><code>struct Stack&lt;T&gt;: Container {
    // original Stack&lt;T&gt; implementation
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(item: T) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; T {
        return items[i]
    }
}
</code></pre>


<p>这个时候，占位类型参数<code>T</code>被用作<code>append</code>方法的item参数和下标的返回类型。Swift 因此可以推断出被用作这个特定容器的<code>ItemType</code>的<code>T</code>的合适类型。</p>


<h3 id="-">扩展一个存在的类型为一指定关联类型</h3>


<p>在[使用扩展来添加协议兼容性][6]中有描述扩展一个存在的类型添加遵循一个协议。这个类型包含一个关联类型的协议。</p>


<p>Swift的<code>Array</code>已经提供<code>append</code>方法，一个<code>count</code>属性和通过下标来查找一个自己的元素。这三个功能都达到<code>Container</code>协议的要求。也就意味着你可以扩展<code>Array</code>去遵循<code>Container</code>协议，只要通过简单声明<code>Array</code>适用于该协议而已。如何实践这样一个空扩展，在[使用扩展来声明协议的采纳][7]中有描述这样一个实现一个空扩展的行为：</p>


<pre><code>extension Array: Container {}
</code></pre>


<p>如同上面的泛型<code>Stack</code>类型一样，<code>Array的append</code>方法和下标保证<code>Swift</code>可以推断出<code>ItemType</code>所使用的适用的类型。定义了这个扩展后，你可以将任何<code>Array</code>当作<code>Container</code>来使用。</p>


<p><a name="where_clauses"></a></p>


<h2 id="where-">Where 语句</h2>


<p>[类型约束][8]中描述的类型约束确保你定义关于类型参数的需求和一泛型函数或类型有关联。</p>


<p>对于关联类型的定义需求也是非常有用的。你可以通过这样去定义<em>where语句</em>作为一个类型参数队列的一部分。一个<code>where</code>语句使你能够要求一个关联类型遵循一个特定的协议，以及（或）那个特定的类型参数和关联类型可以是相同的。你可写一个<code>where</code>语句，通过紧随放置<code>where</code>关键字在类型参数队列后面，其后跟着一个或者多个针对关联类型的约束，以及（或）一个或多个类型和关联类型的等于关系。</p>


<p>下面的列子定义了一个名为<code>allItemsMatch</code>的泛型函数，用来检查是否两个<code>Container</code>单例包含具有相同顺序的相同元素。如果匹配到所有的元素，那么返回一个为<code>true</code>的<code>Boolean</code>值，反之，则相反。</p>


<p>这两个容器可以被检查出是否是相同类型的容器（虽然它们可以是），但他们确实拥有相同类型的元素。这个需求通过一个类型约束和<code>where</code>语句结合来表示：</p>


<pre><code>func allItemsMatch&lt;
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;
    (someContainer: C1, anotherContainer: C2) -&gt; Bool {

        // check that both containers contain the same number of items
        if someContainer.count != anotherContainer.count {
            return false
        }

        // check each pair of items to see if they are equivalent
        for i in 0..someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }

        // all items match, so return true
        return true

}
</code></pre>


<p>这个函数用了两个参数：<code>someContainer</code>和<code>anotherContainer</code>。<code>someContainer</code>参数是类型<code>C1</code>，<code>anotherContainer</code>参数是类型<code>C2</code>。<code>C1</code>和<code>C2</code>是容器的两个占位类型参数，决定了这个函数何时被调用。</p>


<p>这个函数的类型参数列紧随在两个类型参数需求的后面：</p>


<ul>
<li><code>C1</code>必须遵循<code>Container</code>协议 (写作 <code>C1: Container</code>)。</li>
<li><code>C2</code>必须遵循<code>Container</code>协议 (写作 <code>C2: Container</code>)。</li>
<li><code>C1</code>的<code>ItemType</code>同样是C2的<code>ItemType</code>（写作 <code>C1.ItemType == C2.ItemType</code>）。</li>
<li><code>C1</code>的<code>ItemType</code>必须遵循<code>Equatable</code>协议 (写作 <code>C1.ItemType: Equatable</code>)。</li>
</ul>


<p>第三个和第四个要求被定义为一个<code>where</code>语句的一部分，写在关键字<code>where</code>后面，作为函数类型参数链的一部分。</p>


<p>这些要求意思是：</p>


<p><code>someContainer</code>是一个<code>C1</code>类型的容器。
<code>anotherContainer</code>是一个<code>C2</code>类型的容器。
<code>someContainer</code>和<code>anotherContainer</code>包含相同的元素类型。
<code>someContainer</code>中的元素可以通过不等于操作(<code>!=</code>)来检查它们是否彼此不同。</p>


<p>第三个和第四个要求结合起来的意思是<code>anotherContainer</code>中的元素也可以通过 <code>!=</code> 操作来检查，因为他们在<code>someContainer</code>中元素确实是相同的类型。</p>


<p>这些要求能够使<code>allItemsMatch</code>函数比较两个容器，即便他们是不同的容器类型。</p>


<p><code>allItemsMatch</code>首先检查两个容器是否拥有同样数目的items，如果他们的元素数目不同，没有办法进行匹配，函数就会<code>false</code>。</p>


<p>检查完之后，函数通过<code>for-in</code>循环和半闭区间操作（..）来迭代<code>someContainer</code>中的所有元素。对于每个元素，函数检查是否<code>someContainer</code>中的元素不等于对应的<code>anotherContainer</code>中的元素，如果这两个元素不等，则这两个容器不匹配，返回<code>false</code>。</p>


<p>如果循环体结束后未发现没有任何的不匹配，那表明两个容器匹配，函数返回<code>true</code>。</p>


<p>这里演示了allItemsMatch函数运算的过程：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    println("All items match.")
} else {
    println("Not all items match.")
}
// 输出 "All items match."
</code></pre>


<p> 上面的例子创建一个<code>Stack</code>单例来存储<code>String</code>，然后压了三个字符串进栈。这个例子也创建了一个<code>Array</code>单例，并初始化包含三个同栈里一样的原始字符串。即便栈和数组否是不同的类型，但他们都遵循<code>Container</code>协议，而且他们都包含同样的类型值。你因此可以调用<code>allItemsMatch</code>函数，用这两个容器作为它的参数。在上面的例子中，<code>allItemsMatch</code>函数正确的显示了所有的这两个容器的<code>items</code>匹配。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift集合类型]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift集合类型</id>
    <content type="html"><![CDATA[<p>Swift 语言提供经典的数组和字典两种集合类型来存储集合数据。数组用来按顺序存储相同类型的数据。字典虽然无序存储相同类型数据值但是需要由独有的标识符引用和寻址（就是键值对）。</p>


<p>Swift 语言里的数组和字典中存储的数据值类型必须明确。 这意味着我们不能把不正确的数据类型插入其中。 同时这也说明我们完全可以对获取出的值类型非常自信。 Swift 对显式类型集合的使用确保了我们的代码对工作所需要的类型非常清楚，也让我们在开发中可以早早地找到任何的类型不匹配错误。</p>


<!-- more -->


<blockquote>
<p>注意：</p>
<p>Swift 的数组结构在被声明成常量和变量或者被传入函数与方法中时会相对于其他类型展现出不同的特性。 获取更多信息请参见<a href="#mutability_of_collections">集合的可变性</a>与<a href="09_Classes_and_Structures.html#assignment_and_copy_behavior_for_collection_types">集合在赋值和复制中的行为</a>章节。</p>
</blockquote>


<p><a name="arrays"></a></p>


<h2 id="-">数组</h2>


<p>数组使用有序列表存储相同类型的多重数据。相同的值可以多次出现在一个数组的不同位置中。</p>


<p>Swift 数组对存储数据有具体要求。 不同于 Objective-C 的<code>NSArray</code>和<code>NSMutableArray</code>类，他们可以存储任何类型的实例而且不提供他们返回对象的任何本质信息。 在 Swift 中，数据值在被存储进入某个数组之前类型必须明确，方法是通过显式的类型标注或类型推断，而且不是必须是<code>class</code>类型。例如： 如果我们创建了一个<code>Int</code>值类型的数组，我们不能往其中插入任何不是<code>Int</code>类型的数据。 Swift 中的数组是类型安全的，并且它们中包含的类型必须明确。</p>


<p><a name="array_type_shorthand_syntax"></a></p>


<h3 id="-">数组的简单语法</h3>


<p>写 Swift 数组应该遵循像<code>Array&lt;SomeType&gt;</code>这样的形式，其中<code>SomeType</code>是这个数组中唯一允许存在的数据类型。 我们也可以使用像<code>SomeType[]</code>这样的简单语法。 尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</p>


<p><a name="array_literals"></a></p>


<h3 id="-">数组构造语句</h3>


<p>我们可以使用字面语句来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。字面语句是一系列由逗号分割并由方括号包含的数值。
<code>[value 1, value 2, value 3]</code>。</p>


<p>下面这个例子创建了一个叫做<code>shoppingList</code>并且存储字符串的数组：</p>


<pre><code>var shoppingList: String[] = ["Eggs", "Milk"]
// shoppingList 已经被构造并且拥有两个初始项。
</code></pre>


<p><code>shoppingList</code>变量被声明为“字符串值类型的数组“，记作<code>String[]</code>。 因为这个数组被规定只有<code>String</code>一种数据结构，所以只有<code>String</code>类型可以在其中被存取。 在这里，<code>shoppinglist</code>数组由两个<code>String</code>值（<code>"Eggs"</code> 和<code>"Milk"</code>）构造，并且由字面语句定义。</p>


<blockquote>
<p>注意：</p>
<p><code>Shoppinglist</code>数组被声明为变量（<code>var</code>关键字创建）而不是常量（<code>let</code>创建）是因为以后可能会有更多的数据项被插入其中。</p>
</blockquote>


<p>在这个例子中，字面语句仅仅包含两个<code>String</code>值。匹配了该数组的变量声明（只能包含<code>String</code>的数组），所以这个字面语句的分配过程就是允许用两个初始项来构造<code>shoppinglist</code>。</p>


<p>由于 Swift 的类型推断机制，当我们用字面语句构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。 <code>shoppinglist</code>的构造也可以这样写：</p>


<pre><code>var shoppingList = ["Eggs", "Milk"]
</code></pre>


<p>因为所有字面语句中的值都是相同的类型，Swift 可以推断出<code>String[]</code>是<code>shoppinglist</code>中变量的正确类型。</p>


<p><a name="accessing_and_modifying_an_array"></a></p>


<h3 id="-">访问和修改数组</h3>


<p>我们可以通过数组的方法和属性来访问和修改数组，或者下标语法。
还可以使用数组的只读属性<code>count</code>来获取数组中的数据项数量。</p>


<pre><code>println("The shopping list contains \(shoppingList.count) items.")
// 输出"The shopping list contains 2 items."（这个数组有2个项）
</code></pre>


<p>使用布尔项<code>isEmpty</code>来作为检查<code>count</code>属性的值是否为 0 的捷径。</p>


<pre><code>if shoppingList.isEmpty {
    println("The shopping list is empty.")
} else {
    println("The shopping list is not empty.")
}
// 打印 "The shopping list is not empty."（shoppinglist不是空的）
</code></pre>


<p>也可以使用<code>append</code>方法在数组后面添加新的数据项：</p>


<pre><code>shoppingList.append("Flour")
// shoppingList 现在有3个数据项，有人在摊煎饼
</code></pre>


<p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加数据项：</p>


<pre><code>shoppingList += "Baking Powder"
// shoppingList 现在有四项了
</code></pre>


<p>我们也可以使用加法赋值运算符（<code>+=</code>）直接添加拥有相同类型数据的数组。</p>


<pre><code>shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
// shoppingList 现在有7项了
</code></pre>


<p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>


<pre><code>var firstItem = shoppingList[0]
// 第一项是 "Eggs"
</code></pre>


<p>注意第一项在数组中的索引值是<code>0</code>而不是<code>1</code>。 Swift 中的数组索引总是从零开始。</p>


<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>


<pre><code>shoppingList[0] = "Six eggs"
// 其中的第一项现在是 "Six eggs" 而不是 "Eggs"
</code></pre>


<p>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把<code>"Chocolate Spread"</code>，<code>"Cheese"</code>，和<code>"Butter"</code>替换为<code>"Bananas"</code>和 <code>"Apples"</code>：</p>


<pre><code>shoppingList[4...6] = ["Bananas", "Apples"]
// shoppingList 现在有六项
</code></pre>


<blockquote>
<p>注意：</p>
<p>我们不能使用下标语法在数组尾部添加新项。如果我们试着用这种方法对索引越界的数据进行检索或者设置新值的操作，我们会引发一个运行期错误。我们可以使用索引值和数组的<code>count</code>属性进行比较来在使用某个索引之前先检验是否有效。除了当<code>count</code>等于 0 时（说明这是个空数组），最大索引值一直是<code>count - 1</code>，因为数组都是零起索引。</p>
</blockquote>


<p>调用数组的<code>insert(atIndex:)</code>方法来在某个具体索引值之前添加数据项：</p>


<pre><code>shoppingList.insert("Maple Syrup", atIndex: 0)
// shoppingList 现在有7项
// "Maple Syrup" 现在是这个列表中的第一项
</code></pre>


<p>这次<code>insert</code>函数调用把值为<code>"Maple Syrup"</code>的新数据项插入列表的最开始位置，并且使用<code>0</code>作为索引值。</p>


<p>类似的我们可以使用<code>removeAtIndex</code>方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）:</p>


<pre><code>let mapleSyrup = shoppingList.removeAtIndex(0)
//索引值为0的数据项被移除
// shoppingList 现在只有6项，而且不包括Maple Syrup
// mapleSyrup常量的值等于被移除数据项的值 "Maple Syrup"
</code></pre>


<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为<code>0</code>的数据项的值再次等于<code>"Six eggs"</code>:</p>


<pre><code>firstItem = shoppingList[0]
// firstItem 现在等于 "Six eggs"
</code></pre>


<p>如果我们只想把数组中的最后一项移除，可以使用<code>removeLast</code>方法而不是<code>removeAtIndex</code>方法来避免我们需要获取数组的<code>count</code>属性。就像后者一样，前者也会返回被移除的数据项：</p>


<pre><code>let apples = shoppingList.removeLast()
// 数组的最后一项被移除了
// shoppingList现在只有5项，不包括cheese
//  apples 常量的值现在等于"Apples" 字符串
</code></pre>


<p><a name="iterating_over_an_array"></a></p>


<h3 id="-">数组的遍历</h3>


<p>我们可以使用<code>for-in</code>循环来遍历所有数组中的数据项：</p>


<pre><code>for item in shoppingList {
    println(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
</code></pre>


<p>如果我们同时需要每个数据项的值和索引值，可以使用全局<code>enumerate</code>函数来进行数组遍历。<code>enumerate</code>返回一个由每一个数据项索引值和数据值组成的键值对组。我们可以把这个键值对组分解成临时常量或者变量来进行遍历：</p>


<pre><code>for (index, value) in enumerate(shoppingList) {
    println("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
</code></pre>


<p>更多关于<code>for-in</code>循环的介绍请参见<a href="05_Control_Flow.html#for_loops">for 循环</a>。</p>


<p><a name="creating_and_initializing_an_array"></a></p>


<h3 id="-">创建并且构造一个数组</h3>


<p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>


<pre><code>var someInts = Int[]()
println("someInts is of type Int[] with \(someInts。count) items。")
// 打印 "someInts is of type Int[] with 0 items。"（someInts是0数据项的Int[]数组）
</code></pre>


<p>注意<code>someInts</code>被设置为一个<code>Int[]</code>构造函数的输出所以它的变量类型被定义为<code>Int[]</code>。</p>


<p>除此之外，如果代码上下文中提供了类型信息， 例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：<code>[]</code>（一对空方括号）：</p>


<pre><code>someInts.append(3)
// someInts 现在包含一个INT值
someInts = []
// someInts 现在是空数组，但是仍然是Int[]类型的。
</code></pre>


<p>Swift 中的<code>Array</code>类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（<code>count</code>）和适当类型的初始值（<code>repeatedValue</code>）传入数组构造函数：</p>


<pre><code>var threeDoubles = Double[](count: 3, repeatedValue:0.0)
// threeDoubles 是一种 Double[]数组, 等于 [0.0, 0.0, 0.0]
</code></pre>


<p>因为类型推断的存在，我们使用这种构造方法的时候不需要特别指定数组中存储的数据类型，因为类型可以从默认值推断出来：</p>


<pre><code>var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]
</code></pre>


<p>最后，我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>


<pre><code>var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles 被推断为 Double[], 等于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
</code></pre>


<p><a name="dictionaries"></a></p>


<h2 id="-">字典</h2>


<p>字典是一种存储相同类型多重数据的存储器。每个值（value）都关联独特的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>


<p>Swift 的字典使用时需要具体规定可以存储键和值类型。不同于 Objective-C 的<code>NSDictionary</code>和<code>NSMutableDictionary</code> 类可以使用任何类型的对象来作键和值并且不提供任何关于这些对象的本质信息。在 Swift 中，在某个特定字典中可以存储的键和值必须提前定义清楚，方法是通过显性类型标注或者类型推断。</p>


<p>Swift 的字典使用<code>Dictionary&lt;KeyType, ValueType&gt;</code>定义,其中<code>KeyType</code>是字典中键的数据类型，<code>ValueType</code>是字典中对应于这些键所存储值的数据类型。</p>


<p><code>KeyType</code>的唯一限制就是可哈希的，这样可以保证它是独一无二的，所有的 Swift 基本类型（例如<code>String</code>，<code>Int</code>， <code>Double</code>和<code>Bool</code>）都是默认可哈希的，并且所有这些类型都可以在字典中当做键使用。未关联值的枚举成员（参见<a href="08_Enumerations.html">枚举</a>）也是默认可哈希的。</p>


<p><a name="dictionary_literals"></a></p>


<h2 id="-">字典字面语句</h2>


<p>我们可以使用字典字面语句来构造字典，他们和我们刚才介绍过的数组字面语句拥有相似语法。一个字典字面语句是一个定义拥有一个或者多个键值对的字典集合的简单语句。</p>


<p>一个键值对是一个<code>key</code>和一个<code>value</code>的结合体。在字典字面语句中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含并且由逗号分割：</p>


<pre><code>[key 1: value 1, key 2: value 2, key 3: value 3]
</code></pre>


<p>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>


<pre><code>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]
</code></pre>


<p><code>airports</code>字典被定义为一种<code>Dictionary&lt;String, String&gt;</code>,它意味着这个字典的键和值都是<code>String</code>类型。</p>


<blockquote>
<p>注意：</p>
<p><code>airports</code>字典被声明为变量（用<code>var</code>关键字）而不是常量（<code>let</code>关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
</blockquote>


<p><code>airports</code>字典使用字典字面语句初始化，包含两个键值对。第一对的键是<code>TYO</code>，值是<code>Tokyo</code>。第二对的键是<code>DUB</code>，值是<code>Dublin</code>。</p>


<p>这个字典语句包含了两个<code>String: String</code>类型的键值对。他们对应<code>airports</code>变量声明的类型（一个只有<code>String</code>键和<code>String</code>值的字典）所以这个字典字面语句是构造两个初始数据项的<code>airport</code>字典。</p>


<p>和数组一样，如果我们使用字面语句构造字典就不用把类型定义清楚。<code>airports</code>的也可以用这种方法简短定义：</p>


<pre><code>var airports = ["TYO": "Tokyo", "DUB": "Dublin"]
</code></pre>


<p>因为这个语句中所有的键和值都分别是相同的数据类型，Swift 可以推断出<code>Dictionary&lt;String, String&gt;</code>是<code>airports</code>字典的正确类型。</p>


<p><a name="accessing_and_modifying_a_dictionary"></a></p>


<h3 id="-">读取和修改字典</h3>


<p>我们可以通过字典的方法和属性来读取和修改字典，或者使用下标语法。和数组一样，我们可以通过字典的只读属性<code>count</code>来获取某个字典的数据项数量：</p>


<pre><code>println("The dictionary of airports contains \(airports.count) items.")
// 打印 "The dictionary of airports contains 2 items."（这个字典有两个数据项）
</code></pre>


<p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个合适类型的 key 作为下标索引，并且分配新的合适类型的值：</p>


<pre><code>airports["LHR"] = "London"
// airports 字典现在有三个数据项
</code></pre>


<p>我们也可以使用下标语法来改变特定键对应的值：</p>


<pre><code>airports["LHR"] = "London Heathrow"
// "LHR"对应的值 被改为 "London Heathrow
</code></pre>


<p>作为另一种下标方法，字典的<code>updateValue(forKey:)</code>方法可以设置或者更新特定键对应的值。就像上面所示的示例，<code>updateValue(forKey:)</code>方法在这个键不存在对应值的时候设置值或者在存在时更新已存在的值。和上面的下标方法不一样，这个方法返回更新值之前的原值。这样方便我们检查更新是否成功。</p>


<p><code>updateValue(forKey:)</code>函数会返回包含一个字典值类型的可选值。举例来说：对于存储<code>String</code>值的字典，这个函数会返回一个<code>String?</code>或者“可选 <code>String</code>”类型的值。如果值存在，则这个可选值值等于被替换的值，否则将会是<code>nil</code>。</p>


<pre><code>if let oldValue = airports.updateValue("Dublin Internation", forKey: "DUB") {
    println("The old value for DUB was \(oldValue).")
}
// 输出 "The old value for DUB was Dublin."（dub原值是dublin）
</code></pre>


<p>我们也可以使用下标语法来在字典中检索特定键对应的值。由于使用一个没有值的键这种情况是有可能发生的，可选类型返回这个键存在的相关值，否则就返回<code>nil</code>：</p>


<pre><code>if let airportName = airports["DUB"] {
    println("The name of the airport is \(airportName).")
} else {
    println("That airport is not in the airports dictionary.")
}
// 打印 "The name of the airport is Dublin INTernation."（机场的名字是都柏林国际）
</code></pre>


<p>我们还可以使用下标语法来通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对：</p>


<pre><code>airports["APL"] = "Apple Internation"
// "Apple Internation"不是真的 APL机场, 删除它
airports["APL"] = nil
// APL现在被移除了
</code></pre>


<p>另外，<code>removeValueForKey</code>方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的value或者在没有值的情况下返回<code>nil</code>：</p>


<pre><code>if let removedValue = airports.removeValueForKey("DUB") {
    println("The removed airport's name is \(removedValue).")
} else {
    println("The airports dictionary does not contain a value for DUB.")
}
// prints "The removed airport's name is Dublin International."
</code></pre>


<p><a name="iterating_over_a_dictionary"></a></p>


<h3 id="-">字典遍历</h3>


<p>我们可以使用<code>for-in</code>循环来遍历某个字典中的键值对。每一个字典中的数据项都由<code>(key, value)</code>元组形式返回，并且我们可以使用暂时性常量或者变量来分解这些元组：</p>


<pre><code>for (airportCode, airportName) in airports {
    prINTln("\(airportCode): \(airportName)")
}
// TYO: Tokyo
// LHR: London Heathrow
</code></pre>


<p><code>for-in</code>循环请参见<a href="05_Control_Flow.html#for_loops">For 循环</a>。</p>


<p>我们也可以通过访问他的<code>keys</code>或者<code>values</code>属性（都是可遍历集合）检索一个字典的键或者值：</p>


<pre><code>for airportCode in airports.keys {
    prINTln("Airport code: \(airportCode)")
}
// Airport code: TYO
// Airport code: LHR

for airportName in airports.values {
    prINTln("Airport name: \(airportName)")
}
// Airport name: Tokyo
// Airport name: London Heathrow
</code></pre>


<p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受<code>Array</code>实例 API 的参数，可以直接使用<code>keys</code>或者<code>values</code>属性直接构造一个新数组：</p>


<pre><code>let airportCodes = Array(airports.keys)
// airportCodes is ["TYO", "LHR"]

let airportNames = Array(airports.values)
// airportNames is ["Tokyo", "London Heathrow"]
</code></pre>


<blockquote>
<p>注意：</p>
<p>Swift 的字典类型是无序集合类型。其中字典键，值，键值对在遍历的时候会重新排列，而且其中顺序是不固定的。</p>
</blockquote>


<p><a name="creating_an_empty_dictionary"></a></p>


<h3 id="-">创建一个空字典</h3>


<p>我们可以像数组一样使用构造语法创建一个空字典：</p>


<pre><code>var namesOfIntegers = Dictionary&lt;Int, String&gt;()
// namesOfIntegers 是一个空的 Dictionary&lt;Int, String&gt;
</code></pre>


<p>这个例子创建了一个<code>Int, String</code>类型的空字典来储存英语对整数的命名。他的键是<code>Int</code>型，值是<code>String</code>型。</p>


<p>如果上下文已经提供了信息类型，我们可以使用空字典字面语句来创建一个空字典，记作<code>[:]</code>（中括号中放一个冒号）：</p>


<pre><code>namesOfIntegers[16] = "sixteen"
// namesOfIntegers 现在包含一个键值对
namesOfIntegers = [:]
// namesOfIntegers 又成为了一个 Int, String类型的空字典
</code></pre>


<blockquote>
<p>注意：</p>
<p>在后台，Swift 的数组和字典都是由泛型集合来实现的，想了解更多泛型和集合信息请参见<a href="22_Generics.html">泛型</a>。</p>
</blockquote>


<p><a name="mutability_of_collections"></a></p>


<h2 id="-">集合的可变性</h2>


<p>数组和字典都是在单个集合中存储可变值。如果我们创建一个数组或者字典并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小。与此相反，如果我们把数组或字典分配成常量，那么他就是不可变的，它的大小不能被改变。</p>


<p>对字典来说，不可变性也意味着我们不能替换其中任何现有键所对应的值。不可变字典的内容在被首次设定之后不能更改。
不可变行对数组来说有一点不同，当然我们不能试着改变任何不可变数组的大小，但是我们·可以重新设定相对现存索引所对应的值。这使得 Swift 数组在大小被固定的时候依然可以做的很棒。</p>


<p>Swift 数组的可变性行为同时影响了数组实例如何被分配和修改，想获取更多信息，请参见<a href="09_Classes_and_Structures.html#assignment_and_copy_behavior_for_collection_types">集合在赋值和复制中的行为</a>。</p>


<blockquote>
<p>注意：</p>
<p>在我们不需要改变数组大小的时候创建不可变数组是很好的习惯。如此 Swift 编译器可以优化我们创建的集合。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift附属脚本]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%99%84%E5%B1%9E%E8%84%9A%E6%9C%AC.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift附属脚本</id>
    <content type="html"><![CDATA[<p><em>附属脚本</em> 可以定义在类（Class）、结构体（structure）和枚举（enumeration）这些目标中，可以认为是访问对象、集合或序列的快捷方式，不需要再调用实例的特定的赋值和访问方法。举例来说，用附属脚本访问一个数组(Array)实例中的元素可以这样写 <code>someArray[index]</code> ，访问字典(Dictionary)实例中的元素可以这样写 <code>someDictionary[key]</code>。</p>


<p>对于同一个目标可以定义多个附属脚本，通过索引值类型的不同来进行重载，而且索引值的个数可以是多个。</p>


<!-- more -->


<blockquote>
<p>译者：这里附属脚本重载在本小节中原文并没有任何演示</p>
</blockquote>


<p><a name="subscript_syntax"></a></p>


<h2 id="-">附属脚本语法</h2>


<p>附属脚本允许你通过在实例后面的方括号中传入一个或者多个的索引值来对实例进行访问和赋值。语法类似于实例方法和计算型属性的混合。与定义实例方法类似，定义附属脚本使用<code>subscript</code>关键字，显式声明入参（一个或多个）和返回类型。与实例方法不同的是附属脚本可以设定为读写或只读。这种方式又有点像计算型属性的getter和setter：</p>


<pre><code>subscript(index: Int) -&gt; Int {
    get {
        // 返回与入参匹配的Int类型的值
    }

    set(newValue) {
        // 执行赋值操作
    }
}
</code></pre>


<p><code>newValue</code>的类型必须和附属脚本定义的返回类型相同。与计算型属性相同的是set的入参声明<code>newValue</code>就算不写，在set代码块中依然可以使用默认的<code>newValue</code>这个变量来访问新赋的值。</p>


<p>与只读计算型属性一样，可以直接将原本应该写在<code>get</code>代码块中的代码写在<code>subscript</code>中：</p>


<pre><code>subscript(index: Int) -&gt; Int {
    // 返回与入参匹配的Int类型的值
}
</code></pre>


<p>下面代码演示了一个在<code>TimesTable</code>结构体中使用只读附属脚本的用法，该结构体用来展示传入整数的<em>n</em>倍。</p>


<pre><code>struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
println("3的6倍是\(threeTimesTable[6])")
// 输出 "3的6倍是18"
</code></pre>


<p>在上例中，通过<code>TimesTable</code>结构体创建了一个用来表示索引值三倍的实例。数值<code>3</code>作为结构体<code>构造函数</code>入参初始化实例成员<code>multiplier</code>。</p>


<p>你可以通过附属脚本来来得到结果，比如<code>threeTimesTable[6]</code>。这句话访问了<code>threeTimesTable</code>的第六个元素，返回<code>18</code>或者<code>6</code>的<code>3</code>倍。</p>


<blockquote>
<p>注意：</p>
<p><code>TimesTable</code>例子是基于一个固定的数学公式。它并不适合开放写权限来对<code>threeTimesTable[someIndex]</code>进行赋值操作，这也是为什么附属脚本只定义为只读的原因。</p>
</blockquote>


<p><a name="subscript_usage"></a></p>


<h2 id="-">附属脚本用法</h2>


<p>根据使用场景不同附属脚本也具有不同的含义。通常附属脚本是用来访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。你可以在你自己特定的类或结构体中自由的实现附属脚本来提供合适的功能。</p>


<p>例如，Swift 的字典（Dictionary）实现了通过附属脚本来对其实例中存放的值进行存取操作。在附属脚本中使用和字典索引相同类型的值，并且把一个字典值类型的值赋值给这个附属脚本来为字典设值：</p>


<pre><code>var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
numberOfLegs["bird"] = 2
</code></pre>


<p>上例定义一个名为<code>numberOfLegs</code>的变量并用一个字典字面量初始化出了包含三对键值的字典实例。<code>numberOfLegs</code>的字典存放值类型推断为<code>Dictionary&lt;String, Int&gt;</code>。字典实例创建完成之后通过附属脚本的方式将整型值<code>2</code>赋值到字典实例的索引为<code>bird</code>的位置中。</p>


<p>更多关于字典（Dictionary）附属脚本的信息请参考<a href="../chapter2/04_Collection_Types.html">读取和修改字典</a></p>


<blockquote>
<p>注意：</p>
<p>Swift 中字典的附属脚本实现中，在<code>get</code>部分返回值是<code>Int?</code>，上例中的<code>numberOfLegs</code>字典通过下边返回的是一个<code>Int?</code>或者说“可选的int”，不是每个字典的索引都能得到一个整型值，对于没有设过值的索引的访问返回的结果就是<code>nil</code>；同样想要从字典实例中删除某个索引下的值也只需要给这个索引赋值为<code>nil</code>即可。</p>
</blockquote>


<p><a name="subscript_options"></a></p>


<h2 id="-">附属脚本选项</h2>


<p>附属脚本允许任意数量的入参索引，并且每个入参类型也没有限制。附属脚本的返回值也可以是任何类型。附属脚本可以使用变量参数和可变参数，但使用写入读出（in-out）参数或给参数设置默认值都是不允许的。</p>


<p>一个类或结构体可以根据自身需要提供多个附属脚本实现，在定义附属脚本时通过入参个类型进行区分，使用附属脚本时会自动匹配合适的附属脚本实现运行，这就是<em>附属脚本的重载</em>。</p>


<p>一个附属脚本入参是最常见的情况，但只要有合适的场景也可以定义多个附属脚本入参。如下例定义了一个<code>Matrix</code>结构体，将呈现一个<code>Double</code>类型的二维矩阵。<code>Matrix</code>结构体的附属脚本需要两个整型参数：</p>


<pre><code>struct Matrix {
    let rows: Int, columns: Int
    var grid: Double[]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            return grid[(row * columns) + column]
        }
        set {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            grid[(row * columns) + columns] = newValue
        }
    }
}
</code></pre>


<p><code>Matrix</code>提供了一个两个入参的构造方法，入参分别是<code>rows</code>和<code>columns</code>，创建了一个足够容纳<code>rows * columns</code>个数的<code>Double</code>类型数组。为了存储，将数组的大小和数组每个元素初始值0.0，都传入数组的构造方法中来创建一个正确大小的新数组。关于数组的构造方法和析构方法请参考<a href="../chapter2/04_Collection_Types.html">创建并且构造一个数组</a>。</p>


<p>你可以通过传入合适的<code>row</code>和<code>column</code>的数量来构造一个新的<code>Matrix</code>实例：</p>


<pre><code>var matrix = Matrix(rows: 2, columns: 2)
</code></pre>


<p>上例中创建了一个新的两行两列的<code>Matrix</code>实例。在阅读顺序从左上到右下的<code>Matrix</code>实例中的数组实例<code>grid</code>是矩阵二维数组的扁平化存储：</p>


<pre><code>// 示意图
grid = [0.0, 0.0, 0.0, 0.0]

        col0     col1
row0   [0.0,     0.0,
row1    0.0,     0.0]
</code></pre>


<p>将值赋给带有<code>row</code>和<code>column</code>附属脚本的<code>matrix</code>实例表达式可以完成赋值操作，附属脚本入参使用逗号分割</p>


<pre><code>matrix[0, 1] = 1.5
matrix[1, 0] = 3.2
</code></pre>


<p>上面两条语句分别<code>让matrix</code>的右上值为 1.5，坐下值为 3.2：</p>


<pre><code>[0.0, 1.5,
 3.2, 0.0]
</code></pre>


<p><code>Matrix</code>附属脚本的<code>getter</code>和<code>setter</code>中同时调用了附属脚本入参的<code>row</code>和<code>column</code>是否有效的判断。为了方便进行断言，<code>Matrix</code>包含了一个名为<code>indexIsValid</code>的成员方法，用来确认入参的<code>row</code>或<code>column</code>值是否会造成数组越界：</p>


<pre><code>func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
    return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
}
</code></pre>


<p>断言在附属脚本越界时触发：</p>


<pre><code>let someValue = matrix[2, 2]
// 断言将会触发，因为 [2, 2] 已经超过了matrix的最大长度
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift闭包]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%97%AD%E5%8C%85.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift闭包</id>
    <content type="html"><![CDATA[<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。
Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 lambdas 函数比较相似。</p>


<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。
这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。</p>


<!-- more -->


<blockquote>
<p>注意：</p>
<p>如果您不熟悉捕获（capturing）这个概念也不用担心，您可以在 <a href="#capturing_values">值捕获</a> 章节对其进行详细了解。</p>
</blockquote>


<p>在<a href="../chapter2/06_Function.html">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：</p>


<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>


<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>


<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随（Trailing）闭包语法</li>
</ul>


<p><a name="closure_expressions"></a></p>


<h2 id="-closure-expressions-">闭包表达式（Closure Expressions）</h2>


<p><a href="../chapter2/06_Function.html#nested_function">嵌套函数</a> 是一个在较复杂函数中方便进行命名和定义自包含代码模块的方式。
当然，有时候撰写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在您处理一些函数并需要将另外一些函数作为该函数的参数时。</p>


<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。
闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。
下面闭包表达式的例子通过使用几次迭代展示了<code>sort</code>函数定义和语法优化的方式。
每一次迭代都用更简洁的方式描述了相同的功能。</p>


<p><a name="the_sort_function"></a></p>


<h3 id="sort-the-sort-function-">sort 函数（The Sort Function）</h3>


<p>Swift 标准库提供了<code>sort</code>函数，会根据您提供的基于输出类型排序的闭包函数将已知类型数组中的值进行排序。
一旦排序完成，函数会返回一个与原数组大小相同的新数组，该数组中包含已经正确排序的同类型元素。</p>


<p>下面的闭包表达式示例使用<code>sort</code>函数对一个<code>String</code>类型的数组进行字母逆序排序，以下是初始数组值：</p>


<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</code></pre>


<p><code>sort</code>函数需要传入两个参数：</p>


<ul>
<li>已知类型的数组</li>
<li>闭包函数，该闭包函数需要传入与数组类型相同的两个值，并返回一个布尔类型值来告诉<code>sort</code>函数当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回<code>true</code>，反之返回<code>false</code>。</li>
</ul>


<p>该例子对一个<code>String</code>类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p>


<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为<code>sort</code>函数的第二个参数传入：</p>


<pre><code>func backwards(s1: String, s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversed = sort(names, backwards)
// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
</code></pre>


<p>如果第一个字符串 (<code>s1</code>) 大于第二个字符串 (<code>s2</code>)，<code>backwards</code>函数返回<code>true</code>，表示在新的数组中<code>s1</code>应该出现在<code>s2</code>前。
对于字符串中的字符来说，“大于” 表示 “按照字母顺序较晚出现”。
这意味着字母<code>"B"</code>大于字母<code>"A"</code>，字符串<code>"Tom"</code>大于字符串<code>"Tim"</code>。
其将进行字母逆序排序，<code>"Barry"</code>将会排在<code>"Alex"</code>之后。</p>


<p>然而，这是一个相当冗长的方式，本质上只是写了一个单表达式函数 (a &gt; b)。
在下面的例子中，利用闭合表达式语法可以更好的构造一个内联排序闭包。</p>


<p><a name="closure_expression_syntax"></a></p>


<h3 id="-closure-expression-syntax-">闭包表达式语法（Closure Expression Syntax）</h3>


<p>闭包表达式语法有如下一般形式：</p>


<pre><code>{ (parameters) -&gt; returnType in
    statements
}
</code></pre>


<p>闭包表达式语法可以使用常量、变量和<code>inout</code>类型作为参数，不提供默认值。
也可以在参数列表的最后使用可变参数。
元组也可以作为参数和返回值。</p>


<p>下面的例子展示了之前<code>backwards</code>函数对应的闭包表达式版本的代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
    })
</code></pre>


<p>需要注意的是内联闭包参数和返回值类型声明与<code>backwards</code>函数类型声明相同。
在这两种方式中，都写成了<code>(s1: String, s2: String) -&gt; Bool</code>。
然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>


<p>闭包的函数体部分由关键字<code>in</code>引入。
该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>


<p>因为这个闭包的函数体部分如此短以至于可以将其改写成一行代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )
</code></pre>


<p>这说明<code>sort</code>函数的整体调用保持不变，一对圆括号仍然包裹住了函数中整个参数集合。而其中一个参数现在变成了内联闭包（相比于<code>backwards</code>版本的代码）。</p>


<p><a name="inferring_type_from_context"></a></p>


<h3 id="-inferring-type-from-context-">根据上下文推断类型（Inferring Type From Context）</h3>


<p>因为排序闭包函数是作为<code>sort</code>函数的参数进行传入的，Swift可以推断其参数和返回值的类型。
<code>sort</code>期望第二个参数是类型为<code>(String, String) -&gt; Bool</code>的函数，因此实际上<code>String</code>,<code>String</code>和<code>Bool</code>类型并不需要作为闭包表达式定义中的一部分。
因为所有的类型都可以被正确推断，返回箭头 (<code>-&gt;</code>) 和围绕在参数周围的括号也可以被省略：</p>


<pre><code>reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )
</code></pre>


<p>实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数时，都可以推断出闭包的参数和返回值类型，这意味着您几乎不需要利用完整格式构造任何内联闭包。</p>


<p><a name="implicit_returns_from_single_expression_closures"></a></p>


<h3 id="-implicit-return-from-single-expression-clossures-">单表达式闭包隐式返回（Implicit Return From Single-Expression Clossures）</h3>


<p>单行表达式闭包可以通过隐藏<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>


<pre><code>reversed = sort(names, { s1, s2 in s1 &gt; s2 } )
</code></pre>


<p>在这个例子中，<code>sort</code>函数的第二个参数函数类型明确了闭包必须返回一个<code>Bool</code>类型值。
因为闭包函数体只包含了一个单一表达式 (<code>s1 &gt; s2</code>)，该表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略。</p>


<p><a name="shorthand_argument_names"></a></p>


<h3 id="-shorthand-argument-names-">参数名称缩写（Shorthand Argument Names）</h3>


<p>Swift 自动为内联函数提供了参数名称缩写功能，您可以直接通过<code>$0</code>,<code>$1</code>,<code>$2</code>来顺序调用闭包的参数。</p>


<p>如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。
<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>


<pre><code>reversed = sort(names, { $0 &gt; $1 } )
</code></pre>


<p>在这个例子中，<code>$0</code>和<code>$1</code>表示闭包中第一个和第二个<code>String</code>类型的参数。</p>


<p><a name="operator_functions"></a></p>


<h3 id="-operator-functions-">运算符函数（Operator Functions）</h3>


<p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。
Swift 的<code>String</code>类型定义了关于大于号 (<code>&gt;</code>) 的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。
而这正好与<code>sort</code>函数的第二个参数需要的函数类型相符合。
因此，您可以简单地传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现：</p>


<pre><code>reversed = sort(names, &gt;)
</code></pre>


<p>更多关于运算符表达式的内容请查看 <a href="../chapter2/23_Advanced_Operators.html#operator_functions">运算符函数</a>。</p>


<p><a name="trailing_closures"></a></p>


<h2 id="-trailing-closures-">尾随闭包（Trailing Closures）</h2>


<p>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。
尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</p>


<pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; ()) {
    // 函数体部分
}

// 以下是不使用尾随闭包进行函数调用

someFunctionThatTakesAClosure({
    // 闭包主体部分
    })

// 以下是使用尾随闭包进行函数调用

someFunctionThatTakesAClosure() {
    // 闭包主体部分
}
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把<code>()</code>省略掉。</p>
</blockquote>


<p>在上例中作为<code>sort</code>函数参数的字符串排序闭包可以改写为：</p>


<pre><code>reversed = sort(names) { $0 &gt; $1 }
</code></pre>


<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。
举例来说，Swift 的<code>Array</code>类型有一个<code>map</code>方法，其获取一个闭包表达式作为其唯一参数。
数组中的每一个元素调用一次该闭包函数，并返回该元素所映射的值(也可以是不同类型的值)。
具体的映射方式和返回值类型由闭包来指定。</p>


<p>当提供给数组闭包函数后，<code>map</code>方法将返回一个新的数组，数组中包含了与原数组一一对应的映射后的值。</p>


<p>下例介绍了如何在<code>map</code>方法中使用尾随闭包将<code>Int</code>类型数组<code>[16,58,510]</code>转换为包含对应<code>String</code>类型的数组<code>["OneSix", "FiveEight", "FiveOneZero"]</code>:</p>


<pre><code>let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
</code></pre>


<p>如上代码创建了一个数字位和他们名字映射的英文版本字典。
同时定义了一个准备转换为字符串的整型数组。</p>


<p>您现在可以通过传递一个尾随闭包给<code>numbers</code>的<code>map</code>方法来创建对应的字符串版本数组。
需要注意的时调用<code>numbers.map</code>不需要在<code>map</code>后面包含任何括号，因为其只需要传递闭包表达式这一个参数，并且该闭包表达式参数通过尾随方式进行撰写：</p>


<pre><code>let strings = numbers.map {
    (var number) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
// strings 常量被推断为字符串类型数组，即 String[]
// 其值为 ["OneSix", "FiveEight", "FiveOneZero"]
</code></pre>


<p><code>map</code>在数组中为每一个元素调用了闭包表达式。
您不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行推断。</p>


<p>闭包<code>number</code>参数被声明为一个变量参数（变量的具体描述请参看<a href="../chapter2/06_Functions.html#closure_expression_syntax">常量参数和变量参数</a>），因此可以在闭包函数体内对其进行修改。
闭包表达式制定了返回类型为<code>String</code>，以表明存储映射值的新数组类型为<code>String</code>。</p>


<p>闭包表达式在每次被调用的时候创建了一个字符串并返回。
其使用求余运算符 (number % 10) 计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。</p>


<blockquote>
<p>注意：</p>
<p>字典<code>digitNames</code>下标后跟着一个叹号 (!)，因为字典下标返回一个可选值 (optional value)，表明即使该 key 不存在也不会查找失败。
在上例中，它保证了<code>number % 10</code>可以总是作为一个<code>digitNames</code>字典的有效下标 key。
因此叹号可以用于强制解析 (force-unwrap) 存储在可选下标项中的<code>String</code>类型值。</p>
</blockquote>


<p>从<code>digitNames</code>字典中获取的字符串被添加到输出的前部，逆序建立了一个字符串版本的数字。
（在表达式<code>number % 10</code>中，如果number为16，则返回6，58返回8，510返回0）。</p>


<p><code>number</code>变量之后除以10。
因为其是整数，在计算过程中未除尽部分被忽略。
因此 16变成了1，58变成了5，510变成了51。</p>


<p>整个过程重复进行，直到<code>number /= 10</code>为0，这时闭包会将字符串输出，而<code>map</code>函数则会将字符串添加到所映射的数组中。</p>


<p>上例中尾随闭包语法在函数后整洁封装了具体的闭包功能，而不再需要将整个闭包包裹在<code>map</code>函数的括号内。</p>


<p><a name="capturing_values"></a></p>


<h2 id="-capturing-values-">捕获值（Capturing Values）</h2>


<p>闭包可以在其定义的上下文中捕获常量或变量。
即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>


<p>Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>


<p>下例为一个叫做<code>makeIncrementor</code>的函数，其包含了一个叫做<code>incrementor</code>嵌套函数。
嵌套函数<code>incrementor</code>从上下文中捕获了两个值，<code>runningTotal</code>和<code>amount</code>。
之后<code>makeIncrementor</code>将<code>incrementor</code>作为闭包返回。
每次调用<code>incrementor</code>时，其会以<code>amount</code>作为增量增加<code>runningTotal</code>的值。</p>


<pre><code>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}
</code></pre>


<p><code>makeIncrementor</code>返回类型为<code>() -&gt; Int</code>。
这意味着其返回的是一个函数，而不是一个简单类型值。
该函数在每次调用时不接受参数只返回一个<code>Int</code>类型的值。
关于函数返回其他函数的内容，请查看<a href="../chapter2/06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>


<p><code>makeIncrementor</code>函数定义了一个整型变量<code>runningTotal</code>(初始为0) 用来存储当前跑步总数。
该值通过<code>incrementor</code>返回。</p>


<p><code>makeIncrementor</code>有一个<code>Int</code>类型的参数，其外部命名为<code>forIncrement</code>， 内部命名为<code>amount</code>，表示每次<code>incrementor</code>被调用时<code>runningTotal</code>将要增加的量。</p>


<p><code>incrementor</code>函数用来执行实际的增加操作。
该函数简单地使<code>runningTotal</code>增加<code>amount</code>，并将其返回。</p>


<p>如果我们单独看这个函数，会发现看上去不同寻常：</p>


<pre><code>func incrementor() -&gt; Int {
    runningTotal += amount
    return runningTotal
}
</code></pre>


<p><code>incrementor</code>函数并没有获取任何参数，但是在函数体内访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为其通过捕获在包含它的函数体内已经存在的<code>runningTotal</code>和<code>amount</code>变量而实现。</p>


<p>由于没有修改<code>amount</code>变量，<code>incrementor</code>实际上捕获并存储了该变量的一个副本，而该副本随着<code>incrementor</code>一同被存储。</p>


<p>然而，因为每次调用该函数的时候都会修改<code>runningTotal</code>的值，<code>incrementor</code>捕获了当前<code>runningTotal</code>变量的引用，而不是仅仅复制该变量的初始值。捕获一个引用保证了当<code>makeIncrementor</code>结束时候并不会消失，也保证了当下一次执行<code>incrementor</code>函数时，<code>runningTotal</code>可以继续增加。</p>


<blockquote>
<p>注意：</p>
<p>Swift 会决定捕获引用还是拷贝值。
您不需要标注<code>amount</code>或者<code>runningTotal</code>来声明在嵌入的<code>incrementor</code>函数中的使用方式。
Swift 同时也处理<code>runingTotal</code>变量的内存管理操作，如果不再被<code>incrementor</code>函数使用，则会被清除。</p>
</blockquote>


<p>下面代码为一个使用<code>makeIncrementor</code>的例子：</p>


<pre><code>let incrementByTen = makeIncrementor(forIncrement: 10)
</code></pre>


<p>该例子定义了一个叫做<code>incrementByTen</code>的常量，该常量指向一个每次调用会加10的<code>incrementor</code>函数。
调用这个函数多次可以得到以下结果：</p>


<pre><code>incrementByTen()
// 返回的值为10
incrementByTen()
// 返回的值为20
incrementByTen()
// 返回的值为30
</code></pre>


<p>如果您创建了另一个<code>incrementor</code>，其会有一个属于自己的独立的<code>runningTotal</code>变量的引用。
下面的例子中，<code>incrementBySevne</code>捕获了一个新的<code>runningTotal</code>变量，该变量和<code>incrementByTen</code>中捕获的变量没有任何联系：</p>


<pre><code>let incrementBySeven = makeIncrementor(forIncrement: 7)
incrementBySeven()
// 返回的值为7
incrementByTen()
// 返回的值为40
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果您闭包分配给一个类实例的属性，并且该闭包通过指向该实例或其成员来捕获了该实例，您将创建一个在闭包和实例间的强引用环。
Swift 使用捕获列表来打破这种强引用环。更多信息，请参考 <a href="../chapter2/16_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>


<p><a name="closures_are_reference_types"></a></p>


<h2 id="-closures-are-reference-types-">闭包是引用类型（Closures Are Reference Types）</h2>


<p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。
这是因为函数和闭包都是引用类型。</p>


<p>无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。
上面的例子中，<code>incrementByTen</code>指向闭包的引用是一个常量，而并非闭包内容本身。</p>


<p>这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包：</p>


<pre><code>let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// 返回的值为50
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift基础]]></title>
    <link href="http://baxiang123.com//blog/Swift%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift语言简介</id>
    <content type="html"><![CDATA[<h2>常量和变量</h2>


<p>常量和变量把一个名字（比如maximumNumberOfLoginAttempts或者welcomeMessage）和一个指定类型的值（比如数字10或者字符串&#8221;Hello&#8221;）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>

<p>Swift 是 iOS 和 OS X 应用开发的一门新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>


<!-- more -->


<p>Swift 的类型是在 C 和 Objective-C 的基础上提出的，<code>Int</code>是整型；<code>Double</code>和<code>Float</code>是浮点型；<code>Bool</code>是布尔型；<code>String</code>是字符串。Swift 还有两个有用的集合类型，<code>Array</code>和<code>Dictionary</code>，请参考<a href="04_Collection_Types.html">集合类型</a>。</p>


<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，值不可变的变量有着广泛的应用，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更好地表达你的意图。</p>


<p>除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>


<p>Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用<code>nil</code>，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的<code>nil</code>指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>


<p>Swift 是一个类型安全的语言，可选就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个<code>String</code>，类型安全会阻止你不小心传入一个<code>Int</code>。你可以在开发阶段尽早发现并修正错误。</p>


<p><a name="constants_and_variables"></a></p>


<h2 id="-">常量和变量</h2>


<p>常量和变量把一个名字（比如<code>maximumNumberOfLoginAttempts</code>或者<code>welcomeMessage</code>）和一个指定类型的值（比如数字<code>10</code>或者字符串<code>"Hello"</code>）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>


<h3 id="-">声明常量和变量</h3>


<p>常量和变量必须在使用前声明，用<code>let</code>来声明常量，用<code>var</code>来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：</p>


<pre><code>let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
</code></pre>


<p>这两行代码可以被理解为：</p>


<p>“声明一个名字是<code>maximumNumberOfLoginAttempts</code>的新常量，并给它一个值<code>10</code>。然后，声明一个名字是<code>currentLoginAttempt</code>的变量并将它的值初始化为<code>0</code>.”</p>


<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>


<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>


<pre><code>var x = 0.0, y = 0.0, z = 0.0
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果你的代码中有不需要改变的值，请使用<code>let</code>关键字将它声明为常量。只将需要改变的值声明为变量。</p>
</blockquote>


<h3 id="-">类型标注</h3>


<p>当你声明常量或者变量的时候可以加上<em>类型标注(type annotation)</em>，说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>


<p>这个例子给<code>welcomeMessage</code>变量添加了类型标注，表示这个变量可以存储<code>String</code>类型的值：</p>


<pre><code>var welcomeMessage: String
</code></pre>


<p>声明中的冒号代表着“是&#8230;类型”，所以这行代码可以被理解为：</p>


<p>“声明一个类型为<code>String</code>，名字为<code>welcomeMessage</code>的变量。”</p>


<p>“类型为<code>String</code>”的意思是“可以存储任意<code>String</code>类型的值。”</p>


<p><code>welcomeMessage</code>变量现在可以被设置成任意字符串：</p>


<pre><code>welcomeMessage = "Hello"
</code></pre>


<blockquote>
<p>注意：</p>
<p>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。在上面的例子中，没有给<code>welcomeMessage</code>赋初始值，所以变量<code>welcomeMessage</code>的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
</blockquote>


<h3 id="-">常量和变量的命名</h3>


<p>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：</p>


<pre><code>let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
</code></pre>


<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>


<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</p>


<blockquote>
<p>注意：</p>
<p>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。</p>
</blockquote>


<p>你可以更改现有的变量值为其他同类型的值，在下面的例子中，<code>friendlyWelcome</code>的值从<code>"Hello!"</code>改为了<code>"Bonjour!"</code>:</p>


<pre><code>var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome 现在是 "Bonjour!"
</code></pre>


<p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>


<pre><code>let languageName = "Swift"
languageName = "Swift++"
// 这会报编译时错误 - languageName 不可改变
</code></pre>


<h3 id="-">输出常量和变量</h3>


<p>你可以用<code>println</code>函数来输出当前常量或变量的值:</p>


<pre><code>println(friendlyWelcome)
// 输出 "Bonjour!"
</code></pre>


<p><code>println</code>是一个用来输出的全局函数，输出的内容会在最后换行。如果你用 Xcode，<code>println</code>将会输出内容到“console”面板上。(另一种函数叫<code>print</code>，唯一区别是在输出内容最后不会换行。)</p>


<p><code>println</code>函数输出传入的<code>String</code>值：</p>


<pre><code>println("This is a string")
// 输出 "This is a string"
</code></pre>


<p>与 Cocoa 里的<code>NSLog</code>函数类似的是，<code>println</code>函数可以输出更复杂的信息。这些信息可以包含当前常量和变量的值。</p>


<p>Swift 用<em>字符串插值（string interpolation）</em>的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>


<pre><code>println("The current value of friendlyWelcome is \(friendlyWelcome)")
// 输出 "The current value of friendlyWelcome is Bonjour!
</code></pre>


<blockquote>
<p>注意：</p>
<p>字符串插值所有可用的选项，请参考<a href="03_Strings_and_Characters.html#string_interpolation">字符串插值</a>。</p>
</blockquote>


<p><a name="comments"></a></p>


<h2 id="-">注释</h2>


<p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>


<p>Swift 中的注释与C 语言的注释非常相似。单行注释以双正斜杠作(<code>//</code>)为起始标记:</p>


<pre><code>// 这是一个注释
</code></pre>


<p>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号(<code>/*</code>)，终止标记为一个星号后跟随单个正斜杠(<code>*/</code>):</p>


<pre><code>/* 这是一个,
多行注释 */
</code></pre>


<p>与C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：</p>


<pre><code>/* 这是第一个多行注释的开头
/* 这是第二个被嵌套的多行注释 */
这是第一个多行注释的结尾 */
</code></pre>


<p>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>


<p><a name="semicolons"></a></p>


<h2 id="-">分号</h2>


<p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（<code>;</code>），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：</p>


<pre><code>let cat = "🐱"; println(cat)
// 输出 "🐱"
</code></pre>


<p><a name="integers"></a></p>


<h2 id="-">整数</h2>


<p>整数就是没有小数部分的数字，比如<code>42</code>和<code>-23</code>。整数可以是<code>有符号</code>（正、负、零）或者<code>无符号</code>（正、零）。</p>


<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是<code>UInt8</code>，32位有符号整数类型是<code>Int32</code>。就像 Swift 的其他类型一样，整数类型采用大写命名法。</p>


<h3 id="-">整数范围</h3>


<p>你可以访问不同整数类型的<code>min</code>和<code>max</code>属性来获取对应类型的最大值和最小值：</p>


<pre><code>let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型的最小值
let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型的最大值
</code></pre>


<h3 id="int">Int</h3>


<p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型<code>Int</code>，长度与当前平台的原生字长相同：</p>


<ul>
<li>在32位平台上，<code>Int</code>和<code>Int32</code>长度相同。</li>
<li>在64位平台上，<code>Int</code>和<code>Int64</code>长度相同。</li>
</ul>


<p>除非你需要特定长度的整数，一般来说使用<code>Int</code>就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，<code>Int</code>可以存储的整数范围也可以达到<code>-2147483648</code>~<code>2147483647</code>，大多数时候这已经足够大了。</p>


<h3 id="uint">UInt</h3>


<p>Swift 也提供了一个特殊的无符号类型<code>UInt</code>，长度与当前平台的原生字长相同：</p>


<ul>
<li>在32位平台上，<code>UInt</code>和<code>UInt32</code>长度相同。</li>
<li>在64位平台上，<code>UInt</code>和<code>UInt64</code>长度相同。</li>
</ul>


<blockquote>
<p>注意：</p>
<p>尽量不要使用<code>UInt</code>，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推测，请参考<a href="#type_safety_and_type_inference">类型安全和类型推测</a>。</p>
</blockquote>


<p><a name="floating-point_numbers"></a></p>


<h2 id="-">浮点数</h2>


<p>浮点数是有小数部分的数字，比如<code>3.14159</code>，<code>0.1</code>和<code>-273.15</code>。</p>


<p>浮点类型比整数类型表示的范围更大，可以存储比<code>Int</code>类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>


<ul>
<li><code>Double</code>表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li><code>Float</code>表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>


<blockquote>
<p>注意：</p>
<p><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。</p>
</blockquote>


<p><a name="type_safety_and_type_inference"></a></p>


<h2 id="-">类型安全和类型推测</h2>


<p>Swift 是一个<em>类型安全(type safe )</em>的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个<code>String</code>，你绝对不可能不小心传进去一个<code>Int</code>。</p>


<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行<em>类型检查(type checks)</em>，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>


<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用<em>类型推测(type inference)</em>来选择合适的类型。有了类型推测，编译器可以在编译代码的时候自动推测出表达式的类型。原理很简单，只要检查你赋的值即可。</p>


<p>因为有类型推测，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>


<p>当你声明常量或者变量并赋初值的时候类型推测非常有用。当你在声明常量或者变量的时候赋给它们一个<em>字面量(literal value 或 literal)</em>即可触发类型推测。（字面量就是会直接出现在你代码中的值，比如<code>42</code>和<code>3.14159</code>。）</p>


<p>例如，如果你给一个新常量赋值<code>42</code>并且没有标明类型，Swift 可以推测出常量类型是<code>Int</code>，因为你给它赋的初始值看起来像一个整数：</p>


<pre><code>let meaningOfLife = 42
// meaningOfLife 会被推测为 Int 类型
</code></pre>


<p>同理，如果你没有给浮点字面量标明类型，Swift 会推测你想要的是<code>Double</code>：</p>


<pre><code>let pi = 3.14159
// pi 会被推测为 Double 类型
</code></pre>


<p>当推测浮点数的类型时，Swift 总是会选择<code>Double</code>而不是<code>Float</code>。</p>


<p>如果表达式中同时出现了整数和浮点数，会被推测为<code>Double</code>类型：</p>


<pre><code>let anotherPi = 3 + 0.14159
// anotherPi 会被推测为 Double 类型
</code></pre>


<p>原始值<code>3</code>没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推测为<code>Double</code>类型。</p>


<p><a name="numeric_literals"></a></p>


<h2 id="-">数值型字面量</h2>


<p>整数字面量可以被写作：</p>


<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是<code>0b</code></li>
<li>一个八进制数，前缀是<code>0o</code></li>
<li>一个十六进制数，前缀是<code>0x</code></li>
</ul>


<p>下面的所有整数字面量的十进制值都是<code>17</code>:</p>


<pre><code>let decimalInteger = 17
let binaryInteger = 0b10001       // 二进制的17
let octalInteger = 0o21           // 八进制的17
let hexadecimalInteger = 0x11     // 十六进制的17
</code></pre>


<p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是<code>0x</code>）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。浮点字面量还有一个可选的<em>指数(exponent)</em>，在十进制浮点数中通过大写或者小写的<code>e</code>来指定，在十六进制浮点数中通过大写或者小写的<code>p</code>来指定。</p>


<p>如果一个十进制数的指数为<code>exp</code>，那这个数相当于基数和<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-7-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-57"><span style="display: inline-block; position: relative; width: 2.116em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(3.115em 1000em 4.184em -0.399em); top: -4em; left: 0em;"><span class="mrow" id="MathJax-Span-58"><span class="msubsup" id="MathJax-Span-59"><span style="display: inline-block; position: relative; width: 2.116em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-60" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-61"><span class="mrow" id="MathJax-Span-62"><span class="mi" id="MathJax-Span-63" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-64" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-65" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">p</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.061em; vertical-align: -0.089em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-7">10^{exp}</script>的乘积：</p>


<ul>
<li><code>1.25e2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-8-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-66"><span style="display: inline-block; position: relative; width: 4.365em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-67"><span class="mn" id="MathJax-Span-68" style="font-family: STIXGeneral-Regular;">1.25</span><span class="mo" id="MathJax-Span-69" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-70" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.492em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-71" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-72"><span class="mrow" id="MathJax-Span-73"><span class="mn" id="MathJax-Span-74" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-8">1.25 × 10^{2}</script>，等于 <code>125.0</code>。</li>
<li><code>1.25e-2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-9-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-75"><span style="display: inline-block; position: relative; width: 4.819em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-76"><span class="mn" id="MathJax-Span-77" style="font-family: STIXGeneral-Regular;">1.25</span><span class="mo" id="MathJax-Span-78" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-79" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.946em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-80" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-81"><span class="mrow" id="MathJax-Span-82"><span class="mo" id="MathJax-Span-83" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">−</span><span class="mn" id="MathJax-Span-84" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-9">1.25 × 10^{-2}</script>，等于 <code>0.0125</code>。</li>
</ul>


<p>如果一个十六进制数的指数为<code>exp</code>，那这个数相当于基数和<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-10-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-85"><span style="display: inline-block; position: relative; width: 1.606em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(3.115em 1000em 4.17em -0.481em); top: -4em; left: 0em;"><span class="mrow" id="MathJax-Span-86"><span class="msubsup" id="MathJax-Span-87"><span style="display: inline-block; position: relative; width: 1.606em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-88" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-89"><span class="mrow" id="MathJax-Span-90"><span class="mi" id="MathJax-Span-91" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-92" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-93" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">p</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.044em; vertical-align: -0.071em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-10">2^{exp}</script>的乘积：</p>


<ul>
<li><code>0xFp2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-11-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-94"><span style="display: inline-block; position: relative; width: 3.118em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-95"><span class="mn" id="MathJax-Span-96" style="font-family: STIXGeneral-Regular;">15</span><span class="mo" id="MathJax-Span-97" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-98" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 0.982em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-99" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-100"><span class="mrow" id="MathJax-Span-101"><span class="mn" id="MathJax-Span-102" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-11">15 × 2^{2}</script>，等于 <code>60.0</code>。</li>
<li><code>0xFp-2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-12-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-103"><span style="display: inline-block; position: relative; width: 3.571em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-104"><span class="mn" id="MathJax-Span-105" style="font-family: STIXGeneral-Regular;">15</span><span class="mo" id="MathJax-Span-106" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-107" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.436em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-108" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-109"><span class="mrow" id="MathJax-Span-110"><span class="mo" id="MathJax-Span-111" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">−</span><span class="mn" id="MathJax-Span-112" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-12">15 × 2^{-2}</script>，等于 <code>3.75</code>。</li>
</ul>


<p>下面的这些浮点字面量都等于十进制的<code>12.1875</code>：</p>


<pre><code>let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
</code></pre>


<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>


<pre><code>let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>


<p><a name="numeric_type_conversion"></a></p>


<h2 id="-">数值型类型转换</h2>


<p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用<code>Int</code>类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推测。
只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>


<h3 id="-">整数转换</h3>


<p>不同整数类型的变量和常量可以存储不同范围的数字。<code>Int8</code>类型的常量或者变量可以存储的数字范围是<code>-128</code>~<code>127</code>，而<code>UInt8</code>类型的常量或者变量能存储的数字范围是<code>0</code>~<code>255</code>。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：</p>


<pre><code>let cannotBeNegative: UInt8 = -1
// UInt8 类型不能存储负数，所以会报错
let tooBig: Int8 = Int8.max + 1
// Int8 类型不能存储超过最大值的数，所以会报错
</code></pre>


<p>由于每中整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>


<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量<code>twoThousand</code>是<code>UInt16</code>类型，然而常量<code>one</code>是<code>Uint8</code>类型。它们不能直接相加，因为它们类型不同。所以要调用<code>UInt16(one)</code>来创建一个新的<code>UInt16</code>数字并用<code>one</code>的值来初始化，然后使用这个新数字来计算：</p>


<pre><code>let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>


<p>现在两个数字的类型都是<code>UInt16</code>，可以进行相加。目标常量<code>twoThousandAndOne</code>的类型被推测为<code>UInt16</code>，因为它是两个<code>UInt16</code>值的和。</p>


<p><code>SomeType(ofInitialValue)</code>是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，<code>UInt16</code>有一个构造器，可以接受一个<code>UInt8</code>类型的值，所以这个构造器可以用现有的<code>UInt8</code>来创建一个新的<code>UInt16</code>。注意，你并不能传入任意类型的值，只能传入<code>UInt16</code>内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考<a href="20_Extensions.html">扩展</a>。</p>


<h3 id="-">整数和浮点数转换</h3>


<p>整数和浮点数的转换必须显式指定类型：</p>


<pre><code>let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi 等于 3.14159，所以被推测为 Double 类型
</code></pre>


<p>这个例子中，常量<code>three</code>的值被用来创建一个<code>Double</code>类型的值，所以加号两边的数类型相同。如果不进行转换，两者无法相加。</p>


<p>浮点数到整数的反向转换同样行，整数类型可以用<code>Double</code>或者<code>Float</code>类型来初始化：</p>


<pre><code>let integerPi = Int(pi)
// integerPi 等于 3，所以被推测为 Int 类型
</code></pre>


<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说<code>4.75</code>会变成<code>4</code>，<code>-3.9</code>会变成<code>-3</code>。</p>


<blockquote>
<p>注意：</p>
<p>结合数字类常量和变量不同于结合数字类字面量。字面量<code>3</code>可以直接和字面量<code>0.14159</code>相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。</p>
</blockquote>


<p><a name="type_aliases"></a></p>


<h2 id="-">类型别名</h2>


<p><em>类型别名(type aliases)</em>就是给现有类型定义另一个名字。你可以使用<code>typealias</code>关键字来定义类型别名。</p>


<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p>


<pre><code>typealias AudioSample = UInt16
</code></pre>


<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>


<pre><code>var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound 现在是 0
</code></pre>


<p>本例中，<code>AudioSample</code>被定义为<code>UInt16</code>的一个别名。因为它是别名，<code>AudioSample.min</code>实际上是<code>UInt16.min</code>，所以会给<code>maxAmplitudeFound</code>赋一个初值<code>0</code>。</p>


<p><a name="booleans"></a></p>


<h2 id="-">布尔值</h2>


<p>Swift 有一个基本的<em>布尔(Boolean)</em>类型，叫做<code>Bool</code>。布尔值指<em>逻辑上的(logical)</em>，因为它们只能是真或者假。Swift 有两个布尔常量，<code>true</code>和<code>false</code>：</p>


<pre><code>let orangesAreOrange = true
let turnipsAreDelicious = false
</code></pre>


<p><code>orangesAreOrange</code>和<code>turnipsAreDelicious</code>的类型会被推测为<code>Bool</code>，因为它们的初值是布尔字面量。就像之前提到的<code>Int</code>和<code>Double</code>一样，如果你创建变量的时候给它们赋值<code>true</code>或者<code>false</code>，那你不需要将常量或者变量声明为<code>Bool</code>类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推测，这让 Swift 代码更加简洁并且可读性更高。</p>


<p>当你编写条件语句比如<code>if</code>语句的时候，布尔值非常有用：</p>


<pre><code>if turnipsAreDelicious {
    println("Mmm, tasty turnips!")
} else {
    println("Eww, turnips are horrible.")
}
// 输出 "Eww, turnips are horrible."
</code></pre>


<p>条件语句，例如<code>if</code>，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<p>如果你在需要使用<code>Bool</code>类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>


<pre><code>let i = 1
if i {
    // 这个例子不会通过编译，会报错
}
</code></pre>


<p>然而，下面的例子是合法的：</p>


<pre><code>let i = 1
if i == 1 {
    // 这个例子会编译成功
}
</code></pre>


<p><code>i == 1</code>的比较结果是<code>Bool</code>类型，所以第二个例子可以通过类型检查。类似<code>i == 1</code>这样的比较，请参考<a href="05_Control_Flow.html">基本操作符</a>。</p>


<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p>


<p><a name="tuples"></a></p>


<h2 id="-">元组</h2>


<p><em>元组（tuples）</em>把多个值组合成一个复合值。元组内的值可以使任意类型，并不要求是相同类型。</p>


<p>下面这个例子中，<code>(404, "Not Found")</code>是一个描述 <em>HTTP 状态码（HTTP status code）</em>的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个<code>404 Not Found</code>状态码。</p>


<pre><code>let http404Error = (404, "Not Found")
// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")
</code></pre>


<p><code>(404, "Not Found")</code>元组把一个<code>Int</code>值和一个<code>String</code>值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为<code>(Int, String)</code>的元组”。</p>


<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为<code>(Int, Int, Int)</code>或者<code>(String, Bool)</code>或者其他任何你想要的组合的元组。</p>


<p>你可以将一个元组的内容<em>分解（decompose）</em>成单独的常量和变量，然后你就可以正常使用它们了：</p>


<pre><code>let (statusCode, statusMessage) = http404Error
println("The status code is \(statusCode)")
// 输出 "The status code is 404"
println("The status message is \(statusMessage)")
// 输出 "The status message is Not Found"
</code></pre>


<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：</p>


<pre><code>let (justTheStatusCode, _) = http404Error
println("The status code is \(justTheStatusCode)")
// 输出 "The status code is 404"
</code></pre>


<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>


<pre><code>println("The status code is \(http404Error.0)")
// 输出 "The status code is 404"
println("The status message is \(http404Error.1)")
// 输出 "The status message is Not Found"
</code></pre>


<p>你可以在定义元组的时候给单个元素命名：</p>


<pre><code>let http200Status = (statusCode: 200, description: "OK")
</code></pre>


<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>


<pre><code>println("The status code is \(http200Status.statusCode)")
// 输出 "The status code is 200"
println("The status message is \(http200Status.description)")
// 输出 "The status message is OK"
</code></pre>


<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个<code>(Int, String)</code>元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考[函数参数与返回值(06_Functions.html#Function_Parameters_and_Return_Values)。</p>


<blockquote>
<p>注意：</p>
<p>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考<a href="09_Classes_and_Structures.html">类和结构体</a>。</p>
</blockquote>


<p><a name="optionals"></a></p>


<h2 id="-">可选</h2>


<p>使用<em>可选（optionals）</em>来处理值可能缺失的情况。可选表示：</p>


<ul>
<li><em>有</em>值，等于 x</li>
</ul>


<p>或者</p>


<ul>
<li><em>没有</em>值</li>
</ul>


<blockquote>
<p>注意：</p>
<p>C 和 Objective-C 中并没有可选这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回<code>nil</code>，<code>nil</code>表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选可以让你暗示<em>任意类型</em>的值缺失，并不需要一个特殊值。</p>
</blockquote>


<p>来看一个例子。Swift 的<code>String</code>类型有一个叫做<code>toInt</code>的方法，作用是将一个<code>String</code>值转换成一个<code>Int</code>值。然而，并不是所有的字符串都可以转换成一个整数。字符串<code>"123"</code>可以被转换成数字<code>123</code>，但是字符串<code>"hello, world"</code>不行。</p>


<p>下面的例子使用<code>toInt</code>方法来尝试将一个<code>String</code>转换成<code>Int</code>：</p>


<pre><code>let possibleNumber = "123"
let convertedNumber = possibleNumber.toInt()
// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"
</code></pre>


<p>因为<code>toInt</code>方法可能会失败，所以它返回一个<em>可选的（optional）</em><code>Int</code>，而不是一个<code>Int</code>。一个可选的<code>Int</code>被写作<code>Int?</code>而不是<code>Int</code>。问号暗示包含的值是可选，也就是说可能包含<code>Int</code>值也可能不包含值。（不能包含其他任何值比如<code>Bool</code>值或者<code>String</code>值。只能是<code>Int</code>或者什么都没有。）</p>


<h3 id="if-">if 语句以及强制解析</h3>


<p>你可以使用<code>if</code>语句来判断一个可选是否包含值。如果可选有值，结果是<code>true</code>；如果没有值，结果是<code>false</code>。</p>


<p>当你确定可选包<em>确实</em>含值之后，你可以在可选的名字后面加一个感叹号(<code>!</code>)来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的<em>强制解析（forced unwrapping）</em>：</p>


<pre><code>if convertedNumber {
    println("\(possibleNumber) has an integer value of \(convertedNumber!)")
} else {
    println("\(possibleNumber) could not be converted to an integer")
}
// 输出 "123 has an integer value of 123"
</code></pre>


<p>更多关于<code>if</code>语句的内容，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<blockquote>
<p>注意：</p>
<p>使用<code>!</code>来获取一个不存在的可选值会导致运行时错误。使用<code>!</code>来强制解析值之前，一定要确定可选包含一个非<code>nil</code>的值。</p>
</blockquote>


<h3 id="-">可选绑定</h3>


<p>使用<em>可选绑定（optional binding）</em>来判断可选是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在<code>if</code>和<code>while</code>语句中来对可选的值进行判断并把值赋给一个常量或者变量。<code>if</code>和<code>while</code>语句，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<p>像下面这样在<code>if</code>语句中写一个可选绑定：</p>


<pre><code>if let constantName = someOptional {
    statements
}
</code></pre>


<p>你可以像上面这样使用可选绑定来重写<code>possibleNumber</code>这个例子：</p>


<pre><code>if let actualNumber = possibleNumber.toInt() {
    println("\(possibleNumber) has an integer value of \(actualNumber)")
} else {
    println("\(possibleNumber) could not be converted to an integer")
}
// 输出 "123 has an integer value of 123"
</code></pre>


<p>这段代码可以被理解为：</p>


<p>“如果<code>possibleNumber.toInt</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。”</p>


<p>如果转换成功，<code>actualNumber</code>常量可以在<code>if</code>语句的第一个分支中使用。它已经被可选<em>包含的</em>值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。在这个例子中，<code>actualNumber</code>只被用来输出转换结果。</p>


<p>你可以在可选绑定中使用常量和变量。如果你想在<code>if</code>语句的第一个分支中操作<code>actualNumber</code>的值，你可以改成<code>if var actualNumber</code>，这样可选包含的值就会被赋给一个变量而非常量。</p>


<h3 id="nil">nil</h3>


<p>你可以给可选变量赋值为<code>nil</code>来表示它没有值：</p>


<pre><code>var serverResponseCode: Int? = 404
// serverResponseCode 包含一个可选的 Int 值 404
serverResponseCode = nil
// serverResponseCode 现在不包含值
</code></pre>


<blockquote>
<p>注意：</p>
<p><code>nil</code>不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>


<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为<code>nil</code>：</p>


<pre><code>var surveyAnswer: String?
// surveyAnswer 被自动设置为 nil
</code></pre>


<blockquote>
<p>注意：</p>
<p>Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。<em>任何</em>类型的可选都可以被设置为<code>nil</code>，不只是对象类型。</p>
</blockquote>


<h3 id="-">隐式解析可选</h3>


<p>如上所述，可选暗示了常量或者变量可以“没有值”。可选可以通过<code>if</code>语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>


<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>


<p>这种类型的可选被定义为<em>隐式解析可选（implicitly unwrapped optionals）</em>。把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选。</p>


<p>当可选被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选非常有用。隐式解析可选主要被用在 Swift 中类的构造过程中，请参考<a href="16_Automatic_Reference_Counting.html#strong_reference_cycles_between_class_instances">类实例之间的循环强引用</a>。</p>


<p>一个隐式解析可选其实就是一个普通的可选，但是可以被当做非可选来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选<code>String</code>和隐式解析可选<code>String</code>之间的区别：</p>


<pre><code>let possibleString: String? = "An optional string."
println(possibleString!) // 需要惊叹号来获取值
// 输出 "An optional string."

let assumedString: String! = "An implicitly unwrapped optional string."
println(assumedString)  // 不需要感叹号
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<p>你可以把隐式解析可选当做一个可以自动解析的可选。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>


<blockquote>
<p>注意：</p>
<p>如果你在隐式解析可选没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选后面加一个惊叹号一样。</p>
</blockquote>


<p>你仍然可以把隐式解析可选当做普通可选来判断它是否包含值：</p>


<pre><code>if assumedString {
    println(assumedString)
}
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<p>你也可以在可选绑定中使用隐式解析可选来检查并解析它的值：</p>


<pre><code>if let definiteString = assumedString {
    println(definiteString)
}
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果一个变量之后可能变成<code>nil</code>的话请不要使用隐式解析可选。如果你需要在变量的生命周期中判断是否是<code>nil</code>的话，请使用普通可选类型。</p>
</blockquote>


<p><a name="assertions"></a></p>


<h2 id="-">断言</h2>


<p>可选可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能并不需要继续执行。这时，你可以在你的代码中触发一个<em>断言（assertion）</em>来结束代码运行并通过调试来找到值缺失的原因。</p>


<h3 id="-">使用断言进行调试</h3>


<p>断言会在运行时判断一个逻辑条件是否为<code>true</code>。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为<code>true</code>，代码运行会继续进行；如果条件判断为<code>false</code>，代码运行停止，你的应用被终止。</p>


<p>如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>


<p>你可以使用全局<code>assert</code>函数来写一个断言。向<code>assert</code>函数传入一个结果为<code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式为<code>false</code>的时候这条信息会被显示：</p>


<pre><code>let age = -3
assert(age &gt;= 0, "A person's age cannot be less than zero")
// 因为 age &lt; 0，所以断言会触发
</code></pre>


<p>在这个例子中，只有<code>age &gt;= 0</code>为<code>true</code>的时候代码运行才会继续，也就是说，当<code>age</code>的值非负的时候。如果<code>age</code>的值是负数，就像代码中那样，<code>age &gt;= 0</code>为<code>false</code>，断言被触发，结束应用。</p>


<p>断言信息不能使用字符串插值。断言信息可以省略，就像这样：</p>


<pre><code>assert(age &gt;= 0)
</code></pre>


<h3 id="-">何时使用断言</h3>


<p>当条件可能为假时使用断言，但是最终一定要<em>保证</em>条件为真，这样你的代码才能继续运行。断言的适用情景：</p>


<ul>
<li>整数的附属脚本索引被传入一个自定义附属脚本实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>值。</li>
</ul>


<p>请参考<a href="12_Subscripts.html">附属脚本</a>和<a href="06_Functions.html">函数</a>。</p>


<blockquote>
<p>注意：</p>
<p>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>

]]></content>
  </entry>
  
</feed>
