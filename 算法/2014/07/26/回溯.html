<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>回溯</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">jvm<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label8" class="tags__li tags-btn">网络<span class="post_count"></span></li>
          <li id="js-label9" class="tags__li tags-btn">工作<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/09/11/ThreadLocal%20%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">ThreadLocal 分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/04/MapReduce%20Algorithms.html"><span class="pl__circle"></span><span class="pl__title">MapReduce Algorithms</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/09/03/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Skyline监控系统工作原理分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%20timeseries%E5%BC%82%E5%B8%B8%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Skyline timeseries异常判定算法</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">排序总结</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"><span class="pl__circle"></span><span class="pl__title">快速排序</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">几个常见的概率问题</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/31/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html"><span class="pl__circle"></span><span class="pl__title">常见的HTTP状态码</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/28/BloomFilter.html"><span class="pl__circle"></span><span class="pl__title">BloomFilter</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="jvm pl__all" href="/jvm/2014/07/27/gc.html"><span class="pl__circle"></span><span class="pl__title">JVM GC调优</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">二叉树的各种遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C总结 + 虚拟内存</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache 与 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">回溯</h1>
  <div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">回溯法是一个万金油算法，它的本质是优化了的暴力搜索，其基本思想是 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin-top: 0px; margin: 0 4px;">深度优先搜索</code> 以及 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">剪枝</code> ，适用于求解 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">任意解</code> ，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">所有解</code> 或 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">最优解（可能不是最好的方式）</code> 的场景，后两者都需要探索整个解空间。  </p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. 基本思想</h2>
<ul style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">每一步的 <strong style="font-weight: bold; margin-top: 0px;">选择</strong> 和 <strong style="font-weight: bold;">问题状态的变迁</strong> 构成了一棵 <strong style="font-weight: bold;">解空间树</strong> ，可以看作每个节点都存储着这两种信息。  </li>
<li style="line-height: 1.6;">用 <strong style="font-weight: bold; margin-top: 0px;">深度优先</strong> 的方式遍历这棵树，当到达 <strong style="font-weight: bold;">目标状态</strong> 时停止，此时从根节点出发的路径即为问题的一个解。探索过程中，若当前节点的子树可能有解则继续往下探索；若无解则回溯。</li>
<li style="line-height: 1.6;"><strong style="font-weight: bold; margin-top: 0px;">剪枝</strong>：判断当前节点的子树中是否有解的函数称为 <strong style="font-weight: bold;">剪枝函数</strong>，很形象的，<em>‘剪掉子树’</em>。主要有 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">可行性剪枝 [状态是否合法]</code> <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">最优解剪枝 [求最优解时]</code> <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">状态判重剪枝 [状态可能重复时]</code>。</li>
</ul>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. 实现与模板</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">现在来考虑实现，一般的，我们需要：</p>
<ul style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">一个stack保存当前的遍历路径（每一步的选择），随着探索不停的push和pop元素；  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">  当完整解的高度固定时，可以用一个数组 + 栈顶索引index，来模拟stack。注意，初始栈为空，index初值为-1。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">一些变量保存问题的 <strong style="font-weight: bold; margin-top: 0px;">状态</strong>，在探索和回溯过程中不停地<em>改变</em>和<em>恢复</em>：  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">  比如，假设当前探索到节点P，此时的状态是S(P)，往下探索时，假设它有两个孩子节点C1和C2。首先考虑C1：  </p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;">  <span style="color: #75715e; margin-top: 0px;">// 伪代码</span>
  <span style="color: #e6db74;">stack</span>.push(C1)
  状态 = S(C1)
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 当 a. C1被剪枝了；b.C1的子树都被探索完时，我们该考虑C2了。在对C2进行上述两步之前，需要 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin-top: 0px; margin: 0 4px;">恢复状态到父节点</code> 并 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">出栈C1</code>，第一步很容易遗漏:</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;">  <span style="color: #75715e; margin-top: 0px;">// 伪代码</span>
  状态 = S(P)     <span style="color: #75715e;">//！记得恢复状态</span>
  <span style="color: #e6db74;">stack</span>.pop()

  <span style="color: #75715e;">// 此时考虑C2</span>
  <span style="color: #e6db74;">stack</span>.push(C2)
  状态 = S(C2)
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">  需要注意的是，很多问题中（如八皇后/数独），stack中保存的部分解就可以表达当前问题的状态，此时就没有必要专门去跟踪了。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">函数 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin-top: 0px; margin: 0 4px;">isComplete()</code> ，判断当前是否找到了 <strong style="font-weight: bold;">完整解</strong>。  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">  通常根据 <strong style="font-weight: bold; margin-top: 0px;">是否到达目标状态</strong>，<strong style="font-weight: bold;">当前路径的长度</strong> 判断。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">剪枝函数 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin-top: 0px; margin: 0 4px;">isPartial()</code> ，判断当前stack 是不是一个合法的 <strong style="font-weight: bold;">部分解</strong>。  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">  判断有没有必要继续向下探索。<br style="margin-top: 0px;"/>  当探索到达树的底部，还需要判断当前是不是合法的 <strong style="font-weight: bold;">完整解</strong>。</p>
</li>
</ul>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">给出用回溯法（递归的方式）求 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin-top: 0px; margin: 0 4px;">全部解</code> 的模板如下：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;"><span style="color: #75715e; margin-top: 0px;">// 探索时存放路径，即部分解。当树的高度确定时，可用index+array代替栈，index是stack的栈顶位置, 其初始值为-1.</span>
<span style="color: #F92672;">var</span> path = <span style="color: #F92672;">new</span> Stack()

<span style="color: #75715e;">// 状态随节点转移而改变。注意，很多情况下status可以由path来表达(比如N皇后/数独，棋盘的状态就存放在path中)，这时就省去了状态转移的这个步骤了。</span>
<span style="color: #F92672;">var</span> status = init status

<span style="color: #75715e;">// 其含义其实是对当前栈顶节点的子树进行探索</span>
<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">function</span> <span style="color: #a6e22e;">explore</span><span style="color: #f8f8f2;">()</span></span>{
    <span style="color: #75715e;">// 找到一个完整解</span>
    <span style="color: #F92672;">if</span>(isComplete()){
        print path
        <span style="color: #F92672;">return</span>;
    }

    <span style="color: #F92672;">for</span>(choice : choices of last node(eg. P) <span style="color: #F92672;">in</span> path){ <span style="color: #75715e;">// 这里可以做一个优化：更优的选择先探索</span>
        path.push(choice)     
        transform status    <span style="color: #75715e;">// P转移到choice节点的状态计算</span>

        <span style="color: #75715e;">// 剪枝</span>
        <span style="color: #F92672;">if</span>(isPatial()){
            <span style="color: #75715e;">// 剪枝失败，进入choice的子树探索</span>
            explore()
        }

        <span style="color: #75715e;">// 剪枝成功或choice的子树探索完毕，探索P的下一个子节点。</span>

        restore status <span style="color: #75715e;">// --&gt; 不要忘了状态的恢复!</span>
        path.pop()
    }
}

<span style="color: #75715e;">// 根据path或status判断是否找到了完整解</span>
<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">function</span> <span style="color: #a6e22e;">isComplete</span><span style="color: #f8f8f2;">()</span></span>{
}

<span style="color: #75715e;">// 剪枝</span>
<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">function</span> <span style="color: #a6e22e;">isPatial</span><span style="color: #f8f8f2;">()</span></span>{
    <span style="color: #75715e;">// 对于path中存放的部分解进行 *可行性剪枝*，即判断status是否合法/后续探索是否有可能找到一个完整解</span>
}

<span style="color: #75715e;">// 调用</span>
explore()
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只需保存路径，空间复杂度为O(height of tree)。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. 实例</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">3.1 八皇后</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">应用回溯法时，最重要的有两点：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><strong style="font-weight: bold; margin-top: 0px;">问题的状态</strong> 是什么（什么信息需要跟踪），<strong style="font-weight: bold;">初始状态</strong> 和 <strong style="font-weight: bold;">目标状态</strong> 各是什么；</li>
<li style="line-height: 1.6;">如何明确定义解，即 <strong style="font-weight: bold; margin-top: 0px;">如何一步一步进行探索</strong>。同一个问题，解的表达方式可能有多种，某些形式可能更容易处理，如更少的探索次数、更易剪枝、可以在搜索过程中避免状态重复等，要多利用解的特点；</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">以八皇后为例，一种直接的探索方式为：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;"><span style="color: #75715e; margin-top: 0px;">// --解的表示方式</span>
使用一个长度为n的数组保存每个皇后在棋盘中的坐标（取值范围<span style="color: #ae81ff;">0.</span><span style="color: #f8f8f2;">.n</span>^<span style="color: #ae81ff;">2</span>）；
<span style="color: #75715e;">// 探索过程</span>
对第<span style="color: #ae81ff;">1</span>个皇后，可以放在棋盘的任意位置（n^<span style="color: #ae81ff;">2</span>种选择）；固定皇后<span style="color: #ae81ff;">1</span>后，皇后<span style="color: #ae81ff;">2</span>可以选皇后<span style="color: #ae81ff;">1</span>以外的位置；同样的，皇后<span style="color: #ae81ff;">3</span>可以选择皇后<span style="color: #ae81ff;">1</span>/<span style="color: #ae81ff;">2</span>之外的位置；...以此类推，每次选定位置后利用规则进行剪枝。
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">这种探索方式的缺点有两点：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">平均每次探索的选择都是O(n^2)的，待选节点规模太大；</li>
<li style="line-height: 1.6;">会出现<em style="margin-top: 0px;">重复状态</em>（如皇后1选择[0][0]，2选择[0][1]；vs 1选择[0][1]，2选择[0][0]，这两者所到达的棋盘状态是一样的），需要额外的空间和时间进行状态保存和判重。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">仔细考虑解的特点，最后的解必然会在每一行上有且仅有一个棋子，因此可以用下面的探索方式：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;"><span style="color: #75715e; margin-top: 0px;">// --解的表示方式</span>
使用一个长度为n的数组，每个元素代表该行上皇后所在的列(取值范围<span style="color: #ae81ff;">0.</span><span style="color: #f8f8f2;">.n</span>)；
<span style="color: #75715e;">// 探索过程</span>
对第<span style="color: #ae81ff;">1</span>个行，皇后可以放在该行的任意位置（n种选择）；对第<span style="color: #ae81ff;">2</span>行，同理；...以此类推。
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">可以看到，上面的方法避免了前一种的两个问题：子节点的规模为O(n)，且不会出现重复状态。代码如下，和模板基本上是一一对应的：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;"><span style="color: #75715e; margin-top: 0px;">#!/usr/bin/python</span>
<span style="color: #75715e;"># coding=utf-8</span>
<span style="color: #F92672;">import</span> math

<span><span style="color: #66d9ef; margin-top: 0px;">class</span> <span style="color: #a6e22e; font-style: italic;">Solution</span>:</span>

    <span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">solveNQueens</span><span style="color: #f8f8f2;">(self, n)</span>:</span>
        self.n = n
        <span style="color: #75715e;"># 栈（数组）和栈顶，保存每一行上皇后所在的列</span>
        self.stack = [<span style="color: #F92672;">None</span>] * n
        self.stackTop = -<span style="color: #ae81ff;">1</span>
        <span style="color: #75715e;"># 不需要额外记录问题的状态，路径就可以表达棋盘的状态了</span>

        self.explore()

    <span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">explore</span><span style="color: #f8f8f2;">(self)</span>:</span>
        <span style="color: #75715e;"># isComplete():</span>
        <span style="color: #75715e;"># 探索完了最后一层，即栈指针指向最后一个元素。此时stack中保存一个完整解。</span>
        <span style="color: #F92672;">if</span> self.stackTop == self.n - <span style="color: #ae81ff;">1</span>:
            <span style="color: #F92672;">print</span> self.stack
            <span style="color: #F92672;">return</span> 

        <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> range(<span style="color: #ae81ff;">0</span>,self.n): <span style="color: #75715e;">#每一层有n个选择</span>
            <span style="color: #75715e;"># push</span>
            self.stackTop += <span style="color: #ae81ff;">1</span>
            self.stack[self.stackTop] = i

            <span style="color: #75715e;"># 剪枝 &amp; 继续探索</span>
            <span style="color: #F92672;">if</span> self.isPatial():
                self.explore()

            <span style="color: #75715e;"># pop</span>
            self.stack[self.stackTop] = <span style="color: #F92672;">None</span>
            self.stackTop -= <span style="color: #ae81ff;">1</span>

    <span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">isPatial</span><span style="color: #f8f8f2;">(self)</span>:</span>
        <span style="color: #75715e;"># 可行性剪枝:</span>
        <span style="color: #75715e;"># 两个皇后不能在一行/一列/一条斜线</span>

        <span style="color: #75715e;"># 这里利用了一个特性：</span>
        <span style="color: #75715e;"># stack中[0..stackTop - 1]的排列方式可以保证已经是符合规则的，只需要考察stackTop和之前的每个皇后是否满足规则即可。</span>
        lastCol = self.stack[self.stackTop]    
        i = self.stackTop - <span style="color: #ae81ff;">1</span>
        <span style="color: #F92672;">while</span> i &gt;= <span style="color: #ae81ff;">0</span>:
            col = self.stack[i]
            <span style="color: #F92672;">if</span> lastCol == col <span style="color: #F92672;">or</span> math.fabs(self.stackTop - i) == math.fabs(lastCol - col):
                <span style="color: #F92672;">return</span> <span style="color: #F92672;">False</span>
            i -= <span style="color: #ae81ff;">1</span>
        <span style="color: #F92672;">return</span> <span style="color: #F92672;">True</span>


<span style="color: #F92672;">if</span> __name__ == <span style="color: #e6db74;">"__main__"</span>:
    Solution().solveNQueens(<span style="color: #ae81ff;">6</span>)
    <span style="color: #75715e;"># [1, 3, 5, 0, 2, 4]</span>
    <span style="color: #75715e;"># [2, 5, 1, 4, 0, 3]</span>
    <span style="color: #75715e;"># [3, 0, 4, 1, 5, 2]</span>
    <span style="color: #75715e;"># [4, 2, 0, 5, 3, 1]</span>
</code></pre>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">4. 求任意解</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果只要求一个解，可以用一个变量维护当前解是否找到，每次探索完了先看一下，如果已经找到了解就立刻返回。</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;">solutionFound = <span style="color: #F92672; margin-top: 0px;">False</span>           <span style="color: #75715e;"># 1</span>

<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">explore</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #F92672;">if</span> isComplete():
        solutionFound = <span style="color: #F92672;">True</span>    <span style="color: #75715e;"># 2</span>
        <span style="color: #F92672;">return</span>

    <span style="color: #F92672;">for</span> every step <span style="color: #F92672;">in</span> Steps:
        ...
        <span style="color: #F92672;">if</span> isPatial():
            explore()
            <span style="color: #F92672;">if</span> solutionFound:   <span style="color: #75715e;"># 3</span>
                <span style="color: #F92672;">return</span>
        ...
</code></pre>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">5. 求最优解</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">思路：</p>
<ul style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">维护当前找到的最优（完整）解及其对应的状态；</li>
<li style="line-height: 1.6;">剪枝时，除<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin-top: 0px; margin: 0 4px;">可行性剪枝</code>，还需要进行<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">最优解剪枝</code>：如果当前的部分解比已知最优解还差，就可以停止往下探索了；</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin-top: 0px; margin: 0 4px;">最优解剪枝</code>会淘汰掉比已知最优解差的"完整解"，因此当确实找到了一个完整解时，即为新的最优解；</li>
</ul>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">因此，在实现中需要增加的逻辑有：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;">... <span style="color: #75715e; margin-top: 0px;">// stack/status</span>
<span style="color: #75715e;">// 已知最优解及其状态   ---- 改动1</span>
<span style="color: #F92672;">var</span> bestSolution = None;
<span style="color: #F92672;">var</span> bestStatus = None;

<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">function</span> <span style="color: #a6e22e;">explore</span><span style="color: #f8f8f2;">()</span></span>{
    <span style="color: #75715e;">// 找到一个完整解，即新的最优解</span>
    <span style="color: #F92672;">if</span>(isComplete()){
        <span style="color: #75715e;">// 更新已知最优解及其状态   ---- 改动2</span>
        bestSolution = stack.copy();
        bestStatus = status;
        <span style="color: #F92672;">return</span>;
    }

    <span style="color: #F92672;">for</span>(choice : choices of last node(eg. P) <span style="color: #F92672;">in</span> path){
        ... 
        <span style="color: #75715e;">// 注意，即使choice已经到达最后一层且组成了一个合法的完整解，如果不是当前最优的，也会被剪掉。</span>
    }
}

<span style="color: #75715e;">// 剪枝</span>
<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">function</span> <span style="color: #a6e22e;">isPatial</span><span style="color: #f8f8f2;">()</span></span>{
    <span style="color: #75715e;">// 1. 可行性剪枝</span>
    <span style="color: #75715e;">// 2. 最优解剪枝    ---- 改动3</span>
}

explore()
<span style="color: #75715e;">// 算法结束后，bestSolution就是最优解了。</span>
</code></pre>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">5.1 01背包</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">01背包属于下面提到的“子集树”的情况，为了搜索，使用一个长度为n的数组作为探索时的栈，每个元素只有两种可能取值，0-不选，1-选。问题的状态由 <em style="margin-top: 0px;">当前物品的总价值</em> 以及 <em>当前物品的总空间</em> 二者表达，在遍历时需要维护这两个状态。虽然他们可以由stack中的元素计算而得，但耗时O(n)；</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">为了求最优解，还需要跟踪当前最优解及其对应的问题的状态；</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最后，如何利用最优解进行剪枝？ 假设考察k，物品[0..k-1]已经确定了是否选择，如果[0..k-1]得到的总价值，再加上剩余所有物品的价值总和，依然小于当前最优解，则可以放弃探索了。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">代码实现如下：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;"><span style="color: #75715e; margin-top: 0px;">#!/usr/bin/python</span>
<span style="color: #75715e;"># coding=utf-8</span>

<span style="color: #75715e;"># 0/1背包问题</span>

v =  [<span style="color: #ae81ff;">8</span>, <span style="color: #ae81ff;">9</span>, <span style="color: #ae81ff;">10</span>, <span style="color: #ae81ff;">4</span>, <span style="color: #ae81ff;">1</span>, <span style="color: #ae81ff;">15</span>]     <span style="color: #75715e;"># 物品价值</span>
c = [<span style="color: #ae81ff;">2</span>, <span style="color: #ae81ff;">1</span>, <span style="color: #ae81ff;">5</span>, <span style="color: #ae81ff;">3</span>, <span style="color: #ae81ff;">3</span>, <span style="color: #ae81ff;">7</span>]        <span style="color: #75715e;"># 物品空间</span>
n = len(v)                    <span style="color: #75715e;"># 物品个数</span>
bag = <span style="color: #ae81ff;">12</span>                    <span style="color: #75715e;"># 包的总空间</span>

<span style="color: #75715e;"># DFS需要的信息</span>
stack = [<span style="color: #F92672;">None</span>] * n             <span style="color: #75715e;"># stack</span>
stackTop = -<span style="color: #ae81ff;">1</span>
totalValue = <span style="color: #ae81ff;">0</span>                <span style="color: #75715e;"># 问题的状态 --     1. 所选物品的总价值，初始没选物品，为0; </span>
totalCapacity = <span style="color: #ae81ff;">0</span>            <span style="color: #75715e;">#                 2.所有物品的总空间</span>
                            <span style="color: #75715e;"># 其实由path中也可计算得到，但是耗时O(n).</span>

<span style="color: #75715e;"># 求最优解需要的额外信息</span>
bestSolution = <span style="color: #F92672;">None</span>            <span style="color: #75715e;"># 当前最优解</span>
maxValueFound = <span style="color: #F92672;">None</span>        <span style="color: #75715e;"># 最优解时的物品总价值</span>

<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">explore</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #F92672;">global</span> stackTop,totalValue,bestSolution,maxValueFound,totalCapacity

    <span style="color: #75715e;"># 找到了新的最优（完整）解</span>
    <span style="color: #F92672;">if</span> stackTop == n - <span style="color: #ae81ff;">1</span>:
        bestSolution = stack[:]
        maxValueFound = totalValue
        <span style="color: #F92672;">return</span>

    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> range(<span style="color: #ae81ff;">0</span>,<span style="color: #ae81ff;">2</span>):    <span style="color: #75715e;"># 子集树</span>
        <span style="color: #75715e;"># push</span>
        stackTop += <span style="color: #ae81ff;">1</span>
        stack[stackTop] = i
        <span style="color: #75715e;"># transform status</span>
        totalValue += v[stackTop] * i
        totalCapacity += c[stackTop] * i

        <span style="color: #F92672;">if</span> isPartial():
            explore()

        <span style="color: #75715e;"># restore status</span>
        totalValue -= v[stackTop] * i
        totalCapacity -= c[stackTop] * i
        <span style="color: #75715e;"># pop</span>
        stack[stackTop] = <span style="color: #F92672;">None</span>
        stackTop -= <span style="color: #ae81ff;">1</span>

<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">isPartial</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #75715e;"># 1. 可行性剪枝</span>
    <span style="color: #F92672;">if</span> totalCapacity &gt; bag:        <span style="color: #75715e;"># 占用空间超过袋子的总空间，则不合法</span>
        <span style="color: #F92672;">return</span> <span style="color: #F92672;">False</span>

    <span style="color: #75715e;"># 2. 最优解剪枝</span>
    <span style="color: #F92672;">if</span> maxValueFound != <span style="color: #F92672;">None</span>:    <span style="color: #75715e;"># 已经找到了一个最优解才进行最优解剪枝</span>
        <span style="color: #75715e;"># 剪枝的依据：如果当前获得的物品价值（totalValue），加上剩余所有物品的价值，依然小于当前最优解，则剪掉</span>
        c = totalValue
        <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> range(stackTop + <span style="color: #ae81ff;">1</span>,n):
            c += v[i]
        <span style="color: #F92672;">if</span> c &lt; maxValueFound:
            <span style="color: #F92672;">return</span> <span style="color: #F92672;">False</span>
    <span style="color: #F92672;">return</span> <span style="color: #F92672;">True</span>

<span style="color: #F92672;">if</span> __name__ == <span style="color: #e6db74;">"__main__"</span>:
    explore()
    <span style="color: #F92672;">print</span> bestSolution,maxValueFound
</code></pre>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">6. 排列树和子集树</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">给定一个集合和提问，有两种特殊的情况：</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">6.1 子集树</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">从集合中挑一个满足条件的子集，解是[0,1,0,0,1]的形式，表示各个元素是否选择，解空间规模为 <span style="display: inline-block; margin: 0; margin-top: 0px;"><span style="margin-top: 0px;"></span><span style=""><span style="white-space: nowrap; margin-top: 0px;"><span style="width: 3.358em; display: inline-block; margin-top: 0px;"><span style="display: inline-block; position: relative; width: 2.546em; height: 0px; font-size: 132%; margin-top: 0px;"><span style="position: absolute; clip: rect(1.734em 1000.003em 3.087em -0.43em); top: -2.649em; left: 0.003em; margin-top: 0px;"><span style="margin-top: 0px;"><span style="font-family: MathJax_Math, serif; font-style: italic; margin-top: 0px;">O</span><span style="font-family:MathJax_Main, serif;">(</span><span><span style="display: inline-block; position: relative; width: 0.977em; height: 0px; margin-top: 0px;"><span style="position: absolute; clip: rect(1.843em 1000.003em 2.817em -0.43em); top: -2.649em; left: 0.003em; margin-top: 0px;"><span style="font-family: MathJax_Main, serif; margin-top: 0px;">2</span><span style="display: inline-block; width: 0px; height: 2.654em;"></span></span><span style="position: absolute; top: -2.595em; left: 0.49em;"><span style="font-size: 70.7%; font-family: MathJax_Math, serif; font-style: italic; margin-top: 0px;">n</span><span style="display: inline-block; width: 0px; height: 2.221em;"></span></span></span></span><span style="font-family:MathJax_Main, serif;">)</span></span><span style="display: inline-block; width: 0px; height: 2.654em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.432em; vertical-align: -0.425em;"></span></span></span></span></span>。01背包问题就是子集树的例子：  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="data:image,local://1394690224453" name="d94bf7f9-bedc-4288-8c48-2dfe54d38128" src="/assets/img/c3c23757d2149a02fb84418b84a8afa9" style="border: 0; max-width: 100%; border-radius: 8px; margin-top: 0px;"/> </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">子集树的处理与之前一致，每次探索只有两个选择，0和1：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;"><span style="color: #75715e; margin-top: 0px;">// old</span>
<span style="color: #F92672;">for</span>(choice : choices of last node(eg. P) <span style="color: #F92672;">in</span> path){
    ...
}

<span style="color: #75715e;">// new</span>
<span style="color: #F92672;">for</span>(i = <span style="color: #ae81ff;">0</span>;i&lt;=<span style="color: #ae81ff;">1</span>;i++){
    ...
}
</code></pre>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">6.2 排列树</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">求集合的满足条件的某种排列形式，解空间规模 <span style="display: inline-block; margin: 0; margin-top: 0px;"><span style="margin-top: 0px;"></span><span style=""><span style="white-space: nowrap; margin-top: 0px;"><span style="width: 3.141em; display: inline-block; margin-top: 0px;"><span style="display: inline-block; position: relative; width: 2.384em; height: 0px; font-size: 132%; margin-top: 0px;"><span style="position: absolute; clip: rect(1.734em 1000.003em 3.087em -0.43em); top: -2.649em; left: 0.003em; margin-top: 0px;"><span style="margin-top: 0px;"><span style="font-family: MathJax_Math, serif; font-style: italic; margin-top: 0px;">O</span><span style="font-family:MathJax_Main, serif;">(</span><span style="font-family:MathJax_Math, serif; font-style: italic;">n</span><span style="font-family:MathJax_Main, serif;">!</span><span style="font-family:MathJax_Main, serif;">)</span></span><span style="display: inline-block; width: 0px; height: 2.654em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.432em; vertical-align: -0.425em;"></span></span></span></span></span>：  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="data:image,local://1394690256154" name="deca2065-049d-4af1-aa28-73e629ff0b95" src="/assets/img/c9590fdaa9eaafdfb3e318b1ab7e086a" style="border: 0; max-width: 100%; border-radius: 8px; margin-top: 0px;"/> </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">每次探索都只能选择之前没出现过的元素，这个限制可以用一个简单的方式实现：  </p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">保存探索路径的 <em style="margin-top: 0px;">stack</em> 和 <em>原始元素的集合</em> 共用同一个数组；</li>
<li style="line-height: 1.6;">假设0..k-1是已经确定了的探索路径（即 stack），在考察k时，则可以选k..n之间的每个元素;</li>
<li style="line-height: 1.6;"><strong style="font-weight: bold; margin-top: 0px;">对栈的 push 和 pop 可以用两次 swap 搞定</strong></li>
</ol>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;"><span style="color: #75715e; margin-top: 0px;">// old</span>
<span style="color: #F92672;">for</span>(choice : choices of last node(eg. P) <span style="color: #F92672;">in</span> path){
    ...
}

<span style="color: #75715e;">// new</span>
<span style="color: #75715e;">// [0..stackTop]已经确定，对stackTop+1考察，可选元素为 [stackTop+1 .. n-1]</span>
<span style="color: #F92672;">for</span>(i <span style="color: #F92672;">in</span> [stackTop+<span style="color: #ae81ff;">1</span> .. n-<span style="color: #ae81ff;">1</span>]){
    <span style="color: #75715e;">// push a[i] to stack</span>
    swap(++stackTop,i);

    <span style="color: #75715e;">// transform status...</span>
    <span style="color: #75715e;">// 剪枝或继续探索</span>
    <span style="color: #75715e;">// restore status...</span>

    <span style="color: #75715e;">// pop</span>
    swap(i,stackTop--);
}
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">用两个swap也可以达到同样的效果且更简洁，但不太好理解。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">排列树</strong> 和 <strong style="font-weight: bold;">子集树</strong> 是很常见的两类问题，且都不会出现重复状态，属于比较简单的情况，一定要好好理解。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">7. 状态记录和判重</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在稍微复杂的问题中，经常会出现状态重复的情况，即经过若干步探索后到达了一个之前已经探索过的状态，这种情况在讨论八皇后问题时已经看到过了。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">通常用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin-top: 0px; margin: 0 4px;">hashset</code>保存所有已经访问过的状态，并且利用它们进行剪枝。当求<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">最优解</code>时，不仅要保存状态，还要保存到达该状态的路径的某些信息如长度；进行<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 13px; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">状态重复剪枝</code>时，当状态重复但 <em>当前的部分解</em> 优于 <em>记录的部分解</em> 时，是不能剪枝的。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">代码的改动有：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;">... <span style="color: #75715e; margin-top: 0px;">// stack/status...</span>

<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">function</span> <span style="color: #a6e22e;">explore</span><span style="color: #f8f8f2;">()</span></span>{
    <span style="color: #75715e;">// 记录已经访问过的状态，在此处进行可以保证初始状态和最终状态都被记录</span>
    recordStatus();  <span style="color: #75715e;">// &lt;---- 1</span>

    <span style="color: #F92672;">if</span>(isComplete()){
    ...
}

<span style="color: #F92672;">var</span> statuses = <span style="color: #F92672;">new</span> HashSet/HashMap()    <span style="color: #75715e;">// 所有已经访问过的状态   &lt;---- 2</span>
<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">function</span> <span style="color: #a6e22e;">recordStatus</span><span style="color: #f8f8f2;">()</span></span>{
    statuses.put(curStatus);    <span style="color: #75715e;">// 如果状态复杂，可以拼接出一个String表示</span>
}

<span style="color: #75715e;">// 剪枝</span>
<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">function</span> <span style="color: #a6e22e;">isPatial</span><span style="color: #f8f8f2;">()</span></span>{
    <span style="color: #75715e;">// 可行性剪枝</span>
    <span style="color: #75715e;">// [最优解剪枝]</span>
    ...
    <span style="color: #75715e;">// 状态重复剪枝     &lt;---- 3</span>
}
</code></pre>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">7.1 传教士和野人问题</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">题目如下：</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">有P个牧师和C个野人过河，只有一条能装下两个人的船，在河的任何一方或者船上，如果野人的人数大于牧师的人数，那么牧师就会有危险. 你能不能找出一种安全的渡河方法呢（P&gt;=C）？</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">由于是求任意一个解，因此按照回溯法的思路分析如下：  </p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">很明显，解空间树的高度是不确定的，不能用数组+索引当stack用，需要一个动态的栈；</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">问题的状态由什么表达？  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 左岸牧师人数 + 左岸野人人数 + 船的位置</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">初始状态和目标状态是什么？  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 初始：左岸P个牧师，C个野人，船在左边；目标：全部牧师和野人、船都在右岸</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">每一步有哪些选择？  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 这里每一次探索的选项是固定的：运送2p/1p/1p1c/1c/2c，5个选择</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">哪些可行性约束？  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 显然的，两岸的野人和牧师都不能是负数；此外，当有牧师存在时，牧师不能少于野人</p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">但是，这个问题显然是会出现重复状态的。举个例子，假设第一步送两个牧师到对岸，第二步也选择送两个牧师，这样状态就和初始状态一模一样了；即很有可能经过n步搜索后发现到达了一个曾经到过的状态。因此，为了防止无限的搜索，必须在搜索的过程中记录当前状态并以此剪枝。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">代码如下：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin-top: 0px; margin: 0 4px;"><span style="color: #75715e; margin-top: 0px;">#!/usr/bin/python</span>
<span style="color: #75715e;"># coding=utf-8</span>

<span style="color: #75715e;"># 4种选择</span>
<span><span style="color: #66d9ef; margin-top: 0px;">class</span> <span style="color: #f8f8f2;">Step</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">__init__</span><span style="color: #f8f8f2;">(self,p,c)</span>:</span>
        self.p = p
        self.c = c

    <span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">__str__</span><span style="color: #f8f8f2;">(self)</span>:</span>
        <span style="color: #F92672;">return</span> <span style="color: #e6db74;">'Pastor: '</span> + str(self.p) + <span style="color: #e6db74;">'    Cannibal: '</span>+ str(self.c)

Step.all = [Step(<span style="color: #ae81ff;">1</span>,<span style="color: #ae81ff;">1</span>),Step(<span style="color: #ae81ff;">1</span>,<span style="color: #ae81ff;">0</span>),Step(<span style="color: #ae81ff;">0</span>,<span style="color: #ae81ff;">1</span>),Step(<span style="color: #ae81ff;">2</span>,<span style="color: #ae81ff;">0</span>),Step(<span style="color: #ae81ff;">0</span>,<span style="color: #ae81ff;">2</span>)]

totalP = <span style="color: #ae81ff;">3</span>            <span style="color: #75715e;"># 总牧师</span>
totalC = <span style="color: #ae81ff;">3</span>            <span style="color: #75715e;"># 总野人</span>

<span style="color: #75715e;"># DFS需要的信息</span>
stack = []             <span style="color: #75715e;"># stack</span>
p = totalP            <span style="color: #75715e;"># 问题的状态。 p：左岸的牧师，c：左岸的野人，boat：船在哪边(为了方便计算，在左岸时-1，右岸时1)</span>
c = totalC
boat = -<span style="color: #ae81ff;">1</span>

<span style="color: #75715e;"># 第一个找到的完整解</span>
aSolution = <span style="color: #F92672;">None</span>

<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">explore</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #F92672;">global</span> aSolution,p,c,boat

    <span style="color: #75715e;"># 记录当前到达的状态</span>
    recordStatus()

    <span style="color: #75715e;"># 如果找到了解，返回</span>
    <span style="color: #F92672;">if</span> aSolution != <span style="color: #F92672;">None</span>:
        <span style="color: #F92672;">return</span>

    <span style="color: #75715e;"># 根据目标状态判断是否找到了完整解</span>
    <span style="color: #F92672;">if</span> p == <span style="color: #ae81ff;">0</span> <span style="color: #F92672;">and</span> c == <span style="color: #ae81ff;">0</span> <span style="color: #F92672;">and</span> boat == <span style="color: #ae81ff;">1</span>:
        aSolution = stack[:]
        <span style="color: #F92672;">return</span>

    <span style="color: #F92672;">for</span> step <span style="color: #F92672;">in</span> Step.all:
        <span style="color: #75715e;"># push &amp; 状态转移</span>
        stack.append(step)
        p += boat * step.p
        c += boat * step.c
        boat = -boat

        <span style="color: #F92672;">if</span> isPartial():
            explore()

        <span style="color: #75715e;"># 状态恢复 &amp; pop</span>
        p += boat * step.p
        c += boat * step.c
        boat = - boat
        stack.pop()

<span style="color: #75715e;"># 状态记录相关</span>
statuses = {}
<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">recordStatus</span><span style="color: #f8f8f2;">()</span>:</span>
    statuses[curStatus()] = <span style="color: #F92672;">True</span>
<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">curStatus</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #F92672;">return</span> str(p) + <span style="color: #e6db74;">"_"</span> + str(c) + <span style="color: #e6db74;">"_"</span> + str(boat)    <span style="color: #75715e;"># 当前状态："左岸牧师_左岸传教士_船的位置"</span>

<span style="color: #F92672;"><span style="color: #66d9ef; margin-top: 0px;">def</span> <span style="color: #a6e22e;">isPartial</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #75715e;"># 1. 可行性剪枝:</span>
    <span style="color: #75715e;"># a. 两岸的牧师和野人不可&lt;0</span>
    <span style="color: #75715e;"># b. 两岸当有牧师时，牧师不得少于野人</span>
    <span style="color: #F92672;">if</span> p &lt; <span style="color: #ae81ff;">0</span> <span style="color: #F92672;">or</span> c &lt; <span style="color: #ae81ff;">0</span> \
        <span style="color: #F92672;">or</span> totalP - p &lt; <span style="color: #ae81ff;">0</span> <span style="color: #F92672;">or</span> totalC &lt; <span style="color: #ae81ff;">0</span> \
        <span style="color: #F92672;">or</span> (p &lt; c <span style="color: #F92672;">and</span> p &gt; <span style="color: #ae81ff;">0</span>) \
        <span style="color: #F92672;">or</span> (totalP - p &lt; totalC - c <span style="color: #F92672;">and</span> totalP - p &gt; <span style="color: #ae81ff;">0</span>):
        <span style="color: #F92672;">return</span> <span style="color: #F92672;">False</span>

    <span style="color: #75715e;"># 2. 状态判重剪枝</span>
    <span style="color: #F92672;">if</span> curStatus() <span style="color: #F92672;">in</span> statuses:
        <span style="color: #F92672;">return</span> <span style="color: #F92672;">False</span>
    <span style="color: #F92672;">return</span> <span style="color: #F92672;">True</span>

<span style="color: #F92672;">if</span> __name__ == <span style="color: #e6db74;">"__main__"</span>:
    explore()
    <span style="color: #F92672;">if</span> aSolution == <span style="color: #F92672;">None</span>:
        <span style="color: #F92672;">print</span> <span style="color: #e6db74;">"no solution"</span>
    <span style="color: #F92672;">else</span>: 
        <span style="color: #F92672;">print</span> [str(s) <span style="color: #F92672;">for</span> s <span style="color: #F92672;">in</span> aSolution]
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果是求步骤数最少的方案呢？</p>
</div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html&text=回溯" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html&title=回溯" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->
<!-- 
      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">目录</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div> -->
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>
    <button id="js-toc"><span id="icon-list" class="fa fa-list-ul"></span></button>
    <div id="post__toc">
      <span id="post__toc-title">目录</span>
      <ul id="post__toc-ul"></ul>
    </div>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
