<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[小巴童鞋]]></title>
  <link href="http://ba-xiang.com//atom.xml" rel="self"/>
  <link href="http://ba-xiang.com//"/>
  <updated>2015-06-28T01:09:06+08:00</updated>
  <id>http://ba-xiang.com//</id>
  <author>
    <name><![CDATA[小巴]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ios9适配指南]]></title>
    <link href="http://ba-xiang.com//blog/ios9-adatation-tips.html"/>
    <updated>2015-06-28T01:17:55+08:00</updated>
    <id>http://ba-xiang.com//blog/ios9-adatation-tips</id>
    <content type="html"><![CDATA[<p> 原文作者：iOS程序犭袁</p>

<p> 原文地址：<a href="https://github.com/ChenYilong/iOS9AdaptationTips">https://github.com/ChenYilong/iOS9AdaptationTips</a></p>

<h2>1. Demo1_iOS9网络适配_改用更安全的HTTPS</h2>

<p>TLS 1.2 协议 强制增强数据访问安全
系统 Foundation 框架下的相关网络请求，将不再默认使用 Http 等不安全的网络协议，而默认采用 TLS 1.2。服务器因此需要更新，以解析相关数据。如不更新，可通过在 Info.plist 中声明，倒退回不安全的网络请求。</p>

<h2>2.Demo2_iOS9新特性_更灵活的后台定位</h2>

<p>【iOS9在定位的问题上，有一个坏消息一个好消息】坏消息：如果不适配iOS9，就不能偷偷在后台定位（不带蓝条，见图）！好消息：将允许出现这种场景：同一App中的多个location manager：一些只能在前台定位，另一些可在后台定位，并可随时开启或者关闭特定location manager的后台定位。
如果没有请求后台定位的权限，也是可以在后台定位的，不过会带蓝条：</p>

<!--more -->


<p> <img src="https://i.imgur.com/UoqGHlG.png" alt="enter image description here" />
如何偷偷在后台定位：请求后台定位权限：</p>

<pre><code> // 1. 实例化定位管理器
_locationManager = [[CLLocationManager alloc] init];
// 2. 设置代理
_locationManager.delegate = self;
// 3. 定位精度
[_locationManager setDesiredAccuracy:kCLLocationAccuracyBest];
// 4.请求用户权限：分为：⓵只在前台开启定位⓶在后台也可定位，
//注意：建议只请求⓵和⓶中的一个，如果两个权限都需要，只请求⓶即可，
//⓵⓶这样的顺序，将导致bug：第一次启动程序后，系统将只请求⓵的权限，⓶的权限系统不会请求，只会在下一次启动应用时请求⓶
if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8) {
    //[_locationManager requestWhenInUseAuthorization];//⓵只在前台开启定位
    [_locationManager requestAlwaysAuthorization];//⓶在后台也可定位
}
// 5.iOS9新特性：将允许出现这种场景：同一app中多个location manager：一些只能在前台定位，另一些可在后台定位（并可随时禁止其后台定位）。
if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 9) {
    _locationManager.allowsBackgroundLocationUpdates = YES;
}
// 6. 更新用户位置
[_locationManager startUpdatingLocation];
</code></pre>

<p>但是如果照着这种方式尝试，而没有配置Info.plist，100%你的程序会崩溃掉，并报错：</p>

<blockquote><p>*** Assertion failure in -[CLLocationManager setAllowsBackgroundLocationUpdates:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-1808.1.5/Framework/CoreLocation/CLLocationManager.m:593</p></blockquote>

<p>要将  Info.plist 配置如下：
 <img src="https://i.imgur.com/MAoKbUe.png" alt="enter image description here" /></p>

<p>对应的 Info.plist 的XML源码是：</p>

<pre><code>&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;
&lt;string&gt;微博@iOS程序犭袁 请求后台定位权限&lt;/string&gt;

&lt;key&gt;UIBackgroundModes&lt;/key&gt;
&lt;array&gt;
    &lt;string&gt;location&lt;/string&gt;
&lt;/array&gt;
</code></pre>

<h2>3.企业级分发</h2>

<p>iOS9之前，企业级分发十分方便：点击App出现“信任按钮”，</p>

<p> <img src="https://i.imgur.com/aSmM8bk.png" alt="enter image description here" /></p>

<p>iOS9以后，企业级分发ipa包将遭到与Mac上dmg安装包一样的待遇：默认不能安装，也不再出现“信任按钮”</p>

<p> <img src="https://i.imgur.com/Skn9iXk.png" alt="enter image description here" /></p>

<p>必须让用户进行gif图中的设置（相关Demo：<a href="https://github.com/ChenYilong/iOS9AdaptationTips/">https://github.com/ChenYilong/iOS9AdaptationTips/</a> ）</p>

<p> <img src="https://i.imgur.com/PXM235L.gif" alt="enter image description here" /></p>

<h2>4.Bitcode（通俗解释：在线版安卓ART模式）</h2>

<p>未来Watch应用须包含Bitcode，iOS不强制，但Xcode7默认会开启Bitcode。</p>

<p>如何适配？方法一：更新library使包含Bitcode，否则会出现以下中的警告；</p>

<blockquote><p>(null): URGENT: all bitcode will be dropped because
&lsquo;/Users/myname/Library/Mobile
Documents/com~apple~CloudDocs/foldername/appname/GoogleMobileAds.framework/GoogleMobileAds(GADSlot+AdEvents.o)&rsquo;
was built without bitcode. You must rebuild it with bitcode enabled
(Xcode setting ENABLE_BITCODE), obtain an updated library from the
vendor, or disable bitcode for this target. Note: This will be an
error in the future.</p></blockquote>

<p>方法二：关闭Bitcode，方法见下图</p>

<blockquote><p> <img src="https://i.imgur.com/OoOogUe.gif" alt="enter image description here" /></p></blockquote>

<p>更多信息，请移步
<a href="https://developer.apple.com/library/prerelease/watchos/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35-SW2">bitcode 苹果官方文档</a></p>

<p>,和 WWDC 2015 Session 102: <a href="https://developer.apple.com/videos/wwdc/2015/?id=102">&ldquo;Platforms State of the Union&rdquo;</a></p>

<p> <img src="http://mobileforward.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-12-at-6.57.54-PM-697x351.png" alt="enter image description here" /></p>

<h2>5.URL scheme</h2>

<p>在iOS9中，如果使用URL scheme必须在&#8221;Info.plist&#8221;中将你要在外部调用的URL scheme列为白名单，否则不能使用。key叫做LSApplicationQueriesSchemes ，键值内容是</p>

<pre><code>&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;
&lt;array&gt;
 &lt;string&gt;urlscheme&lt;/string&gt;
 &lt;string&gt;urlscheme2&lt;/string&gt;
 &lt;string&gt;urlscheme3&lt;/string&gt;
 &lt;string&gt;urlscheme4&lt;/string&gt;
&lt;/array&gt; 
</code></pre>

<p>推荐一篇博客: <a href="http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes">http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes</a></p>

<p>其中最关键的是以下部分：</p>

<blockquote><p>If you call the “canOpenURL” method on a URL that is not in your whitelist, it will return “NO”, even if there is an app installed that has registered to handle this scheme. A “This app is not allowed to query for scheme xxx” syslog entry will appear.</p>

<p>If you call the “openURL” method on a URL that is not in your whitelist, it will fail silently. A “This app is not allowed to query for scheme xxx” syslog entry will appear.</p></blockquote>

<p>更多信息请移步：WWDC 2015 Session 703: &ldquo;Privacy and Your App&rdquo;  <a href="https://developer.apple.com/videos/wwdc/2015/?id=703">https://developer.apple.com/videos/wwdc/2015/?id=703</a> 时间在30：18左右</p>

<p> <img src="https://i.imgur.com/2HxWQqq.png" alt="enter image description here" /></p>

<h2>6. iPad适配Slide Over 和 Split View</h2>

<p> <img src="http://cdn1.tnwcdn.com/wp-content/blogs.dir/1/files/2015/06/ew-.gif" alt="enter image description here" /></p>

<p>【iPad适配Slide Over 和 Split View】
若想适配multi tasking特性，唯一的建议：弃纯代码，改用storyboard、xib，纵观苹果WWDC所有Demo均是如此：</p>

<ol>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=218">Mysteries of Auto Layout, Part 1</a></p></li>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=215">What&rsquo;s New in Storyboards</a></p></li>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=407">Implementing UI Designs in Interface Builder</a></p></li>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=205">Getting Started with Multitasking on iPad in iOS 9</a></p></li>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=212">Optimizing Your App for Multitasking on iPad in iOS</a></p></li>
</ol>


<h4>英文</h4>

<h2>1. Demo1_You&rsquo;d better Convert HTTP to HTTPS</h2>

<p>How to deal with the SSL in iOS9，One solution is to  do like:
 <img src="https://github.com/ChenYilong/iOS9AdaptationTips/blob/master/Demo1_iOS9%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D_%E6%94%B9%E7%94%A8%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84HTTPS/%E5%BE%AE%E5%8D%9A%40iOS%E7%A8%8B%E5%BA%8F%E7%8A%AD%E8%A2%81/http%E9%97%AE%E9%A2%98.gif" alt="enter image description here" /></p>

<p>As the <a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-DontLinkElementID_13">Apple</a> say :
 <img src="https://i.imgur.com/dCD1fBB.png" alt="enter image description here" />
   <img src="https://i.imgur.com/Tc0fS6p.jpg" alt="enter image description here" /></p>

<p>   <img src="https://i.imgur.com/v2Tskwh.jpg" alt="enter image description here" /></p>

<p>iOS 9 and OSX 10.11 require TLSv1.2 SSL for all hosts you plan to request data from unless you specify exception domains in your app&rsquo;s Info.plist file.</p>

<p>The syntax for the Info.plist configuration looks like this:</p>

<pre><code>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;
&lt;dict&gt;
  &lt;key&gt;NSExceptionDomains&lt;/key&gt;
  &lt;dict&gt;
    &lt;key&gt;yourserver.com&lt;/key&gt;
    &lt;dict&gt;
      &lt;!--Include to allow subdomains--&gt;
      &lt;key&gt;NSIncludesSubdomains&lt;/key&gt;
      &lt;true/&gt;
      &lt;!--Include to allow insecure HTTP requests--&gt;
      &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;
      &lt;true/&gt;
      &lt;!--Include to specify minimum TLS version--&gt;
      &lt;key&gt;NSTemporaryExceptionMinimumTLSVersion&lt;/key&gt;
      &lt;string&gt;TLSv1.1&lt;/string&gt;
    &lt;/dict&gt;
  &lt;/dict&gt;
&lt;/dict&gt;
</code></pre>

<p>If your application (a third-party web browser, for instance) needs to connect to arbitrary hosts, you can configure it like this:</p>

<pre><code>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;
&lt;dict&gt;
    &lt;!--Connect to anything (this is probably BAD)--&gt;
    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
</code></pre>

<p>If you&rsquo;re having to do this, it&rsquo;s probably best to update your servers to use TLSv1.2 and SSL, if they&rsquo;re not already doing so. This should be considered a temporary workaround.</p>

<p>As of today, the prerelease documentation makes no mention of any of these configuration options in any specific way. Once it does, I&rsquo;ll update the answer to link to the relevant documentation.</p>

<h2>2.Demo2_iOS9 new feature  in CoreLocation :  background only when you need</h2>

<p>If you&rsquo;re using CoreLocation framework in your app in Xcode7(pre-released),and you may notice that there is a newly added property called allowsBackgroundLocationUpdates in CLLocationManager class.</p>

<p>This new property is explained in the WWDC session <a href="https://developer.apple.com/videos/wwdc/2015/?id=714">&ldquo;What&rsquo;s New in Core Location&rdquo;</a>.
 <img src="https://i.imgur.com/pvVh1fx.png" alt="enter image description here" /></p>

<p>The default value is <code>NO</code> if you link against iOS 9.</p>

<p>If your app uses location in the background (without showing the blue status bar) you have to set <code>allowsBackgroundLocationUpdates</code> to <code>YES</code> in addition to setting the background mode capability in Info.plist. Otherwise location updates are only delivered in foreground. The advantage is that you can now have location managers with background location updates and other location managers with only foreground location updates in the same app. You can also reset the value to <code>NO</code> to change the behavior.</p>

<p>The documentation is pretty clear about it:</p>

<blockquote><p>By default, this is NO for applications linked against iOS 9.0 or
later, regardless of minimum deployment target.</p>

<p>With UIBackgroundModes set to include &ldquo;location&rdquo; in Info.plist, you
must also set this property to YES at runtime whenever calling
-startUpdatingLocation with the intent to continue in the background.</p>

<p>Setting this property to YES when UIBackgroundModes does not include
&ldquo;location&rdquo; is a fatal error.</p>

<p>Resetting this property to NO is equivalent to omitting &ldquo;location&rdquo;
from the UIBackgroundModes value.  Access to location is still
permitted whenever the application is running (ie not suspended), and
has sufficient authorization (ie it has WhenInUse authorization and is
in use, or it has Always authorization).  However, the app will still
be subject to the usual task suspension rules.</p>

<p>See -requestWhenInUseAuthorization and -requestAlwaysAuthorization for
more details on possible authorization values.</p></blockquote>

<p>Set  Info.plist like：
 <img src="https://i.imgur.com/MAoKbUe.png" alt="enter image description here" /></p>

<p>The syntax for the Info.plist configuration looks like this:</p>

<pre><code>&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;
&lt;string&gt;微博@iOS程序犭袁 请求后台定位权限&lt;/string&gt;

&lt;key&gt;UIBackgroundModes&lt;/key&gt;
&lt;array&gt;
    &lt;string&gt;location&lt;/string&gt;
&lt;/array&gt;
</code></pre>

<p>Use like:</p>

<pre><code>_locationManager = [[CLLocationManager alloc] init];
_locationManager.delegate = self;
[_locationManager setDesiredAccuracy:kCLLocationAccuracyBest];
if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8) {
    [_locationManager requestAlwaysAuthorization];
}
if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 9) {
    _locationManager.allowsBackgroundLocationUpdates = YES;
}
[_locationManager startUpdatingLocation];
</code></pre>

<h2>3.iOS9 Untrusted Enterprise Developer with no option to trust</h2>

<p>Since iOS9 there is no option to trust an enterprise build.
Before iOS9，it&rsquo;s very easy to use:if you touch the app,it&rsquo;ll apear this :</p>

<p> <img src="http://i.stack.imgur.com/WwF76.png" alt="enter image description here" /></p>

<p>Now:</p>

<p> <img src="https://i.imgur.com/Skn9iXk.png" alt="enter image description here" /></p>

<p>You have to let the user  do like:
Go to Settings - General - Profiles - tap on your Profile - tap on Trust button.</p>

<p>  <img src="https://i.imgur.com/AdGNYHe.gif" alt="enter image description here" /></p>

<h2>4.bitcode optional</h2>

<p>After Xcode 7,bitcode option will be enabled by default,If your library was compiled without bitcode but the bitcode option is enabled in your project settings.You can</p>

<blockquote><ol>
<li>Update your library with bit code, or you&rsquo;ll get warnings like:</li>
</ol>


<p>(null): URGENT: all bitcode will be dropped because
&lsquo;/Users/myname/Library/Mobile
Documents/com~apple~CloudDocs/foldername/appname/GoogleMobileAds.framework/GoogleMobileAds(GADSlot+AdEvents.o)&rsquo;
was built without bitcode. You must rebuild it with bitcode enabled
(Xcode setting ENABLE_BITCODE), obtain an updated library from the
vendor, or disable bitcode for this target. Note: This will be an
error in the future.</p>

<ol>
<li>Say NO to Enable Bitcode in your target Build Settings</li>
</ol>


<p> <img src="https://i.imgur.com/OoOogUe.gif" alt="enter image description here" /></p></blockquote>

<p>and the Library Build Settings to remove the warnings</p>

<p>For more information,go to
<a href="https://developer.apple.com/library/prerelease/watchos/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35-SW2">documentation of bitcode in developer library</a></p>

<p>,and WWDC 2015 Session 102: <a href="https://developer.apple.com/videos/wwdc/2015/?id=102">&ldquo;Platforms State of the Union&rdquo;</a></p>

<p> <img src="http://mobileforward.net/wp-content/uploads/2015/06/Screen-Shot-2015-06-12-at-6.57.54-PM-697x351.png" alt="enter image description here" /></p>

<h2>5.Privacy and Your App【URL scheme changes】</h2>

<p>iOS 9 has made a small change to the handling of URL scheme. You must whitelist the url&rsquo;s that your app will call out to using the <code>LSApplicationQueriesSchemes</code> key in your <code>Info.plist</code>.</p>

<p>Please see post here: <a href="http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes">http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes</a></p>

<p>The main conclusion is that:</p>

<blockquote><p>If you call the “canOpenURL” method on a URL that is not in your whitelist, it will return “NO”, even if there is an app installed that has registered to handle this scheme. A “This app is not allowed to query for scheme xxx” syslog entry will appear.</p>

<p>If you call the “openURL” method on a URL that is not in your whitelist, it will fail silently. A “This app is not allowed to query for scheme xxx” syslog entry will appear.</p></blockquote>

<p>The author also speculates that this is a bug with the OS and Apple will fix this in a subsequent release.</p>

<p>This is a new security feature of iOS 9. Watch <a href="https://developer.apple.com/videos/wwdc/2015/?id=703">WWDC 2015 Session 703</a> for more information.</p>

<p> <img src="https://i.imgur.com/2HxWQqq.png" alt="enter image description here" /></p>

<p>Any app built with SDK 9 needs to provide a <code>LSApplicationQueriesSchemes</code> entry in its plist file, declaring which schemes it attempts to query.</p>

<pre><code>&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;
&lt;array&gt;
 &lt;string&gt;urlscheme&lt;/string&gt;
 &lt;string&gt;urlscheme2&lt;/string&gt;
 &lt;string&gt;urlscheme3&lt;/string&gt;
 &lt;string&gt;urlscheme4&lt;/string&gt;
&lt;/array&gt; 
</code></pre>

<h2>6. Support Slide Over and Split View of iOS 9</h2>

<p><img src="http://cdn1.tnwcdn.com/wp-content/blogs.dir/1/files/2015/06/ew-.gif" alt="enter image description here" />
How to transition an an older project to support Slide Over and Split View of iOS 9？
You may find that all the demo projects was written by storyboard or xib,
but the older project&rsquo;s UI is written by code！</p>

<p>I would suggest switching to storyboards to make your life easy.</p>

<p>I would highly recommend you watch the following WWDC videos and then think about what exactly you need to do in order to support multi tasking.</p>

<ol>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=218">Mysteries of Auto Layout, Part 1</a></p></li>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=215">What&rsquo;s New in Storyboards</a></p></li>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=407">Implementing UI Designs in Interface Builder</a></p></li>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=205">Getting Started with Multitasking on iPad in iOS 9</a></p></li>
<li><p><a href="https://developer.apple.com/videos/wwdc/2015/?id=212">Optimizing Your App for Multitasking on iPad in iOS</a></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apple Watch 和 iPhone 通信实践]]></title>
    <link href="http://ba-xiang.com//blog/iPhone-watch-communication.html"/>
    <updated>2015-04-26T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/iPhone-watch-communication</id>
    <content type="html"><![CDATA[<p>给 iPhone App 添加 Watch App 支持需要在 iPhone 工程中添加 Watch Extension，添加后工程中对应生成两个新的target：WatchKit Extension 和 WatchKit App，分别对应逻辑和界面。开发完成后，WatchKit Extension 和 iPhone App 被一起安装到 iPhone 中，如果 iPhone 有匹配的 Watch，系统会提示是否需要将 WatchKit App 安装到 Watch 上。</p>

<!--more-->


<h2>WatchKit Extension</h2>

<p>WatchKit Extension 是 iPhone App 和 Watch App 通信的桥梁，下图展示了三者间的通信过程：</p>

<p><img src="http://ba-xiang.com//images/tech/iPhoneWatchCommunication/iphone_watch_communication.png" alt="list app" /></p>

<h3>1、Extension 和 Watch App ( Host App )的通信</h3>

<p>在 Extension 中可以获取到 Watch App 界面元素的数据接口 WKInterfaceObject（非控件 View 本身，更接近于 Model），通过修改 WKInterfaceObject 的数据，来修改对应Watch App的界面。</p>

<p>另外通过Xcode将Watch App控件的响应事件绑定到Extension中，可以实现Watch操作响应逻辑的处理。</p>

<p>Extension和Watch App的通信在开发实现层面上看起来相对比较简单，开发者只需在接口上实现相关逻辑就可以了，而具体的通信过程，苹果进行了封装，对开发者是不可见的。</p>

<h3>2、Extension 和 iPhone App ( Containing App )的通信</h3>

<p>Extension 和 iPhone App 之间的一种通信方式是读写同一块共享存储空间，达到数据交换的目的目的（见下图）。需要注意的是 Extension 和 iPhone App 属于不同的进程，要共享存储空间，需要在工程对应的 target 中同时打开 App Groups 的权限，并选择共享的组名（打开权限需要在 Xcode 中配置开发者账号和密码，同时本地需要有对应的开发证书）。</p>

<p>但是修改存储文件，并没有达到直接通信的目的。存在这样的问题：iPhone App 对文件进行了修改，Extension 并不知道文件发生了修改，很显然，我们需要通过通知机制告诉 Extension 文件发生了修改，你可以更新新的数据了，本文最后的 Demo 会实现这样的效果。</p>

<p><img src="http://ba-xiang.com//images/tech/iPhoneWatchCommunication/share_container.png" alt="list app" /></p>

<p>Extension 和 iPhone App 另外一种通信方式是 Extension 主动向 iPhone App 发起请求，进行某种操作，或者请求数据（场景：Watch 收到新邮件通知后，点击已读按钮，在 iPhone App 上置已读）。</p>

<p>Extension 发起请求：</p>

<pre><code>+ (BOOL)openParentApplication:(NSDictionary *)userInfo
                        reply:(void (^)(NSDictionary *replyInfo,
                                        NSError *error))reply
</code></pre>

<p>iPhone App 回应请求：</p>

<pre><code>- (void)application:(UIApplication *)application
handleWatchKitExtensionRequest:(NSDictionary *)userInfo
              reply:(void (^)(NSDictionary *replyInfo))reply
</code></pre>

<h2>Demo</h2>

<p><a href="https://github.com/mutualmobile/MMWormhole">MMWormhole</a>通过共享存储空间和通知机制实现 Extension 和 iPhone  App 的通信。利用了 CFNotificationCenter 中的 Darwin notification center 来实现进程间通信，即通知机制的实现。大家如果有兴趣可以看看代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用WatchKit实现Page-Based Navigation]]></title>
    <link href="http://ba-xiang.com//blog/watchkit-pagebase-navigation.html"/>
    <updated>2015-04-25T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/watchkit-pagebase-navigation</id>
    <content type="html"><![CDATA[<p>这篇文章向大家展示如何使用WatchKit创建Page-Based Navigation，我们还是在Helloworld项目的基础上进行改善。</p>

<!-- more -->


<h2>创建Controller</h2>

<p>打开<code>Interface.storyboard</code>，再添加两个Interface Controller，然后给它们添加不同的背景色。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-1.png" alt="pic" /></p>

<p>现在给每个Controller之间添加Segue，选中第一个Controller，按着control+鼠标左键拖拽至第二个Controller，然后选择next page。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-2.png" alt="pic" /></p>

<p>编译运行，看看它是如何工作的：</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-3.gif" alt="pic" /></p>

<h2>Interface Controller生命周期</h2>

<p>接下来我们自定义两个<code>WKInterfaceController</code>，分别设置给新添加的两个Interface Controller。然后我们来看看InterfaceController的生命周期。首先在<code>GreenInterfaceController</code>和<code>RedInterfaceController</code>中添加如下三个方法：</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-4.png" alt="pic" /></p>

<p>编译运行，当Watch模拟器显示出内容时，在控制台中我们可以看到<code>GreenInterfaceController</code>和<code>RedInterfaceController</code>执行了<code>init</code>方法：</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-5.png" alt="pic" /></p>

<p>当切换到绿色InterfaceController时，在控制台中可以看到<code>GreenInterfaceController</code>执行了<code>willActivate</code>方法：</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-6.png" alt="pic" />
当切换到粉红色InterfaceController时，在控制台中可以看到<code>RedInterfaceController</code>执行了<code>willActivate</code>方法，而<code>GreenInterfaceController</code>执行了<code>didDeactivate</code>方法：</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-7.png" alt="pic" /></p>

<p>所以由此可见InterfaceController的生命周期主要由三个方法组成：</p>

<ul>
<li><strong>initWithContext</strong>：当Watch App第一次启动，把三个InterfaceController压入栈的时候调用该方法。</li>
<li><strong>willActivate</strong>：当进入InterfaceController时，调用该方法。类似<code>UIViewController</code>中的<code>viewDidAppear</code>方法。</li>
<li><strong>didDeactivate</strong>：当InterfaceController不在当前屏幕显示时调用该方法。类似<code>UIViewController</code>中的<code>viewDidDisappear</code>方法。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用WatchKit创建Table]]></title>
    <link href="http://ba-xiang.com//blog/watchkit-create-table.html"/>
    <updated>2015-04-23T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/watchkit-create-table</id>
    <content type="html"><![CDATA[<p>上篇文章向大家演示了如何创建一个Helloworld Apple Watch App。这篇文章向大家演示如何使用WatchKit给你的Watch App创建Table。我们在Helloworld项目的基础上进行完善。</p>

<!-- more -->


<h2>创建一个Table</h2>

<p>打开<strong>Interface.storyboard</strong>文件，删除我们之前添加的Label，然后将一个Table组件拖拽到你的Watch屏幕中。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-1.png" alt="pic" /></p>

<p>这里要注意一下，WatchKit中每一个WKInterfaceTableRow都是一个<strong>Table Row Controller</strong>，如果你展开它，你会发现它里面有一个<strong>Group</strong>，我们分别将一个Label和Image组件拖拽至Group中。调整Label和Image的大小，调整到你觉得合适就可以。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-2.png" alt="pic" /></p>

<h2>创建自定义的Table Row Controller</h2>

<p>我们选中TableRowController，然后选择右侧工具栏的Identify inspector，我们可以在<strong>Custom Class</strong>一栏中看到，其实TableRowController是一个<strong>NSObject</strong>。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-3.png" alt="pic" /></p>

<p>我们可以创建一个自己的NSObject，然后将TableRowController的class设置为我们创建的NSObject，这样就达到了自定义的目的。我们在<strong>HelloworldWatchKit WatchKit Extension</strong>目录中创建一个Swfit文件，让它继承NSObject，然后导入WatchKit框架。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-4.png" alt="pic" /></p>

<p>将TableRowController的class设置为<code>MyTableRowController</code>，并给它设置一个Identifier。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-5.png" alt="pic" /></p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-6.png" alt="pic" /></p>

<p>现在你就可以在<code>MyTableRowController</code>中添加Label和Image的<strong>IBOutlet</strong>了。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-7.png" alt="pic" /></p>

<h2>创建数据源</h2>

<p>我们知道，在UIKit的<code>UITableView</code>或者<code>UITableViewController</code>中都有DataSource，负责Table Row中的数据，但是在WatchKit中的TableRowController并没有DataSource，但是这个概念是有的，也就是说我们要为TableRowController创建一个数据源，不论是数组还是字典。在这里，我们创建一个数组，作为TableRowController的数据源，数组中的元素都是<code>String</code>。因为我们的TableRowController中有一个Image组件、一个Label组件，所以我们将图片的名字作为数组的元素。</p>

<p>我们在<code>InterfaceController</code>中创建一个数据源<code>weather</code>数组，数组元素是图片名称，然后创建Table的IBOutlet。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-8.png" alt="pic" /></p>

<h2>加载数据源</h2>

<p>我们在<code>InterfaceController</code>中添加<code>loadTableData()</code>方法，然后在<code>init()</code>方法中调用。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-9.png" alt="pic" /></p>

<p>现在编译运行一下，你就会看到Watch中显示出了Table，是不是很酷呢！</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-10.png" alt="pic" /></p>

<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-11.png" alt="pic" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Helloworld Apple Watch App]]></title>
    <link href="http://ba-xiang.com//blog/helloworld-watchkit-app.html"/>
    <updated>2015-04-22T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/helloworld-watchkit-app</id>
    <content type="html"><![CDATA[<p>首先我们需要下载最新的<a href="https://developer.apple.com/xcode/downloads/">Xcode 6.2</a>。
启动Xcode，选择<strong>Create a new Xcode project</strong>， 然后选择<strong>Single View Application</strong>创建一个单视图应用。</p>

<!-- more -->


<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app1.png" alt="PIC" /></p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app2.png" alt="PIC" /></p>

<h2>创建Watch App Target</h2>

<p>选择菜单中的<strong>File -> New -> Target</strong>， 然后选择<strong>Apple Watch -> Watch App</strong>， 点击<strong>Next</strong>。</p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app3.png" alt="PIC" /></p>

<p>在Target的基本属性设置界面中不要勾选<strong>Include Notification Scene</strong> 和<strong>Include Glance Scene</strong>这两个选项，因为我们是在做一个<strong>Hello World</strong>， 最后点击<strong>Finish</strong>完成 <strong>Watch App Target</strong>的创建。</p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app4.png" alt="PIC" /></p>

<h2>添加Label</h2>

<p>打开<strong>HelloworldWatchKit Watch App</strong>目录下的 <strong>Interface.storyboard</strong>。</p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app5.png" alt="PIC" /></p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app6.png" alt="PIC" /></p>

<p>然后将一个Label拖拽到<code>InterfaceController</code>中，在Label中输入文字“Hello，World!”，并将Label的<strong>Position</strong>属性设置为 <strong>Horizontal:Center，Vertical:Center</strong>，让Label居中。这里不再需要AutoLayout。</p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app7.png" alt="PIC" /></p>

<h2>运行App</h2>

<p>首先选择Active Scheme为<strong>HelloworldWatchKit Watch App</strong>， 然后选择任意型号的iPhone模拟器。</p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app8.png" alt="PIC" /></p>

<p>运行应用，这时你可能还看不到Apple Watch模拟器，别着急，这里还需要一个设置。选择iPhone模拟器，在菜单中选择<strong>Hardware -> External Displays -> Apple Watch - 38mm | Apple Watch - 42mm</strong>。</p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app9.png" alt="PIC" /></p>

<p>然后重新运行应用，你就会看到你的第一个Apple Watch App了！</p>

<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app10.png" alt="PIC" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WatchKit初探]]></title>
    <link href="http://ba-xiang.com//blog/watchkit-initial-impressions.html"/>
    <updated>2015-04-20T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/watchkit-initial-impressions</id>
    <content type="html"><![CDATA[<p>总体而言，WatchKit第一版SDK提供的功能远远超出了我的期望。因为我原本以为第一版WatchKit可能侧重于对iOS Today Extension功能的延伸，而不是真正开发Watch App。所以当知道真相后，我即惊讶又感到高兴，第一版WatchKit并不是我所想的那样，它可以为Watch App创建全新的交互界面，而且可以通过iOS App Extension去控制他们。</p>

<!-- more -->


<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-1.jpg" alt="pic" /></p>

<p>所以我们能做的并不只是一个简单的所谓iOS Apple Watch Extension的玩意，而是有很多新的功能需要我们去挖掘。目前提供的比如特定的UI控制方式  、Glance、可自定义的Notification、和Handoff的深度结合、图片缓存等等，作为开发者，这些功能已经让我为之兴奋了。</p>

<h2>Apple Watch的架构</h2>

<p>WatchKit带给我的惊讶之一是它的架构。目前Watch App的运行是由两部分相互结合进行工作的:</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-2.jpg" alt="pic" /></p>

<ul>
<li><strong>你的Apple Watch</strong>主要包含用户界面元素文件（Storyboard文件和静态的图片文件）和处理用户的输入行为。并不会真正在Apple Watch中运行代码。换句话说，Apple Watch仅是一个“视图”容器。</li>
<li><strong>你的iPhone</strong>包含所有的逻辑代码用于响应用户在Apple Watch上产生的诸如应用启动、点击按钮、滑动滑杆等行为。换言之，iPhone包含了控制器和模型。</li>
</ul>


<p>有趣的是Apple Watch和iPhone的这种交互是在幕后自动完成的。你要做的工作只是在Storyboard中设置好UI的Outlet，然后其他的事都由WatchKit SDK在幕后通过蓝牙技术自动进行交互。即使iPhone和Apple Watch是两个独立的设备，你也只需要关注你本地的代码以及Outlet的连接情况，这真是一件很酷的事情。</p>

<h2>WatchKit布局</h2>

<p>一个令我惊讶的是Watch App的UI布局方式，我们不能再用AutoLayout进行布局了。取而代之的是一种新的布局方式<strong>Group</strong>，你需要将界面元素比如按钮、Label添加到Group中，然后Group会自动为你添加的界面元素在其内部进行布局。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-3.jpg" alt="pic" /></p>

<p>你可以将一个Group嵌入到另一个Group中，用于实现较为复杂一点的界面布局，并在Group中还可以设置背景色、边距、圆角半径等属性。</p>

<p>这让我想起了Java中的<a href="https://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html">BoxLayout</a>或者XAML中的<a href="http://msdn.microsoft.com/en-us/library/ms754152.aspx">StackPanel</a>。</p>

<h2>Glances和Notifications</h2>

<p>Watch App中最酷的功能我觉得就是Glances和Notifications了。我个人认为，Apple Watch的应用中最有用的功能之一就是能让用户很方便的（比如一抬手）就能看到自己感兴趣的事物的提醒通知，比如有人在Twitter中提及到了你或者比特币现在的价位等等。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-4.jpg" alt="pic" /></p>

<p>Glances和Notifications能为你带来什么呢？</p>

<ul>
<li><strong>Glances</strong>能让你在应用中快速预览信息，有点像iOS8中的Today Extension。</li>
<li><strong>Notifications</strong>能让你在Apple Watch中接收到各类通知。Apple Watch中的通知分为两种级别。第一种是提示，只显示应用图标和简单的文本信息。当你抬起手腕或者点击屏幕时就会进入到第二种级别，你就可以看到该通知更多详细的信息，甚至有交互按钮。</li>
</ul>


<p>在Glance和Notification这两种情形下，你都可以点击屏幕进入到对应的Watch App中，并且使用Handoff。你甚至可以将特定的View Controller作为Glance或Notification的内容发送给用户。</p>

<p>我预期在未来几个月我们会在Glance和Notification上面投入较大的时间。</p>

<h2>动画</h2>

<p>Apple Watch中不支持动画，这多少让人觉得有点奇怪。如果你希望某个UI元素具有动画效果，你必须要生成一堆图片，这些图片的内容是连续动画每一帧的内容，然后循环显示这些图片，感觉又回到了GIF动画时代。所以在Apple Watch中不支持iOS中UIView或CALayer这种动画，只支持帧动画。</p>

<p>举个例子，你们可以看看Apple的<a href="https://developer.apple.com/library/prerelease/ios/samplecode/Lister/Introduction/Intro.html">Lister example</a>示例，你会发现Apple通过360张图片来实现一个画圆的动画效果。</p>

<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-5.jpg" alt="pic" /></p>

<p>这显然是一个灾难性的工作量，不过如果需要，也可以借助某些工具去生成一个动画需要的所有图片。不过，因为Apple Watch的容量很悠闲，所以你要谨慎加入帧动画，因为需要大量图片占用内存，除非有画龙点睛的动画，否则还是尽量少使用动画。</p>

<h2>设计资源</h2>

<p>如果你是一名设计者（或者对设计有浓厚的兴趣爱好），一下两点建议对你有很好的帮助：</p>

<ol>
<li>放下你手中所有的事情，阅读Apple提供的针对Apple Watch的<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/WatchHumanInterfaceGuidelines/index.html">Human Interface Guidelines (HIG)</a>。里面有非常不错的指导和参考能帮助你理解Apple Watch UI设计中你有疑惑的地方，因为设计Apple Watch App是一个全新的世界。</li>
<li>你一定要下载<a href="https://developer.apple.com/watchkit/#agreement">Apple Watch Design Resources</a>。这里有大量关于设计Apple Watch App的PSD素材，比如UI控制模型、颜色、元素间距的指导、笔画粗细的指导等等，有很多有用的东西，给我留下了非常深刻的印象，这里强烈推荐。</li>
</ol>


<p>原文地址：<a href="http://www.raywenderlich.com/89473/watchkit-initial-impressions">WatchKit: Initial Impressions</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在同个工程中使用 Swift 和 Objective-C]]></title>
    <link href="http://ba-xiang.com//blog/6-Swift%20and%20Objective-C%20in%20the%20Same%20Project.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/6-Swift and Objective-C in the Same Project</id>
    <content type="html"><![CDATA[<p>Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 <code>mix and match</code> 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。</p>

<!-- more -->


<h3>Mix and Match 概述</h3>

<p>Objective-C 和 Swift 文件可以在一个工程中并存，不管这个工程原本是基于 Objective-C 还是 Swift。你可以直接往现有工程中简单地添加另一种语言的源文件。这种自然的工作流使得创建混合语言的应用或框架 target，与用单独一种语言时一样简单。</p>

<p>混合语言的工作流程只有一点点区别，这取决于你是在写应用还是写框架。下面描述了普通的用两种语言在一个 target 中导入模型的情况，后续章节会有更多细节。</p>

<p><img src="https://raw.githubusercontent.com/haolloyin/Welcome-to-Swift/translate/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/DAG_2x.png?raw=true" alt="DAG_2x.png" /></p>

<p><a name="importing_code_from_within_the_same_app_target"></a></p>

<h3>在同个应用的 target 中导入</h3>

<p>如果你在写混合语言的应用，可能需要用 Swift 代码访问 Objective-C 代码，或者反之。下面的流程描述了在非框架 target 中的应用。</p>

<h4>将 Objective-C 导入 Swift</h4>

<p>在一个应用的 target 中导入一些 Objective-C 文件供 Swift 代码使用时，你需要依赖于 Objective-C 的桥接头文件（<code>bridging header</code>）来暴露给 Swift。当你添加 Swift 文件到现有的 Objective-C 应用（或反之）时，Xcode 会自动创建这些头文件。</p>

<p><img src="https://raw.githubusercontent.com/haolloyin/Welcome-to-Swift/translate/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/bridgingheader_2x.png?raw=true" alt="bridgingheader_2x.png" /></p>

<p>如果你同意，Xcode 会在源文件创建的同时生成头文件，并用 product 的模块名加上 <code>-Bridging-Header.h</code> 命名。关于 product 的模块名，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85">Naming Your Product Module</a>。</p>

<p>你应该编辑这个头文件来对 Swift 暴露出 Objective-C 代码。</p>

<h5>在同一 target 中将 Objective-C 代码导入到 Swift 中</h5>

<ol>
<li>在 Objective-C 桥接头文件中，import 任何你想暴露给 Swift 的头文件，例如：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// OBJECTIVE-C</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#import &quot;XYZCustomCell.h&quot;</span>
</span><span class='line'><span class="cp">#import &quot;XYZCustomView.h&quot;</span>
</span><span class='line'><span class="cp">#import &quot;XYZCustomViewController.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>确保在 <code>Build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
</ol>


<p>这个路径应该是你工程的相对路径，类似 <code>Info.plist</code> 在 <code>Build Settings</code> 中指定的路径。在大多数情况下，你不需要修改这个设置。</p>

<p>在这个桥接头文件中列出的所有 public 的 Objective-C 头文件都会对 Swift 可见。之后当前 target 的所有 Swift 文件都可以使用这些头文件中的方法，不需要任何 import 语句。用 Swift 语法使用这些 Objective-C 代码，就像使用系统自带的 Swift 类一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// SWIFT</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">myCell</span> <span class="o">=</span> <span class="n">XYZCustomCell</span><span class="p">()</span>
</span><span class='line'><span class="n">myCell</span><span class="p">.</span><span class="n">subtitle</span> <span class="o">=</span> <span class="s">&quot;A custom cell&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>将 Swift 导入 Objective-C</h4>

<p>向 Objective-C 中导入Swift 代码时，你依赖 Xcode 生成的头文件来向 Objective-C 暴露 Swift 代码。这是自动生成 Objective-C 头文件，它包含了你的 target 中所有 Swift 代码中定义的接口。可以把这个 Objective-C 头文件看作 Swift 代码的 <code>umbrella header</code>。它以 product 模块名加 <code>-Swift.h</code> 来命名。关于 product 的模块名，详见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85">Naming Your Product Module</a>。</p>

<p>你不需要做任何事情来生成这个头文件，只需要将它导入到你的 Objective-C 代码来使用它。注意这个头文件中的 Swift 接口包含了它所使用到的所有 Objective-C 类型。如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</p>

<h5>在同一 target 中将 Swift 代码导入到 Objective-C 中</h5>

<ul>
<li>在相同 target 的 Objective-C .m 源文件中，用下面的语法来导入Swift 代码：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// OBJECTIVE-C</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#import &quot;ProductModuleName-Swift.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>target 中任何 Swift 文件将会对 Objective-C .m 源文件可见，包括这个 import 语句。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84">Using Swift from Objective-C</a>。</p>

<table>
<thead>
<tr>
<th>              </th>
<th style="text-align:center;"> 导入到 Swift </th>
<th style="text-align:center;"> 导入到 Objective-C  </th>
</tr>
</thead>
<tbody>
<tr>
<td> Swift 代码    </td>
<td style="text-align:center;"> 不需要import语句  </td>
<td style="text-align:center;"> #import &ldquo;ProductModuleName-Swift.h”  </td>
</tr>
<tr>
<td> Objective-C 代码     </td>
<td style="text-align:center;"> 不需要import语句；需要 Objective-C bridging头文件</td>
<td style="text-align:center;"> #import &ldquo;Header.h&rdquo;     </td>
</tr>
</tbody>
</table>


<p><a name="importing_code_from_within_the_same_framework_target"></a></p>

<h3>在同个 Framework 的 target 中导入</h3>

<p>如果你在写一个混合语言的框架，可能会从 Swift 代码访问 Objective-C 代码，或者反之。</p>

<h4>将 Objective-C 导入 Swift</h4>

<p>要将一些 Objective-C 文件导入到同个框架 target 的 Swift 代码中去，你需要将这些文件导入到 Objective-C 的 <code>umbrella header</code> 来供框架使用。</p>

<h6>在同一 framework 中将 Objective-C 代码导入到 Swift 中</h6>

<p>确保将框架 target 的 <code>Build Settings &gt; Packaging &gt; Defines Module</code> 设置为 <code>Yes</code>。然后在你的 <code>umbrella header</code> 头文件中导入你想暴露给 Swift 访问的 Objective-C 头文件，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// OBJECTIVE-C</span>
</span><span class='line'><span class="cp">#import &lt;XYZ/XYZCustomCell.h&gt;</span>
</span><span class='line'><span class="cp">#import &lt;XYZ/XYZCustomView.h&gt;</span>
</span><span class='line'><span class="cp">#import &lt;XYZ/XYZCustomViewController.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 将会看到所有你在 <code>umbrella header</code> 中公开暴露出来的头文件，框架 target 中的所有 Swift 文件都可以访问你 Objective-C 文件的内容，不需要任何 import 语句。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// SWIFT</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">myCell</span> <span class="o">=</span> <span class="n">XYZCustomCell</span><span class="p">()</span>
</span><span class='line'><span class="n">myCell</span><span class="p">.</span><span class="n">subtitle</span> <span class="o">=</span> <span class="s">&quot;A custom cell&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>将 Swift 导入 Objective-C</h4>

<p>要将一些 Swift 文件导入到同个框架的 target 的 Objective-C 代码去，你不需要导入任何东西到 <code>umbrella header</code> 文件，而是将 Xcode 为你的 Swift 代码自动生成的头文件导入到你的 Obj .m 源文件去，以便在 Objective-C 代码中访问 Swift 代码。</p>

<h6>在同一 framework 中将 Swift 代码导入到 Objective-C 中</h6>

<p>确保将框架 target 的 <code>Build Settings &gt; Packaging</code> 中的 <code>Defines Module</code> 设置为 <code>Yes</code>。用下面的语法将 Swift 代码导入到同个框架 target 下的 Objective-C .m 源文件去。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// OBJECTIVE-C</span>
</span><span class='line'><span class="cp">#import &lt;ProductName/ProductModuleName-Swift.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个 import 语句所包含的 Swift 文件都可以被同个框架 target 下的 Objective-C .m 源文件访问。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84">Using Swift from Objective-C</a>。</p>

<table>
<thead>
<tr>
<th>              </th>
<th style="text-align:center;"> 导入到 Swift </th>
<th style="text-align:center;"> 导入到 Objective-C  </th>
</tr>
</thead>
<tbody>
<tr>
<td> Swift 代码    </td>
<td style="text-align:center;"> 不需要import语句  </td>
<td style="text-align:center;"> #import &ldquo;ProductName/ProductModuleName-Swift.h&rdquo;  </td>
</tr>
<tr>
<td> Objective-C 代码     </td>
<td style="text-align:center;"> 不需要import语句；需要 Objective-C umbrella头文件</td>
<td style="text-align:center;"> #import &ldquo;Header.h&rdquo;     </td>
</tr>
</tbody>
</table>


<p><a name="importing_external_frameworks"></a></p>

<h3>导入外部 Framework</h3>

<p>你可以导入外部框架，不管这个框架是纯 Objective-C，纯 Swift，还是混合语言的。import 外部框架的流程都是一样的，不管这个框架是用一种语言写的，还是包含两种语言。当你导入外部框架时，确保 <code>Build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>。</p>

<p>用下面的语法将框架导入到不同 target 的 Swift 文件中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// SWIFT</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="n">FrameworkName</span>
</span></code></pre></td></tr></table></div></figure>


<p>用下面的语法将框架导入到不同 target 的 Objective-C .m 文件中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// OBJECTIVE-C</span>
</span><span class='line'>
</span><span class='line'><span class="p">@</span><span class="n">import</span> <span class="n">FrameworkName</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th>           </th>
<th style="text-align:center;"> 导入到 Swift </th>
<th style="text-align:center;"> 导入到 Objective-C  </th>
</tr>
</thead>
<tbody>
<tr>
<td>任意语言框架 </td>
<td style="text-align:center;"> import FrameworkName </td>
<td style="text-align:center;"> @import FrameworkName; </td>
</tr>
</tbody>
</table>


<p><a name="using_swift_from_objective-c"></a></p>

<h3>在 Objective-C 中使用 Swift</h3>

<p>当你将 Swift 代码导入 Objective-C 文件之后，用普通的 Objective-C 语法使用 Swift 类。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// OBJECTIVE-C</span>
</span><span class='line'>
</span><span class='line'><span class="n">MySwiftClass</span> <span class="o">*</span><span class="n">swiftObject</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MySwiftClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">swiftObject</span> <span class="n">swiftMethod</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 的类或协议必须用 <code>@Objective-C attribute</code> 来标记，以便在 Objective-C 中可访问。这个 attribute 告诉编译器这个 Swift 代码可以从 Objective-C 代码中访问。如果你的 Swift 类是 Objective-C 类的子类，编译器会自动为你添加 <code>@Objective-C attribute</code>。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_36">Swift Type Compatibility</a>。</p>

<p>你可以访问 Swift 类或协议中用 <code>@Objective-C attribute</code> 标记过东西，只要它和 Objective-C 兼容。不包括以下这些 Swift 独有的特性：</p>

<ul>
<li><p>Generics - 范型</p></li>
<li><p>Tuples - 元组</p></li>
<li><p>Enumerations defined in Swift - Swift 中定义的枚举</p></li>
<li><p>Structures defined in Swift - Swift 中定义的结构体</p></li>
<li><p>Top-level functions defined in Swift - Swift 中定义的顶层函数</p></li>
<li><p>Global variables defined in Swift - Swift 中定义的全局变量</p></li>
<li><p>Typealiases defined in Swift - Swift 中定义的类型别名</p></li>
<li><p>Swift-style variadics  - Swift风格可变参数</p></li>
<li><p>Nested types - 嵌套类型</p></li>
<li><p>Curried functions - 柯里化后的函数</p></li>
</ul>


<p>例如带有范型类型作为参数，或者返回元组的方法不能在 Objective-C 中使用。</p>

<p>为了避免循环引用，不要将 Swift 代码导入到 Objective-C 头文件中。但是你可以在 Objective-C 头文件中前向声明（<code>forward declare</code>）一个 Swift 类来使用它，然而，注意<strong>不能在 Objective-C 中继承一个 Swift 类</strong>。</p>

<h3>在 Objective-C 头文件中引用 Swift 类</h3>

<p>这样前向声明 Swift 类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// OBJECTIVE-C</span>
</span><span class='line'><span class="c1">// MyObjective-CClass.h</span>
</span><span class='line'>
</span><span class='line'><span class="k">@class</span> <span class="nc">MySwiftClass</span>;
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyObjective</span><span class="o">-</span><span class="nl">CClass</span> <span class="p">:</span> <span class="bp">NSObject</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">MySwiftClass</span> <span class="o">*</span><span class="p">)</span><span class="n">returnSwiftObject</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* ... */</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><a name="naming_your_product_module"></a></p>

<h3>Product 模块命名</h3>

<p>Xcode 为 Swift 代码生成的头文件的名称，以及 Xcode 创建的 Objective-C 桥接头文件名称，都是从你的 product 模块名生成的。默认你的 product 模块名和 product 名一样。然而，如果你的 product 名有特殊字符（nonalphanumeric，非数字、字母的字符），例如点号，那么它们会被下划线（<code>_</code>）替换之后作为你的 product 模块名。如果 product 名以数字开头，那么第一个数字会用下划线替换掉。</p>

<p>你可以给 product 模块名提供一个自定义的名称，Xcode 会用这个名称来命名桥接的和自动生成的头文件。你只需要在修改在 <code>build setting</code> 中的 <code>Product Module Name</code> 即可。</p>

<p><a name="troubleshooting_tips_and_reminders"></a></p>

<h3>问题解决提示</h3>

<ul>
<li>把 Swift 和 Objective-C 文件看作相同的代码集合，并注意命名冲突；</li>
<li>如果你用框架，确保 <code>Build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>；</li>
<li>如果你使用 Objective-C 桥接头文件，确保在 <code>Build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录；</li>
<li>Xcode 使用你的 product 模块名，而不是 target 名来命名 Objective-C 桥接头文件和为 Swift 自动生成的头文件。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85">Naming Your Product Module</a>；</li>
<li>为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 <code>@Objective-C</code> 标记；</li>
<li>当你将 Swift 导入到 Objective-C 中时，记住 Objective-C 不会将 Swift 独有的特性翻译成 Objective-C 对应的特性。详见列表 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84">Using Swift from Objective-C</a>；</li>
<li>如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件 import 到 Objective-C .m 源文件中来访问 Swift 代码。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与 C 语言交互编程]]></title>
    <link href="http://ba-xiang.com//blog/5-Interacting%20with%20C%20APIs.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/5-Interacting with C APIs</id>
    <content type="html"><![CDATA[<p>作为一种可与 Objective-C 相互调用的语言，Swift 也具有一些与 C 语言的类型和特性，如果你的代码有需要，Swift 也提供了和常见的 C 代码结构混合编程的编程方式。<!--more--></p>

<h3>基本数据类型</h3>

<p>Swift 提供了一些和 C 语言的基本类型如<code>char</code>，<code>int</code>，<code>float</code>，<code>double</code>等价的 Swift 基本数据类型。然而，这些 Swift 的核心基本类型之间并不能隐式的相互转换，如 Int。因此，只有你的代码明确要求它们时再使用这些类型，而 Int 可以在任何你想使用它的时候使用。</p>

<table>
<thead>
<tr>
<th> C 类型 </th>
<th> Swift 类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td> bool </td>
<td> CBool </td>
</tr>
<tr>
<td> char, signed char </td>
<td> CChar </td>
</tr>
<tr>
<td> unsigned char </td>
<td> CUnsignedChar </td>
</tr>
<tr>
<td> short </td>
<td> CShort </td>
</tr>
<tr>
<td> unsigned short </td>
<td> CUnsignedShort </td>
</tr>
<tr>
<td> int </td>
<td> CInt </td>
</tr>
<tr>
<td> unsigned int </td>
<td> CUnsignedInt </td>
</tr>
<tr>
<td> long </td>
<td> CLong </td>
</tr>
<tr>
<td> unsigned long </td>
<td> CUnsignedLong </td>
</tr>
<tr>
<td> long long </td>
<td> CLongLong </td>
</tr>
<tr>
<td> unsigned long long </td>
<td> CUnsignedLongLong </td>
</tr>
<tr>
<td> wchar_t </td>
<td> CWideChar </td>
</tr>
<tr>
<td> char16_t </td>
<td> CChar16 </td>
</tr>
<tr>
<td> char32_t </td>
<td> CChar32 </td>
</tr>
<tr>
<td> float </td>
<td> CFloat </td>
</tr>
<tr>
<td> double </td>
<td> CDouble </td>
</tr>
</tbody>
</table>


<p><a name="enumerations"></a></p>

<h3>枚举</h3>

<p>Swift 引进了用宏<code>NS_ENUM</code>来标记的任何 C 风格的枚举类型。这意味着无论枚举值是在系统框架还是在自定义的代码中定义的，当他们导入到 Swift 时，他们的前缀名称将被截断。例如，看这个 Objective-C 枚举：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Objective-C</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">,</span> <span class="n">UITableViewCellStyle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">UITableViewCellStyleDefault</span><span class="p">,</span>
</span><span class='line'>  <span class="n">UITableViewCellStyleValue1</span><span class="p">,</span>
</span><span class='line'>  <span class="n">UITableViewCellStyleValue2</span><span class="p">,</span>
</span><span class='line'>  <span class="n">UITableViewCellStyleSubtitle</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Swift 中这样来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">enum</span> <span class="nl">UITableViewCellStyle</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">Default</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">Value1</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">Value2</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">Subtitle</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当您需要指向一个枚举值时，使用以点（.）开头的枚举名称：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="nl">cellStyle</span><span class="p">:</span> <span class="n">UITableViewCellStyle</span> <span class="o">=</span> <span class="p">.</span><span class="n">Default</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 也引进了标有<code>NS_OPTIONS</code>宏选项。而选项的行为类似于引进的枚举，选项还可以支持一些位操作，如 ＆，| 和 〜。在 Objective-C 中，你用一个空的选项设置标示恒为零（0）。在 Swift 中，使用 <code>nil</code>代表没有任何选项。</p>

<p><a name="pointer"></a></p>

<h3>指针</h3>

<p>Swift 尽可能避免让您直接访问指针。然而，当您需要直接操作内存的时候，Swift 也为您提供了多种指针类型。下面的表使用 Type 作为占位符类型名称来表示语法的映射。</p>

<p>对于参数，使用以下映射：</p>

<table>
<thead>
<tr>
<th> C 句法 </th>
<th> Swift 句法 </th>
</tr>
</thead>
<tbody>
<tr>
<td> const void * </td>
<td> CConstVoidPointer </td>
</tr>
<tr>
<td> void * </td>
<td> CMutableVoidPointer </td>
</tr>
<tr>
<td> const Type * </td>
<td> CConstPointer\&lt;Type> </td>
</tr>
<tr>
<td> Type * </td>
<td> CMutablePointer\&lt;Type> </td>
</tr>
</tbody>
</table>


<p>对于返回类型，变量和参数类型的多层次指针，使用以下映射：</p>

<table>
<thead>
<tr>
<th> C 句法 </th>
<th> Swift 句法 </th>
</tr>
</thead>
<tbody>
<tr>
<td> void * </td>
<td> COpaquePointer </td>
</tr>
<tr>
<td> Type * </td>
<td> UnsafePointer\&lt;Type> </td>
</tr>
</tbody>
</table>


<p>对于类（class）类型，使用以下映射：</p>

<table>
<thead>
<tr>
<th> C 句法 </th>
<th> Swift 句法 </th>
</tr>
</thead>
<tbody>
<tr>
<td> Type * const * </td>
<td> CConstPointer\&lt;Type> </td>
</tr>
<tr>
<td> Type * __strong * </td>
<td> CMutablePointer\&lt;Type> </td>
</tr>
<tr>
<td> Type ** </td>
<td> AutoreleasingUnsafePointer\&lt;Type> </td>
</tr>
</tbody>
</table>


<h4>C 可变指针</h4>

<p>当一个函数被声明为接受<code>CMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>

<ul>
<li><code>nil</code>，作为空指针传入</li>
<li>一个<code>CMutablePointer&lt;Type&gt;</code>类型的值</li>
<li>一个操作数是 <code>Type</code> 类型的左值的输入输出表达式，作为这个左值的内存地址传入</li>
<li>一个输入输出 <code>Type[]</code> 值，作为一个数组的起始指针传入，并且它的生命周期将在这个调用期间被延长</li>
</ul>


<p>如果您像这样声明了一个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">func</span> <span class="nf">takesAMutablePointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">CMutablePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">var</span> <span class="nl">x</span><span class="p">:</span> <span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="k">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">CMutablePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="k">var</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Float</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">takesAMutablePointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutablePointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutablePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutablePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当函数被声明使用一个<code>CMutableVoidPointer</code>参数，那么这个函数接受任何和<code>CMutablePointer&lt;Type&gt;</code>相似类型的<code>Type</code>操作数。</p>

<p>如果您这样定义了一个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">func</span> <span class="nf">takesAMutableVoidPointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">CMutableVoidPointer</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">var</span> <span class="nl">x</span><span class="p">:</span> <span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">CMutablePointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">,</span> <span class="nl">q</span><span class="p">:</span> <span class="n">CMutablePointer</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="k">var</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Float</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAMutableVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>C 常指针</h4>

<p>当一个函数被声明为接受<code>CConstPointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>

<ul>
<li><code>nil</code>，作为空指针传入</li>
<li>一个<code>CMutablePointer&lt;Type&gt;</code>, <code>CMutableVoidPointer</code>, <code>CConstPointer&lt;Type&gt;</code>, <code>CConstVoidPointer</code>,  或者在必要情况下转换成<code>CConstPointer&lt;Type&gt;</code>的<code>AutoreleasingUnsafePointer&lt;Type&gt;</code>值</li>
<li>一个操作数是 <code>Type</code> 类型的左值的输入输出表达式，作为这个左值的内存地址传入</li>
<li>一个<code>Type[]</code>数组值，作为一个数组的起始指针传入，并且它的生命周期将在这个调用期间被延长</li>
</ul>


<p>如果您这样定义了一个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">func</span> <span class="nf">takesAConstPointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">CConstPointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">var</span> <span class="nl">x</span><span class="p">:</span> <span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="k">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">CConstPointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>
</span><span class='line'><span class="n">takesAConstPointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAConstPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAConstPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAConstPointer</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>当函数被声明使用一个<code>CConstVoidPointer</code>参数，那么这个函数接受任何和<code>CConstPointer&lt;Type&gt;</code> 相似类型的<code>Type</code>操作数。
￼
如果您这样定义了一个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="err">￼￼￼￼</span><span class="k">func</span> <span class="n">takesAConstVoidPointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">CConstVoidPointer</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">var</span> <span class="nl">x</span><span class="p">:</span> <span class="n">Float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="k">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">CConstPointer</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">,</span> <span class="nl">q</span><span class="p">:</span> <span class="n">CConstPointer</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>
</span><span class='line'><span class="n">takesAConstVoidPointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAConstVoidPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAConstVoidPointer</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAConstVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAConstVoidPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAConstVoidPointer</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
</span><span class='line'><span class="n">takesAConstVoidPointer</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<h4>自动释放不安全指针</h4>

<p>当一个函数被声明为接受<code>AutoreleasingUnsafePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>

<ul>
<li><code>nil</code>，作为空指针传入</li>
<li>一个<code>AutoreleasingUnsafePointer&lt;Type&gt;</code>值</li>
<li>其操作数是原始的，复制到一个临时的没有所有者的缓冲区的一个输入输出表达式，该缓冲区的地址传递给调用，并返回时，缓冲区中的值加载，保存，并重新分配到操作数。</li>
</ul>


<p><strong>注意：这个列表没有包含数组。</strong></p>

<p>如果您这样定义了一个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">func</span> <span class="nf">takesAnAutoreleasingPointer</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">AutoreleasingUnsafePointer</span><span class="o">&lt;</span><span class="bp">NSDate</span><span class="o">?&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么您可以使用以下任何一种方式来调用这个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">var</span> <span class="nl">x</span><span class="p">:</span> <span class="bp">NSDate</span><span class="o">?</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="k">var</span> <span class="nl">p</span><span class="p">:</span> <span class="n">AutoreleasingUnsafePointer</span><span class="o">&lt;</span><span class="bp">NSDate</span><span class="o">?&gt;</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'><span class="err">￼￼￼￼￼</span>
</span><span class='line'><span class="n">takesAnAutoreleasingPointer</span><span class="p">(</span><span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAnAutoreleasingPointer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="n">takesAnAutoreleasingPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：C 语言函数指针没有被 Swift 引进。</strong></p>

<p><a name="global_constants"></a></p>

<h3>全局常量</h3>

<p>在 C 和 Objective-C 语言源文件中定义的全局常量会自动地被 Swift 编译引进并做为 Swift 的全局常量。</p>

<p><a name="preprocessor_directives"></a></p>

<h3>预处理指令</h3>

<p>Swift 编译器不包含预处理器。取而代之的是，它充分利用了编译时属性，生成配置，和语言特性来完成相同的功能。因此，Swift 没有引进预处理指令。</p>

<h4>简单宏</h4>

<p>在 C 和 Objective-C，您通常使用的#define指令定义的一个宏常数，在 Swift，您可以使用全局常量来代替。例如：一个全局定义<code>#define FADE_ANIMATION_DURATION 0.35</code>，在 Swift 可以使用<code>let FADE_ANIMATION_DURATION = 0.35</code>来更好的表述。由于简单的用于定义常量的宏会被直接被映射成 Swift 全局量，Swift 编译器会自动引进在 C 或 Objective-C 源文件中定义的简单宏。</p>

<h4>复杂宏</h4>

<p>在 C 和 Objective-C 中使用的复杂宏在 Swift 中并没有与之对应的定义。复杂宏是那些不用来定义常量的宏，而是用来定义包含小括号（），函数的宏。您在 C 和 Objective-C 使用复杂的宏是用来避免类型检查的限制和相同代码的重复劳动。然而，宏也会产生Bug和重构的困难。在 Swift 中你可以直接使用函数和泛型来达到同样的效果。因此，在 C 和 Objective-C 源文件中定义的复杂宏在 Swift 是不能使用的。</p>

<h4>编译配置</h4>

<p>Swift 代码和 Objective-C 代码以不同的方式进行条件编译。Swift 代码可以根据生成配置的评价配进行有条件的编译。生成配置包括 <code>true</code> 和 <code>false</code> 字面值，命令行标志，和下表中的平台测试函数。您可以使用-D \&lt;＃Flag＃>指定命令行标志。</p>

<table>
<thead>
<tr>
<th> 函数 </th>
<th> 有效参数 </th>
</tr>
</thead>
<tbody>
<tr>
<td> os() </td>
<td> OSX, iOS </td>
</tr>
<tr>
<td> arch() </td>
<td> x86_64, arm, arm64, i386 </td>
</tr>
</tbody>
</table>


<blockquote><p>注意</p>

<p>arch(arm) 的生成配置不会为64位 ARM 设备返回<code>true</code>，当代码运行在为32位的 iOS 模拟器器时，arch(i386) 的生成配置返回<code>true</code>。</p></blockquote>

<p>一个简单的条件编译需要以下代码格式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cp">#if build configuration</span>
</span><span class='line'>  <span class="n">statements</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>  <span class="n">statements</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>`</p>

<p>一个由零个或多个有效的 Swift 语句声明的<code>statements</code>，可以包括表达式，语句和控制流语句。您可以添加额外的构建配置要求，条件编译说明用 &amp;&amp; 和 | | 操作符以及 ！ 操作符，添加条件控制块用 ＃elseif：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cp">#if build configuration &amp;&amp; !build configuration</span>
</span><span class='line'>  <span class="n">statements</span>
</span><span class='line'><span class="cp">#elseif build configuration</span>
</span><span class='line'>  <span class="n">statements</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>  <span class="n">statements</span>
</span><span class='line'><span class="cp">#endif </span>
</span></code></pre></td></tr></table></div></figure>


<p>与 C 语言编译器的条件编译相反，Swift 条件编译语句必须完全是自包含和语法有效的代码块。这是因为 Swift 代码即使没有被编译，也要全部进行语法检查。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[采用Cocoa设计模式]]></title>
    <link href="http://ba-xiang.com//blog/4-Adopting%20Cocoa%20Design%20Patterns.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/4-Adopting Cocoa Design Patterns</id>
    <content type="html"><![CDATA[<p>使用 Cocoa 现有的一些设计模式，是帮助开发者开发一款拥有合理设计思路、稳定的性能、良好的可扩展性应用的有效方法之一。这些模式都依赖于在 Objective-C 中定义的类。因为 Swift 与 Objective-C 的互用性，所以你依然可以在 Swift 代码中使用这些设计模式。在一些情况下，你甚至可以使用 Swift 语言的特性扩展或简化这些 Cocoa 设计模式，使这些设计模式更强大、更易于使用。</p>

<!--more-->


<h2>委托（Delegation）</h2>

<p>在 Swift 和 Objective-C 中，委托通常由一个定义交互方法和遵循规范的委托属性的协议表示。与 Objective-C 相比，当你在 Swift 中继承一个委托时，虽然继承模式不变，但是内部的实现已经改变了。就像在 Objective-C 中，在你向委托发送消息之前，不管它是不是 <code>nil</code> 你都会去查看，如果定义的方法是非必须实现的方法，不管委托有没有实现这个方法，你也都会去查看。而在 Swift 中，通过保持类型安全的特性，可以有效的消除这些繁琐、不必要的行为问题。<br />
下面列出的代码可以说明这个过程：<br />
1. 检查 <code>myDelegate</code> 不为 <code>nil</code>。<br />
2. 检查 <code>myDelegate</code> 是否实现了继承的 <code>window:willUseFullScreenContentSize:</code> 方法。<br />
3. 如果<code>myDelegate</code> 不为 <code>nil</code> 并且实现了 <code>window:willUseFullScreenContentSize:</code> 方法，那么调用该方法，将该方法的返回值分配给名为 <code>fullScreenSize</code> 的属性。<br />
4. 将该方法的返回值输出在控制台。<br /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// @inteface MyObject : NSObject</span>
</span><span class='line'><span class="c1">// @property (nonatomic, weak) id&lt;NSWindowDelegate&gt; delegate;</span>
</span><span class='line'><span class="c1">// @end</span>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">fullScreenSize</span> <span class="o">=</span> <span class="n">myDelegate</span><span class="o">?</span><span class="p">.</span><span class="n">window</span><span class="o">?</span><span class="p">(</span><span class="n">myWindow</span><span class="p">,</span> <span class="nl">willUseFullScreenContentSize</span><span class="p">:</span> <span class="n">mySize</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">NSStringFromSize</span><span class="p">(</span><span class="n">fullScreenSize</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：
在一个完全使用 Swift 编写的 app 中，在定义 <code>delegate</code> 属性时，它作为一个不定值的 <code>NSWindowDelegate</code> 对象，并将初始值设为 <code>nil</code>。</p></blockquote>

<p><a name="Lazy_Initialization"></a></p>

<h3>延迟初始化（Lazy Initialization）</h3>

<p>你可以在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14">Lazy Stored Properties</a> 中了解到更多关于延迟初始化的信息。</p>

<p><a name="Error_Reporting"></a></p>

<h3>错误报告（Error Reporting）</h3>

<p>Swift 中的错误报告模式沿用了 Objective-C 的模式，但 Swift 中不定值返回值的新特性给我们带来了额外的好处。举个很简单的例子，你用 <code>Bool</code> 值作为一个函数的返回值，用于标识该函数是否执行成功，当你需要输出错误信息时，你可以在函数中添加一个 <code>NSErrorPointer</code> 类型的输出参数 <code>NSError</code>。这个类型类似 Objective-C 中的 <code>NSError **</code>，并增加了内存安全性和非强制性的传参。你可以使用 <code>&amp;</code> 运算符作为前缀引用一个不定值 <code>NSError</code> 类型作为 <code>NSErrorPointer</code> 对象传递错误信息。如下面的代码所示：<br /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">writeError</span> <span class="p">:</span> <span class="bp">NSError</span><span class="o">?</span>
</span><span class='line'><span class="k">let</span> <span class="n">written</span> <span class="o">=</span> <span class="n">myString</span><span class="p">.</span><span class="n">writeToFile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nl">atomically</span><span class="p">:</span> <span class="nb">false</span><span class="p">,</span>
</span><span class='line'>    <span class="nl">encoding</span><span class="p">:</span> <span class="n">NSUTF8StringEncoding</span><span class="p">,</span>
</span><span class='line'>    <span class="nl">error</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">writeError</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="o">!</span><span class="n">written</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">error</span> <span class="o">=</span> <span class="n">writeError</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;write failure: \(error.localizedDescription)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你实现自己的方法时，你需要配置一个 <code>NSErrorPointer</code> 对象，并将 <code>NSErrorPointer</code> 对象的 <code>memory</code> 属性设为你创建的 <code>NSError</code> 对象。首先检查调用者传递的参数，确保它是一个非 <code>nil</code> 的 <code>NSError</code> 对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">contentsForType</span><span class="p">(</span><span class="nl">typeName</span><span class="p">:</span> <span class="n">String</span><span class="o">!</span> <span class="nl">error</span><span class="p">:</span> <span class="n">NSErrorPointer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyObject</span><span class="o">!</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">cannotProduceContentsForType</span><span class="p">(</span><span class="n">typeName</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">error</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">error</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="bp">NSError</span><span class="p">(</span><span class="nl">domain</span><span class="p">:</span> <span class="n">domain</span><span class="p">,</span> <span class="nl">code</span><span class="p">:</span> <span class="n">code</span><span class="p">,</span> <span class="nl">userInfo</span><span class="p">:</span> <span class="p">[</span><span class="o">:</span><span class="p">])</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a name="Key-Value_Observing"></a></p>

<h2>键值观察（Key-Value Observing）</h2>

<p>尽请期待。</p>

<p><a name="Target_Action"></a></p>

<h2>Target-Action模式（Target-Action）</h2>

<p>当有特定事件发生，需要一个对象向另一个对象发送消息时，我们通常采用 Cocoa 的 Target-Action 设计模式。Swift 和 Objective-C 中的 Target-Action 模型基本类似。在 Swift 中，你可以使用 <code>Selector</code> 类型达到 Objective-C 中 selectors 的效果。请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_37">Objective-C Selectors</a> 中查看在 Swift 中使用 Target-Action 设计模式的示例。</p>

<p><a name="Introspection"></a></p>

<h2>类型匹配与统一规范（Introspection）</h2>

<p>在 Objective-C 中，你可以使用 <code>isKindOfClass:</code> 方法检查某个对象是否是指定类型，可以使用 <code>conformsToProtocol:</code> 方法检查某个对象是否遵循特定协议的规范。在 Swift 中，你可以使用 <code>is</code> 运算符完成上述的功能，或者也可以使用 <code>as?</code> 向下匹配指定类型。<br />
你可以使用 <code>is</code> 运算符检查一个实例是否是指定的子类。如果该实例是指定的子类，那么 <code>is</code> 运算结果为 <code>true</code>，反之为 <code>false</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="n">object</span> <span class="kt">is</span> <span class="bp">UIButton</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object is of type UIButton</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object is not of type UIButton</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你也可以使用 <code>as?</code> 运算符尝试向下匹配子类型，<code>as?</code> 运算符返回不定值，结合 <code>if-let</code> 语句使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">button</span> <span class="o">=</span> <span class="n">object</span> <span class="kt">as</span><span class="o">?</span> <span class="bp">UIButton</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object is successfully cast to type UIButton and bound to button</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object could not be cast to type UIButton</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22">Type Casting</a> 中查看更多信息。<br />
检查匹配协议的语法与检查匹配类的语法是一样的，下面是使用 <code>as?</code> 检查匹配协议的示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">dataSource</span> <span class="o">=</span> <span class="n">object</span> <span class="kt">as</span><span class="o">?</span> <span class="bp">UITableViewDataSource</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object conforms to UITableViewDataSource and is bound to dataSource</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// object not conform to UITableViewDataSource</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，当做完匹配之后，<code>dataSource</code> 会转换为  <code>UITableViewDataSource</code> 类型，所以你只能访问和调用<code>UITableViewDataSource</code> 协议定义的属性和方法。当你想进行其他操作时，必须将其转换为其他的类型。<br />
可以在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25">Protocols</a> 查看更多相关信息。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与 Cocoa 数据类型共舞]]></title>
    <link href="http://ba-xiang.com//blog/3-Working%20with%20Cocoa%20Data%20Types.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/3-Working with Cocoa Data Types</id>
    <content type="html"><![CDATA[<p>作为对 Objective-C 互用性（互操作性）的一部分，Swift提供快捷高效的方式来处理 Cocoa 数据类型。</p>

<p>Swift 会自动将一些 Objective-C 类型转换为 Swift 类型，以及将 Swift 类型转换为 Objective-C 类型。在 Objective-C 和 Swift 中也有一些具有互用性的数据类型。那些可转换的数据类型或者具有互用性的数据类型被称为<em>bridged</em>数据类型。举个例子，在 Swift 中，您可以将一个<code>Array</code>值传递给一个要求为<code>NSArray</code>对象的方法。你也可以转换一个 bridged 类型和它的副本。当你使用<code>as</code>转换 bridged 类型或者那些由常量和变量所提供的类型时，Swift 会桥接它们的数据类型。</p>

<p>Swift 也提供一种简单便捷的覆盖方法来连接 Foundation 的数据类型，在后面的 Swift 语言中，你能在它的句法中感受到自然和统一。</p>

<!--more-->


<p><a name = "strings"></a></p>

<h3>字符串</h3>

<p>Swift会在<code>String</code>类型和<code>NSString</code>类型中自动转换。这意味着在可以使用<code>NSString</code>对象的地方，您可以使用一个属于 Swift 的<code>String</code>类型代替它，这样做会同时拥有它们数据类型的特点，<code>String</code>类型的插值，基于Swift设计的APIs以及<code>NSString</code>类更广的适用范围。因此，您几乎不必再在你的代码中使用<code>NSString</code>类。事实上，当 Swift 接入 Objective-C APIs 时，它将把所有<code>NSString</code>类型替换为<code>String</code>类型。当您在您的Objective-C代码中使用 Swift 类时，接入的API会将所有<code>String</code>类型替换成<code>NSString</code>类型。</p>

<p>为了允许字符串转换，只需接入 Foundation。举个例子，您在 Swift 的一个字符串中调用了<code>capitalizedString</code>&ndash;一个<code>NSString</code>类的方法，此后 Swift 会自动将<code>String</code>转换为一个<code>NSString</code>对象并调用方法。这个方法甚至会返回一个 Swift 的<code>String</code>类型，因为它在接入的时候被替换了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">import</span> <span class="n">Foundation</span>
</span><span class='line'><span class="k">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;hello, world!&quot;</span>
</span><span class='line'><span class="k">let</span> <span class="n">capitalizedGreeting</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">.</span><span class="n">capitalizedString</span>
</span><span class='line'><span class="c1">// capitalizedGreeting: String = Hello, World!</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果您确实需要用到一个<code>NSString</code>对象，您可以用一个 Swift 的<code>String</code>值并转换它。<code>String</code>类型总是可以从一个<code>NSString</code>对象转换为一个Swift的<code>String</code>的值，因此，再没有必要去使用一个可选的类型转换器<code>()as?)</code>。您也可以在一个字符串中通过定义常量和变量来创建一个<code>NSString</code>对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">import</span> <span class="n">Foundation</span>
</span><span class='line'><span class="k">let</span> <span class="nl">myString</span><span class="p">:</span> <span class="bp">NSString</span> <span class="o">=</span> <span class="s">&quot;123&quot;</span>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">integerValue</span> <span class="o">=</span> <span class="p">(</span><span class="n">myString</span> <span class="kt">as</span> <span class="n">String</span><span class="p">).</span><span class="n">toInt</span><span class="p">()){</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(myString) is the integer \(integerValue)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>本地化</h4>

<p>在Objective-C中，常用<code>NSLocalizedString</code>类的宏来定位一个字符串。这集合的宏包括<code>NSLocalizedStringFromTableInBundle</code>和<code>NSLocalizedStringWithDefaultValue</code>。而在Swift中，只用一个函数就可以实现跟整个<code>NSLocalizedString</code>集一样的功能，即<code>NSLocalizedString(key:tableName:bundle:value:comment:)</code>。这个<code>NSLocalizedString</code>函数分别为<code>tableName</code>，<code>bundle</code>和<code>value</code>参数提供了一个默认值。你可以用它来替换宏。</p>

<p><a name = "numbers"></a></p>

<h3>数字</h3>

<p>Swift会自动将已确定的数字类型<code>Int</code>和<code>Float</code>转换为<code>NSNumber</code>。这样的转换允许你基于其中一种类型创建一个<code>NSNumber</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">42</span>
</span><span class='line'><span class="k">let</span> <span class="nl">m</span><span class="p">:</span> <span class="bp">NSNumber</span> <span class="o">=</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure>


<p>你也能传递一个<code>Int</code>类型的值，比如传递给一个要求为<code>NSNumber</code>类型的参数。同时需要注意的是，<code>NSNumber</code>可以包含多种不同的类型，因此您不能把它传递给单一的一个<code>Int</code>值。</p>

<p>下面所列出的类型都会自动转换为<code>NSNumber</code>：</p>

<ul>
<li><code>Int</code></li>
<li><code>UInt</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Bool</code></li>
</ul>


<p><a name = "collection_classes"></a></p>

<h3>类集合</h3>

<p>Swift 会自动将<code>NSArray</code>和<code>NSDictionary</code>类转换为Swift里等价的类。这意味着你将受益于Swift强大的算法和得天独厚的语法来处理集合&ndash;可互相转换的 Foundation 和 Swift 集合类型。</p>

<h4>数组</h4>

<p>Swift 会在<code>Array</code>类型和<code>NSArray</code>类型中自动转换。当你从一个 Swift 数组转换到一个<code>NSArray</code>对象，转换后的数组是一个<code>AnyObject[]</code>类型的数组。如果某个对象是 Objective-C 或者 Swift 类的实例，或者这个对象可以转换成另一种类型，那么这个对象则属于<code>AnyObject</code>类型的对象。你可以将任一<code>NSArray</code>对象转换成一个 Swift 数组，因为所有 Objective-C 的对象都是<code>AnyObject</code>类型的。正因如此，Swift 的编译器会在接入 Objective-C APIs 的时候将<code>NSArray</code>类替换成<code>AnyObject[]</code>。</p>

<p>当你将一个<code>NSArray</code>对象转换成一个 Swift 数组后，你也可以将数组强制类型转换成一个特定的类型。与从<code>NSArray</code>类转换到<code>AnyObject[]</code>不同的是，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功。由于直到运行时编译器才知道<code>AnyObject</code>的对象能否被强制转换为特定的类型，因此，从<code>AnyObject[]</code>转换为<code>SomeType[]</code>会返回一个 optional 的值。举个例子，如果你知道一个Swift数组只包含<code>UIView</code>类的实例(或者一个<code>UIView</code>类的子类)，你可以将<code>AnyObject</code>类型的数组元素强制转换为<code>UIView</code>对象。如果Swift数组中的元素在运行时不是<code>UIView</code>类型的对象，那么转换则会返回<code>nil</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">swiftyArray</span> <span class="o">=</span> <span class="n">foundationArray</span> <span class="kt">as</span> <span class="n">AnyObject</span><span class="p">[]</span>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">downcastedSwiftArray</span> <span class="o">=</span> <span class="n">swiftArray</span> <span class="kt">as</span><span class="o">?</span> <span class="bp">UIView</span><span class="p">[]</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// downcastedSwiftArray contains only UIView objects</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你也可以在for循环中将NSArray对象定向地强制转换为特定类型的Swift数组:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="nl">aView</span><span class="p">:</span> <span class="bp">UIView</span><span class="o">!</span> <span class="k">in</span> <span class="n">foundationArray</span> <span class="p">{</span>
</span><span class='line'>     <span class="c1">// aView is of type UIView</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：这种转换是强制转换，如果转换不成功则会在运行时产生错误信息。</p></blockquote>

<p>当你从 Swift 数组转换为<code>NSArray</code>对象时，Swift 数组里的元素必须是属于<code>AnyObject</code>的。例如，一个<code>Int[]</code>类型的 Swift 数组包含<code>Int</code>结构的元素。<code>Int</code>类型并不是一个类的实例，但由于<code>Int</code>类型转换成了<code>NSNumber</code>类，<code>Int</code>类型属于<code>AnyObject</code>类型的。因此，你可以将一个<code>Int[]</code>类型的Swift数组转换为<code>NSArray</code>对象。如果 Swift 数组里的一个元素不属于<code>AnyObject</code>类型，那么在运行时就会产生错误。</p>

<p>你也可以从 Swift 数组中创建一个<code>NSArray</code>对象。当你将一个常量或变量定义为一个<code>NSArray</code>对象并分配一个数组给它作为实例变量时，Swift 将会创建 <code>NSArray</code>对象，而不是 Swift 数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">schoolSupplies</span><span class="p">:</span> <span class="bp">NSArray</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Pencil&quot;</span><span class="p">,</span> <span class="s">&quot;Eraser&quot;</span><span class="p">,</span> <span class="s">&quot;Notebkko&quot;</span><span class="p">]</span>
</span><span class='line'><span class="c1">// schoolSupplies is an NSArray object containing NSString objects</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子中，Swift 数组包含包含三个<code>String</code>字符串。由于从<code>String</code>类型转换为<code>NSString</code>类，数组字面量被转换成一个<code>NSArray</code>对象，并成功分配给<code>schoolSupplies</code>变量。</p>

<p>当您在 Objective-C 代码中使用 Swift 类或者协议时，接入的API会将全部所有类型的Swift数组代替为<code>NSArray</code>。若您将一个<code>NSArray</code>对象传递给Swift的API并要求数组元素为一个新的类型，运行时就会产生错误。如果 Swift API 返回一个不能被转换为<code>NSArray</code>类型的 Swift 数组，错误也会随之产生。</p>

<h4>字典</h4>

<p>敬请期待</p>

<p><a name = "foundation_data_types"></a></p>

<h3>Foundation数据类型</h3>

<p>Swift 也提供一种简单便捷的覆盖方法来连接定义在 Foundation 框架中的数据类型。在<code>NSSize</code>和<code>NSPoint</code>中使用覆盖方法，在剩下的 Swift 语言中，你能在它的句法中感受到自然和统一。比如，你可以使用如下语法创建一个<code>NSSize</code>类型的结构:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="n">NSSize</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mi">40</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>覆盖方法也允许你以一种自然的方式调用 Foundation 的结构函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">NSRect</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="nl">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="k">let</span> <span class="n">width</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">width</span>    <span class="c1">// equivalent of NSWidth(rect)</span>
</span><span class='line'><span class="k">let</span> <span class="n">maxX</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">maxY</span>      <span class="c1">// equivalent of NSMaxY(rect)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift可以将<code>NSUInteger</code>和<code>NSInteger</code>转换为<code>Int</code>类型。这些类型都会在 Foundation APIs 中变为<code>Int</code>类型。在 Swift 中<code>Int</code>常被尽可能地用以连贯性，同时当你要求一个无符号整数类型时，<code>UInt</code>类型总是可使用的。</p>

<p><a name = "foundation_functions"></a></p>

<h3>Foundation函数</h3>

<p>在 Swift 中，<code>NSLog</code>可在系统控制台输出信息。您可以像在 Objective-C 中使用过的语法格式那样使用此函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">&quot;%.7f&quot;</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>         <span class="c1">// Logs &quot;3.1415927&quot; to the console</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时，Swift 也提供像<code>print</code>和<code>println</code>那样的输出函数。多归于 Swift 的字符插值机制才让这些函数简单，粗暴，多效。这些函数不会在系统控制台输出信息，但在需要调用的时候却是可用的。</p>

<p>Swift 中不再存在<code>NSAssert</code>函数，取而代之的是<code>assert</code>函数。</p>

<p><a name = "core_foundation"></a></p>

<h3>Core Foundation</h3>

<p>Swift中的 Core Foundation 类型是一个成熟的类。当出现内存管理注释时，Swift 会自动地管理 Core Foundation 对象的内存，这其中包括你实例化了的 Core Foundation 对象。在 Swift 中，你可以自由变换 Fundation 和 Core Foundation 类型。如果你想先转换为桥接 Foundation 类型时，你也可以桥接一些 toll-free bridged Core Foundation 类型到 Swift 标准库类型。</p>

<h4>重定义类型</h4>

<p>当 Swift 导入 Core Foundation 类型时，编译器会重映射导入的类型名字。编译器会从每个类型名字的末端移除 <em>Ref</em>，这是因为所有的 Swift 类都属于引用类型，因此后缀是多余的。</p>

<p>Core Foundation 中的<code>CFTypeRef</code>类型会对<code>Anyobject</code>类型重映射。所以你以前使用的<code>CFTypeRef</code>，现在该换成<code>AnyObject</code>了。</p>

<h4>内存管理对象</h4>

<p>在 Swift 中，从 annotated APIs 返回的 Core Foundation 对象能够自动进行内存管理&ndash;你不再需要调用自身的<code>CFRetain</code>，<code>CFRelease</code>，或者<code>CFAutorelease</code>函数。如果你从自身的C函数和 Objective-C 方法中返回一个 Core Foundation 对象，你需要用<code>CF_RETURNS_RETAINED</code>或者<code>CF_RETURNS_NOT_RETAINED</code>注释这个对象。当 Swift 代码中包含这些 APIs 时，编译器会在编译时自动调用内存管理。如果你只调用那些不会间接返回 Core Foundation 对象的 annotated APIs，那么现在你可以跳过本节的剩余部分了。否则，下面我们继续学习非托管的 Core Foundation 对象。</p>

<h4>非托管对象</h4>

<p>当 Swift 导入 unannotated 的APIs时，编译器将不会自动地对返回的 Core Foundation 对象进行内存管理托管。Swift 将这些返回的 Core Foundation 对象封闭在一个<code>Unmanaged&lt;T&gt;</code>结构中。那些间接返回 Core Foundation 的对象也是非托管的。举个例子，这里有一个 unannotated 的 C 函数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">CFStringRef</span> <span class="n">StringByAddingTwoStrings</span><span class="p">(</span><span class="n">CFStringRef</span> <span class="n">string1</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">string2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里说明了Swift是怎么导入的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">StringByAddingTwoStrings</span><span class="p">(</span><span class="n">CFString</span><span class="o">!</span><span class="p">,</span> <span class="n">CFString</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Unmanaged</span><span class="o">&lt;</span><span class="n">CFString</span><span class="o">&gt;!</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设您从 unannotated APIs 接收了非托管的对象，在使用它之前，你必须将它转换为能够内存管理的对象。在这方面，Swift 可以帮你进行内存管理而不用自己动手。同时，<code>Unmanaged&lt;T&gt;</code>结构也提供了两个方法来把一个非托管对象转换为一个可内存管理的对象&ndash;<code>takeUnretainedValue()</code>方法和<code>takeRetainedValue()</code>方法。这两个方法会返回原始的，非封闭的对象类型。您可以根据您实际调用的APIs返回的unretained或retained的对象，来选择哪一方法更合适。</p>

<p>比如，假设这里有一个 C 函数，这个函数在返回值前不会释放<code>CFString</code>对象。在使用这个对象前，您使用<code>takeUnretainedValue()</code>函数，以将它转换为一个能够内存管理托管的对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">memoryManagedResult</span> <span class="o">=</span> <span class="n">StringByAddingTwoStrings</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">).</span><span class="n">takeUnretainedValue</span><span class="p">()</span>
</span><span class='line'><span class="c1">// memoryManagedResult is a memory managed CFString</span>
</span></code></pre></td></tr></table></div></figure>


<p>您也可以在一个非托管的对象中使用<code>retain()</code>，<code>release()</code>和<code>autorelease()</code>方法，但是这种做法并不值得推荐。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Objective-C特性编写Swift类]]></title>
    <link href="http://ba-xiang.com//blog/2-Writing%20Swift%20Classes%20with%20Objective-C%20Behavior.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/2-Writing Swift Classes with Objective-C Behavior</id>
    <content type="html"><![CDATA[<p>互用性（互操作性）使开发者可以定义融合了 Objective-C 语言特性的Swift类。编写 Swift 类时，不仅可以继承 Objective-C 语言编写的父类，采用 Objective-C 的协议，还可以利用 Objective-C 的一些其它功能。这意味着，开发者可以基于 Objective-C 中已有的熟悉、可靠的类、方法和框架来创建 Swift 类，并结合 Swift 提供的现代化和更有效的语言特点对其进行优化。</p>

<!--more-->


<p><a name="inheriting_from_objective-c_classes"></a></p>

<h3>继承Objective-C的类</h3>

<p>在 Swift 中，开发者可以定义一个子类，该子类继承自使用 Objective-C 编写的类。创建该子类的方法是，在 Swift 的类名后面加上一个冒号（:），冒号后面跟上 Objective-C 的类名。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">import</span> <span class="n">UIKit</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nl">MySwiftViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 定义类</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>开发者能够从 Objective-C 的父类中继承所有的功能。如果开发者要覆盖父类中的方法，不要忘记使用<code>override</code>关键字。</p>

<p><a name="adopting_protocols"></a></p>

<h3>采用协议</h3>

<p>在 Swift 中，开发者可以采用 Objective-C 中定义好的协议。和 Swift 协议一样，所有 Objective-C 协议都写在一个用逗号隔开的列表中，跟在所在类的父类名后面（如果它有父类的话）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="nl">MySwiftViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">UITableViewDelegate</span><span class="p">,</span> <span class="bp">UITableViewDataSource</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 定义类</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Objective-C 协议与 Swift 协议使用上是一致的。如果开发者想在 Swift 代码中引用 <code>UITableViewDelegate</code>协议，可以直接使用<code>UITableViewDelegate</code>（跟在 Objective-C 中引用<code>id&lt;UITableViewDelegate&gt;</code>是等价的）。</p>

<p><a name="writing_initializers_and_deinitializers"></a></p>

<h3>编写构造器和析构器</h3>

<p>Swift 的编译器确保在初始化时，构造器不允许类里有任何未初始化的属性，这样做能够增加代码的安全性和可预测性。另外，与 Objective-C 语言不同，Swift 不提供单独的内存分配方法供开发者调用。当你使用原生的 Swift 初始化方法时（即使是和 Objective-C 类协作），Swift 会将 Objective-C 的初始化方法转换为 Swift 的初始化方法。关于如何实现开发者自定义构造器的更多信息，请查看<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/14Initialization.md">构造器</a>。</p>

<p>当开发者希望在类被释放前，执行额外的清理工作时，需要执行一个析构过程来代替<code>dealloc</code>方法。在实例被释放前，Swift 会自动调用析构器来执行析构过程。Swift 调用完子类的析构器后，会自动调用父类的析构器。当开发者使用 Objective-C 类或者是继承自 Objective-C 类的 Swift 类时，Swift 也会自动为开发者调用这个类的父类里的<code>dealloc</code>方法。关于如何实现开发者自定义析构器的更多信息，请查看<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/15Deinitialization.md">析构器</a>。</p>

<p><a name="integrating_with_interface_builder"></a></p>

<h3>集成Interface Builder</h3>

<p>Swift 编译器包含一些属性，使得开发者的 Swift 类集成了 Interface Builder 里的一些特色功能。和 Objective-C 里一样，你能在 Swift 里面使用 outlets，actions 和实时渲染（live rendering）。</p>

<h3>使用Outlets和Action</h3>

<p>使用 Outlets 和 Action 可以连接源代码和 Interface Builder 的 UI 对象。在Swift里面使用 Outlets 和 Action，需要在属性和方法声明前插入<code>@IBOutlet</code>或者<code>@IBAction</code>关键字。声明一个 Outlet 集合同样是用<code>@IBOutlet</code>属性，即为类型指定一个数组。</p>

<p>当开发者在 Swift 里面声明了一个 Outlet 时，Swift 编译器会自动将该类型转换为弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional（Objective-C 里面对应指针类型）数据类型，并为它分配一个初始化的空值<code>nil</code>。实际上，编译器使用<code>@IBOutlet weak var name: Type! = nil</code>来代替 <code>@IBOutlet var name: Type</code>。编译器将该类型转换成了弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional 类型，因此开发者就不需要在构造器中为该类型分配一个初始值了。当开发者从故事板（storyboard）或者<code>xib</code>文件里面初始化对象 class 后，定义好的 Outlet 和这些对象连接在一起了，所以，这些 Outlet 是隐式的，未包装的。由于创建的 outlets 一般都是弱关系，因此默认 outlets 是弱类型。</p>

<p>例如，下面的 Swift 代码声明了一个拥有 Outlet、Outlet 集合和 Action 的类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="nl">MyViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">var</span> <span class="nl">button</span><span class="p">:</span> <span class="bp">UIButton</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">var</span> <span class="nl">textFields</span><span class="p">:</span> <span class="bp">UITextField</span><span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">@</span><span class="kt">IBAction</span> <span class="k">func</span> <span class="n">buttonTapped</span><span class="p">(</span><span class="n">AnyObject</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;button tapped!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在<code>buttonTapped</code>方法中，消息发送者的信息没有被使用，因此可以省略该方法的参数名。</p>

<h4>实时渲染（live rendering）</h4>

<p>开发者可以在 Interface Builder 中用<code>@IBDesignable</code>和<code>@IBInspectable</code>来创建生动、可交互的自定义视图（view）。开发者继承<code>UIView</code>或者<code>NSView</code>来自定义一个视图（view）时，可以在类声明前添加<code>@IBDesignable</code>属性。当你在 Interface Builder 里添加了自定义的视图后（在监视器面板的自定义视图类中进行设置），Interface Builder 将在画布上渲染你自定义的视图。</p>

<blockquote><p>注意：只能针对框架里对象进行实时渲染</p></blockquote>

<p>你也可以将<code>@IBInspectable</code>属性添加到和用户定义的运行时属性兼容的类型属性里。这样，当开发者将自定义的视图添加到 Interface Builder 里后，就可以在监视器面板中编辑这些属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="p">@</span><span class="n">IBDesignable</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nl">MyCustomView</span><span class="p">:</span> <span class="bp">UIView</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">@</span><span class="n">IBInspectable</span> <span class="k">var</span> <span class="nl">textColor</span><span class="p">:</span> <span class="bp">UIColor</span>
</span><span class='line'>  <span class="p">@</span><span class="n">IBInspectable</span> <span class="k">var</span> <span class="nl">iconHeight</span><span class="p">:</span> <span class="n">CGFloat</span>
</span><span class='line'>  <span class="cm">/* ... */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a name="specifying_property_attributes"></a></p>

<h3>指明属性特性</h3>

<p>在 Objective-C 中，属性通常都有一组特性（Attributes）说明来指明该属性的一些附加信息。在 Swift 中，开发者可以通过不同的方法来指明属性的这些特性。</p>

<h4>强类型和弱类型</h4>

<p>Swift 里属性默认都是强类型的。使用<code>weak</code>关键字修饰一个属性，能指明其对象存储时是一个弱引用。该关键字仅能修饰 optional 对象类型。更多的信息，请查阅<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/09Classes%20and%20Structures.md">特性</a>。</p>

<h4>读／写和只读</h4>

<p>在 Swift 中，没有<code>readwrite</code>和<code>readonly</code>特性。当声明一个存储型属性时，使用<code>let</code>修饰其为只读；使用<code>var</code>修饰其为可读／写。当声明一个计算型属性时，为其提供一个 getter 方法，使其成为只读的；提供 getter 方法和 setter 方法，使其成为可读／写的。更多信息，请查阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13">属性</a>。</p>

<h4>拷贝</h4>

<p>在 Swift 中，Objective-C 的<code>copy</code>特性被转换为<code>@NSCopying</code>属性。这一类的属性必须遵守 <code>NSCopying</code>协议。更多信息，请查阅<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/09Classes%20and%20Structures.md">特性</a>。</p>

<p><a name="implementing_core_data_managed_object_subclasses"></a></p>

<h3>实现Core Data Managed Object子类</h3>

<p>Core Data 提供了基本存储和实现<code>NSManagedObject</code>子类的一组属性。在与Core Data 模型中管理对象子类相关的特性或者关系的每个属性定义之前，将<code>@NSmanaged</code>特性加入。与 Objective-C 里面的 <code>@dynamic</code>特性类似，<code>@NSManaged</code>特性告知 Swift 编译器，这个属性的存储和实现将在运行时完成。但是，与<code>@dynamic</code>不同的是，<code>@NSManaged</code>特性仅在 Core Data 支持中可用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[与 Objective-C 的 API 交互]]></title>
    <link href="http://ba-xiang.com//blog/1-Interacting%20with%20Objective-C%20APIs.html"/>
    <updated>2015-03-16T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/1-Interacting with Objective-C APIs</id>
    <content type="html"><![CDATA[<p><strong>互用性</strong>是让 Swift 和 Objective-C 相接合的一种特性，使你能够在一种语言编写的文件中使用另一种语言。当你准备开始把 Swift 融入到你的开发流程中时，你应该懂得如何利用互用性来重新定义并提高你写 Cocoa 应用的方案。</p>

<p>互用性很重要的一点就是允许你在写 Swift 代码时使用 Objective-C 的 API 接口。当你导入一个 Objective-C 框架后，你可以使用原生的 Swift 语法实例化它的 Class 并且与之交互。</p>

<!--more-->


<p><a name="initialization"></a></p>

<h3>初始化</h3>

<p>为了使用 Swift 实例化 Objective-C 的 Class，你应该使用 Swift 语法调用它的一个初始化器。当 Objective-C 的<code>init</code>方法变化到 Swift，他们用 Swift 初始化语法呈现。“init”前缀被截断当作一个关键字，用来表明该方法是初始化方法。那些以“initWith”开头的<code>init</code>方法，“With”也会被去除。从“init”或者“initWith”中分离出来的这部分方法名首字母变成小写，并且被当做是第一个参数的参数名。其余的每一部分方法名依次变为参数名。这些方法名都在圆括号中被调用。</p>

<p>举个例子，你在使用 Objective-C 时会这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Objective-C</span>
</span><span class='line'><span class="bp">UITableView</span> <span class="o">*</span><span class="n">myTableView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UITableView</span> <span class="n">alloc</span><span class="p">]</span>
</span><span class='line'><span class="nl">initWithFrame</span><span class="p">:</span><span class="n">CGRectZero</span> <span class="nl">style</span><span class="p">:</span><span class="n">UITableViewStyleGrouped</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Swift 中，你应该这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="nl">myTableView</span><span class="p">:</span> <span class="bp">UITableView</span> <span class="o">=</span> <span class="bp">UITableView</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="n">CGRectZero</span><span class="p">,</span> <span class="nl">style</span><span class="p">:</span> <span class="p">.</span><span class="n">Grouped</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>你不需要调用 alloc，Swift 能替你处理。注意，当使用 Swift 风格的初始化函数的时候，“init”不会出现。</p>

<p>你可以在初始化时显式的声明对象的类型，也可以忽略它，Swift 能够正确判断对象的类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="n">myTextField</span> <span class="o">=</span> <span class="bp">UITextField</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的<code>UITableView</code>和<code>UITextField</code>对象和你在 Objective-C 中使用的具有相同的功能。你可以用一样的方式使用他们，包括访问属性或者调用各自的类中的方法。</p>

<p>为了统一和简易，Objective-C 的工厂方法也在 Swift 中映射为方便的初始化方法。这种映射能够让他们使用同样简洁明了的初始化方法。例如，在 Objective-C 中你可能会像下面这样调用一个工厂方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Objective-C</span>
</span><span class='line'><span class="bp">UIColor</span> <span class="o">*</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mf">0.5</span> <span class="nl">green</span><span class="p">:</span><span class="mf">0.0</span> <span class="nl">blue</span><span class="p">:</span><span class="mf">0.5</span> <span class="nl">alpha</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Swift 中，你应该这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="n">color</span> <span class="o">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="nl">red</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nl">green</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">blue</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nl">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><a name="accessing_properties"></a></p>

<h3>访问属性</h3>

<p>在 Swift 中访问和设置 Objective-C 对象的属性时，使用点语法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">myTextField</span><span class="p">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="bp">UIColor</span><span class="p">.</span><span class="n">darkGrayColor</span><span class="p">()</span>
</span><span class='line'><span class="n">myTextField</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">&quot;Hello world&quot;</span>
</span><span class='line'><span class="k">if</span> <span class="n">myTextField</span><span class="p">.</span><span class="n">editing</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">myTextField</span><span class="p">.</span><span class="n">editing</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当 get 或 set 属性时，直接使用属性名称，不需要附加圆括号。注意，<code>darkGrayColor</code>后面附加了一对圆括号，这是因为<code>darkGrayColor</code>是<code>UIColor</code>的一个类方法，不是一个属性。</p>

<p>在 Objective-C 中，一个有返回值的无参数方法可以被作为一个隐式的访问函数，并且可以与访问器使用同样的方法调用。但在 Swift 中不再能够这样做了，只有使用<code>@property</code>关键字声明的属性才会被作为属性引入。</p>

<p><a name="working_with_methods"></a></p>

<h3>方法</h3>

<p>在 Swift 中调用 Objective-C 方法时，使用点语法。</p>

<p>当 Objective-C 方法转换到 Swift 时，Objective-C 的<code>selector</code>的第一部分将会成为方法名并出现在圆括号的前面，而第一个参数将直接在括号中出现，并且没有参数名，而剩下的参数名与参数则一一对应的填入圆括号中。</p>

<p>举个例子，你在使用 Objective-C 时会这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Objective-C</span>
</span><span class='line'><span class="p">[</span><span class="n">myTableView</span> <span class="nl">insertSubview</span><span class="p">:</span><span class="n">mySubview</span> <span class="nl">atIndex</span><span class="p">:</span><span class="mi">2</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Swift 中，你应该这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">myTableView</span><span class="p">.</span><span class="n">insertSubview</span><span class="p">(</span><span class="n">mySubview</span><span class="p">,</span> <span class="nl">atIndex</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你调用一个无参方法，仍必须在方法名后面加上一对圆括号</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">myTableView</span><span class="p">.</span><span class="n">layoutIfNeeded</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><a name="id_compatibility"></a></p>

<h3>id 兼容性（id Compatibility）</h3>

<p>Swift 包含一个叫做<code>AnyObject</code>的协议类型，表示任意类型的对象，就像 Objective-C 中的<code>id</code>一样。<code>AnyObject</code>协议允许你编写类型安全的 Swift 代码同时维持无类型对象的灵活性。因为<code>AnyObject</code>协议保证了这种安全，Swift 将 id 对象导入为 AnyObject。</p>

<p>举个例子，跟 id 一样，你可以为<code>AnyObject</code>类型的对象分配任何其它类型的对象，你也同样可以为它重新分配其它类型的对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">var</span> <span class="nl">myObject</span><span class="p">:</span> <span class="n">AnyObject</span> <span class="o">=</span> <span class="bp">UITableViewCell</span><span class="p">()</span>
</span><span class='line'><span class="n">myObject</span> <span class="o">=</span> <span class="bp">NSDate</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>你也可以在调用 Objective-C 方法或者访问属性时不将它转换为具体类的类型。这包括了 Objective-C 中标记为 @objc 的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="n">futureDate</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">dateByAddingTimeInterval</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="k">let</span> <span class="n">timeSinceNow</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">timeIntervalSinceNow</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，由于直到运行时才知道<code>AnyObject</code>的对象类型，所以有可能在不经意间写出不安全代码。另外，与 Objective-C 不同的是，如果你调的用方法或者访问的属性 AnyObject 对象没有声明，将会报运行时错误。比如下面的代码在运行时将会报出一个 unrecognized selector error 错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="n">myObject</span><span class="p">.</span><span class="n">characterAtIndex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="c1">// crash, myObject does&#39;t respond to that method</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，你可以通过 Swift 的 optionals 特性来排除这个 Objective-C 中常见的错误，当你用<code>AnyObject</code>对象调用一个 Objective-C 方法时，这次调用将会变成一次隐式展开 optional（implicitly unwrapped optional）的行为。你可以通过 optional 特性来决定 AnyObject 类型的对象是否调用该方法，同样的，你可以把这种特性应用在属性上。</p>

<p>举个例子，在下面的代码中，第一和第二行代码将不会被执行因为<code>length</code>属性和<code>characterAtIndex:</code>方法不存在于 NSDate 对象中。<code>myLength</code>常量会被推测成可选的<code>Int</code>类型并且被赋值为<code>nil</code>。同样你可以使用<code>if-let</code>声明来有条件的展开这个方法的返回值，从而判断对象是否能执行这个方法。就像第三行做的一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="n">myLength</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">length</span><span class="o">?</span>
</span><span class='line'><span class="k">let</span> <span class="n">myChar</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">characterAtIndex</span><span class="o">?</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">fifthCharacter</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">characterAtIndex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Found \(fifthCharacter) at index 5&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于 Swift 中的强制类型转换，从 AnyObject 类型的对象转换成明确的类型并不会保证成功，所以它会返回一个可选的值。而你需通过检查该值的类型来确认转换是否成功。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="n">userDefaults</span> <span class="o">=</span> <span class="bp">NSUserDefaults</span><span class="p">.</span><span class="n">standardUserDefaults</span><span class="p">()</span>
</span><span class='line'><span class="k">let</span> <span class="nl">lastRefreshDate</span><span class="p">:</span> <span class="n">AnyObject</span><span class="o">?</span> <span class="o">=</span> <span class="n">userDefaults</span><span class="p">.</span><span class="n">objectForKey</span><span class="p">(</span><span class="s">&quot;LastRefreshDate&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">date</span> <span class="o">=</span> <span class="n">lastRefreshDate</span> <span class="kt">as</span><span class="o">?</span> <span class="bp">NSDate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;\(date.timeIntervalSinceReferenceDate)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，如果你能确定这个对象的类型（并且确定不是<code>nil</code>），你可以添加<code>as</code>操作符强制调用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="n">myDate</span> <span class="o">=</span> <span class="n">lastRefreshDate</span> <span class="kt">as</span> <span class="bp">NSDate</span>
</span><span class='line'><span class="k">let</span> <span class="n">timeInterval</span> <span class="o">=</span> <span class="n">myDate</span><span class="p">.</span><span class="n">timeIntervalSinceReferenceDate</span>
</span></code></pre></td></tr></table></div></figure>


<p><a name="working_with_nil"></a></p>

<h3>使用nil</h3>

<p>在 Objective-C 中，对象的引用可以是值为<code>NULL</code>的原始指针（同样也是Objective-C中的<code>nil</code>）。而在Swift中，所有的值–包括结构体与对象的引用–都被保证为非空。作为替代，你将这个可以为空的值包装为optional type。当你需要宣告值为空时，你需要使用<code>nil</code>。你可以在<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/01The%20Basics.md#optionals">Optionals</a>中了解更多。</p>

<p>因为Objective-C不会保证一个对象的值是否非空，Swift在引入Objective-C的API的时候，确保了所有函数的返回类型与参数类型都是optional，在你使用Objective-C的API之前，你应该检查并保证该值非空。
在某些情况下，你可能绝对确认某些Objective-C方法或者属性永远不应该返回一个nil的对象引用。为了让对象在这种情况下更加易用，Swift使用 implicitly unwrapped optionals 方法引入对象， implicitly unwrapped optionals 包含optional 类型的所有安全特性。此外，你可以直接访问对象的值而无需检查nil。当你访问这种类型的变量时， implicitly unwrapped optional 首先检查这个对象的值是否不存在，如果不存在，将会抛出运行时错误。</p>

<p><a name="extensions"></a></p>

<h3>扩展（Extensions）</h3>

<p>Swift 的扩展和 Objective-C 的类别（Category）相似。扩展为原有的类，结构和枚举丰富了功能，包括在 Objective-C 中定义过的。你可以为系统的框架或者你自己的类型增加扩展，只需要导入合适的模块并且保证你在 Objective-C 中使用的类、结构或枚举拥有相同的名字。</p>

<p>举个例子，你可以扩展<code>UIBezierPath</code>类来为它增加一个等边三角形，这个方法只需提供三角形的边长与起点。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">extension</span> <span class="bp">UIBezierPath</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">convenience</span> <span class="k">init</span><span class="p">(</span><span class="nl">triangleSideLength</span><span class="p">:</span> <span class="n">Float</span><span class="p">,</span> <span class="nl">origin</span><span class="p">:</span> <span class="bp">CGPoint</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">()</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">squareRoot</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">altitude</span> <span class="o">=</span> <span class="p">(</span><span class="n">squareRoot</span> <span class="o">*</span> <span class="n">triangleSideLength</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>        <span class="n">moveToPoint</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
</span><span class='line'>        <span class="n">addLineToPoint</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">(</span><span class="n">triangleSideLength</span><span class="p">,</span> <span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">))</span>
</span><span class='line'>        <span class="n">addLineToPoint</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">(</span><span class="n">triangleSideLength</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">altitude</span><span class="p">))</span>
</span><span class='line'>        <span class="n">closePath</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你也可以使用扩展来增加属性（包括类的属性与静态属性）。然而，这些属性必须是通过计算才能获取的，扩展不会为类，结构体，枚举添加存储属性。下面这个例子为<code>CGRect</code>类增加了一个叫<code>area</code>的属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">extension</span> <span class="bp">CGRect</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">area</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">let</span> <span class="n">rect</span> <span class="o">=</span> <span class="bp">CGRect</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nl">width</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mf">50.0</span><span class="p">)</span>
</span><span class='line'><span class="k">let</span> <span class="n">area</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">area</span>
</span><span class='line'><span class="c1">// area: CGFloat = 500.0</span>
</span></code></pre></td></tr></table></div></figure>


<p>你同样可以使用扩展来为类添加协议而无需增加它的子类。如果这个协议是在 Swift 中被定义的，你可以添加 comformance 到它的结构或枚举中无论它们在 Objective-C 或在 Swift 中被定义。</p>

<p>你不能使用扩展来覆盖 Objective-C 类型中存在的方法与属性。</p>

<p><a name="closures"></a></p>

<h3>闭包（Closures）</h3>

<p>Objective-C 中的<code>blocks</code>会被自动导入为 Swift 中的闭包。例如，下面是一个 Objective-C 中的 block 变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Objective-C</span>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">completionBlock</span><span class="p">)(</span><span class="bp">NSData</span> <span class="o">*</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而它在 Swift 中的形式为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">let</span> <span class="nl">completionBlock</span><span class="p">:</span> <span class="p">(</span><span class="bp">NSData</span><span class="p">,</span> <span class="bp">NSError</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="o">=</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span> <span class="cm">/* ... */</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 的闭包与 Objective-C 中的 blocks 能够和睦相处，所以你可以把一个 Swift 闭包传递给一个把 block 作为参数的 Objective-C 函数。Swift 闭包与函数具有互通的类型，所以你甚至可以传递 Swift 函数的名字。</p>

<p>闭包与 blocks 语义上相通但是在一个地方不同：变量是可以直接改变的，而不是像 block 那样会拷贝变量。换句话说，Swift 中变量的默认行为与 Objective-C 中 __block 变量一致。</p>

<p><a name="object_comparison"></a></p>

<h3>比较对象</h3>

<p>当比较两个 Swift 中的对象时，可以使用两种方式。第一种，使用（==），判断两个对象内容是否相同。第二种，使用(===)，判断常量或者变量是否为同一个对象的实例。</p>

<p>Swift 与 Objective-C 一般使用 == 与 === 操作符来做比较。Swift 的 == 操作符为源自 NSObject 的对象提供了默认的实现。在实现 == 操作符时，Swift 调用 NSObject 定义的 isEqual: 方法。</p>

<p>NSObject 类仅仅做了身份的比较，所以你需要在你自己的类中重新实现 isEqual: 方法。因为你可以直接传递 Swift 对象给 Objective-C 的 API，你也应该为这些对象实现自定义的 isEqual: 方法，如果你希望比较两个对象的内容是否相同而不是仅仅比较他们是不是由相同的对象派生。</p>

<p>作为实现比较函数的一部分，确保根据<a href="//https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectComparison.html#//apple_ref/doc/uid/TP40008195-CH37">Object comparison</a>实现对象的<code>hash</code>属性。更进一步的说，如果你希望你的类能够作为字典中的键，也需要遵从<code>Hashable</code>协议以及实现<code>hashValues</code>属性。</p>

<p><a name="swift_type_compatibility"></a></p>

<h3>Swift 类型兼容性</h3>

<p>当你定义了一个继承自<code>NSObject</code>或者其他 Objective-C 类的 Swift 类，这些类都能与 Objective-C 无缝连接。所有的步骤都由 Swift 编译器自动完成，如果你从未在 Objective-C 代码中导入 Swift 类，你也不需要担心类型适配问题。另外一种情况，如果你的 Swift 类并不继承于 Objective-C 类而你希望能在 Objective-C 的代码中使用它，你可以使用下面描述的<code>@objc</code>属性。</p>

<p><code>@objc</code>可以让你的 Swift API 在 Objective-C 中使用。换句话说，你可以通过在任何 Swift 方法、类、属性前添加<code>@objc</code>，来使得他们可以在 Objective-C 代码中使用。如果你的类继承自 Objective-C，编译器会自动帮助你完成这一步。编译器还会在所有的变量、方法、属性前加 @objc，如果这个类自己前面加上了<code>@objc</code>关键字。当你使用<code>@IBOutlet</code>，<code>@IBAction</code>，或者是<code>@NSManaged</code>属性时，<code>@objc</code>也会自动加在前面。这个关键字也可以用在 Objetive-C 中的 target-action 设计模式中，例如，<code>NSTimer</code>或者<code>UIButton</code>。</p>

<p>当你在 Objective-C 中使用 Swift API，编译器通常会对语句做直接的翻译。例如，Swift API <code>func playSong(name: String)</code>会被解释为<code>- (void)playSong:(NSString *)name</code>。然而，有一个例外：当在 Objective-C 中使用 Swift 的初始化函数，编译器会在方法前添加“initWith”并且将原初始化函数的第一个参数首字母大写。例如，这个 Swift 初始化函数<code>init (songName: String, artist: String</code>将被翻译为<code>- (instancetype)initWithSongName:(NSString *)songName artist:(NSString *)artist
</code>。</p>

<p>Swift 同时也提供了一个<code>@objc</code>关键字的变体，通过它你可以自定义在 Objective-C 中转换的函数名。例如，如果你的 Swift 类的名字包含 Objective-C 中不支持的字符，你就可以为 Objective-C 提供一个可供替代的名字。如果你要为 Swift 函数提供一个 Objective-C 名字，记得为带参数的函数添加（:）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="p">@</span><span class="n">objc</span><span class="p">(</span><span class="n">Squirrel</span><span class="p">)</span>
</span><span class='line'><span class="k">class</span> <span class="err">Белка</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">@</span><span class="n">objc</span><span class="p">(</span><span class="nl">initWithName</span><span class="p">:)</span>
</span><span class='line'>    <span class="k">init</span> <span class="p">(</span><span class="err">имя</span><span class="o">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">@</span><span class="n">objc</span><span class="p">(</span><span class="nl">hideNuts</span><span class="p">:</span><span class="nl">inTree</span><span class="p">:)</span>
</span><span class='line'>    <span class="k">func</span> <span class="err">прячьОрехи</span><span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="err">вДереве</span><span class="o">:</span> <span class="err">Дерево</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你在 Swift 类中使用<code>@objc(&lt;#name#&gt;)</code>关键字，这个类可以不需要命名空间即可在 Objective-C 中使用。这个关键字在你迁徙 Objecive-C 代码到 Swift 时同样也非常有用。由于归档过的对象存贮了类的名字，你应该使用<code>@objc(&lt;#name#&gt;)</code>来声明与旧的归档过的类相同的名字，这样旧的类才能被新的 Swift 类解档。</p>

<p><a name="objective_c_selectors"></a></p>

<h3>Objective-C 选择器（Selectors）</h3>

<p>一个 Objective-C 选择器类型指向一个 Objective-C 的方法名。在 Swift 里，Objective-C 的选择器被<code>Selector</code>结构体替代。你可以通过字符串创建一个选择器，比如<code>let mySelector: Selector = "tappedButton:"</code>。因为字符串能够自动转换为选择器，所以你可以把字符串直接传递给任何能够接受选择器的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">//Swift</span>
</span><span class='line'><span class="k">import</span> <span class="n">UIKit</span>
</span><span class='line'><span class="k">class</span> <span class="nl">MyViewController</span><span class="p">:</span> <span class="bp">UIViewController</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">myButton</span> <span class="o">=</span> <span class="bp">UIButton</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mi">50</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="n">nibName</span> <span class="nl">nibNameOrNil</span><span class="p">:</span> <span class="n">String</span><span class="o">!</span><span class="p">,</span> <span class="n">bundle</span> <span class="nl">nibBundleOrNil</span><span class="p">:</span> <span class="bp">NSBundle</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">nibName</span><span class="p">:</span> <span class="n">nibName</span><span class="p">,</span> <span class="nl">bundle</span><span class="p">:</span> <span class="n">nibBundle</span><span class="p">)</span>
</span><span class='line'>        <span class="n">myButton</span><span class="p">.</span><span class="n">targetForAction</span><span class="p">(</span><span class="s">&quot;tappedButton:&quot;</span><span class="p">,</span> <span class="nl">withSender</span><span class="p">:</span> <span class="nb">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">func</span> <span class="n">tappedButton</span><span class="p">(</span><span class="nl">sender</span><span class="p">:</span> <span class="bp">UIButton</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;tapped button&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意</p>

<p><code>performSelector:</code>方法和相关的调用选择器的方法没有导入到 Swift 中因为它们是不安全的。</p></blockquote>

<p>如果你的 Swift 类继承自 Objective-C 的类，你的所有方法都可以用作 Objective-C 的选择器。另外，如果你的 Swift 类不是继承自 Objective-C，如果你想要当选择器来使用你就需要在前面添加<code>@objc</code>关键字，详情请看<a href="#swift_type_compatibility">Swift 类型兼容性</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift泛型]]></title>
    <link href="http://ba-xiang.com//blog/Swif%E6%B3%9B%E5%9E%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/Swif泛型</id>
    <content type="html"><![CDATA[<p><em>泛型代码</em>可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>


<p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个<code>Int</code>数组，也可创建一个<code>String</code>数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。</p>


<!-- more -->


<p><a name="the_problem_that_generics_solve"></a></p>


<h2 id="-">泛型所解决的问题</h2>


<p>这里是一个标准的，非泛型函数<code>swapTwoInts</code>,用来交换两个Int值：</p>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数使用写入读出（in-out）参数来交换<code>a</code>和<code>b</code>的值，请参考[写入读出参数][1]。</p></p>

<p><code>swapTwoInts</code>函数可以交换<code>b</code>的原始值到<code>a</code>，也可以交换a的原始值到<code>b</code>，你可以调用这个函数交换两个<code>Int</code>变量值：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 输出 "someInt is now 107, and anotherInt is now 3"
</code></pre>


<p><code>swapTwoInts</code>函数是非常有用的，但是它只能交换<code>Int</code>值，如果你想要交换两个<code>String</code>或者<code>Double</code>，就不得不写更多的函数，如 <code>swapTwoStrings</code>和<code>swapTwoDoublesfunctions</code>，如同如下所示：</p>


<pre><code>func swapTwoStrings(inout a: String, inout b: String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(inout a: Double, inout b: Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p>你可能注意到 <code>swapTwoInts</code>、 <code>swapTwoStrings</code>和<code>swapTwoDoubles</code>函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是<code>Int</code>、<code>String</code>和<code>Double</code>。</p>


<p>但实际应用中通常需要一个用处更强大并且尽可能的考虑到更多的灵活性单个函数，可以用来交换两个任何类型值，很幸运的是，泛型代码帮你解决了这种问题。（一个这种泛型函数后面已经定义好了。）</p>


<blockquote>
<p>注意：
在所有三个函数中，<code>a</code>和<code>b</code>的类型是一样的。如果<code>a</code>和<code>b</code>不是相同的类型，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个<code>String</code>类型的变量和一个<code>Double</code>类型的变量互相交换值。如果一定要做，Swift 将报编译错误。</p>
</blockquote>


<p><a name="generic_functions"></a></p>


<h2 id="-">泛型函数</h2>


<p><code>泛型函数</code>可以工作于任何类型，这里是一个上面<code>swapTwoInts</code>函数的泛型版本，用于交换两个值：</p>


<pre><code>func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p><code>swapTwoValues</code>函数主体和<code>swapTwoInts</code>函数是一样的，它只在第一行稍微有那么一点点不同于<code>swapTwoInts</code>，如下所示：</p>


<pre><code>func swapTwoInts(inout a: Int, inout b: Int)
func swapTwoValues&lt;T&gt;(inout a: T, inout b: T)
</code></pre>


<p>这个函数的泛型版本使用了占位类型名字（通常此情况下用字母<code>T</code>来表示）来代替实际类型名（如<code>In</code>、<code>String</code>或<code>Doubl</code>）。占位类型名没有提示<code>T</code>必须是什么类型，但是它提示了<code>a</code>和<code>b</code>必须是同一类型<code>T</code>，而不管<code>T</code>表示什么类型。只有<code>swapTwoValues</code>函数在每次调用时所传入的实际类型才能决定<code>T</code>所代表的类型。</p>


<p>另外一个不同之处在于这个泛型函数名后面跟着的展位类型名字（T）是用尖括号括起来的（<t>）。这个尖括号告诉 Swift 那个<code>T</code>是<code>swapTwoValues</code>函数所定义的一个类型。因为<code>T</code>是一个占位命名类型，Swift 不会去查找命名为T的实际类型。</t></p>


<p><code>swapTwoValues</code>函数除了要求传入的两个任何类型值是同一类型外，也可以作为<code>swapTwoInts</code>函数被调用。每次<code>swapTwoValues</code>被调用，T所代表的类型值都会传给函数。</p>


<p>在下面的两个例子中,<code>T</code>分别代表<code>Int</code>和<code>String</code>：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;someInt, &amp;anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&amp;someString, &amp;anotherString)
// someString is now "world", and anotherString is now "hello"
</code></pre>


<blockquote>
<p>注意
上面定义的函数<code>swapTwoValues</code>是受<code>swap</code>函数启发而实现的。<code>swap</code>函数存在于 Swift 标准库，并可以在其它类中任意使用。如果你在自己代码中需要类似<code>swapTwoValues</code>函数的功能，你可以使用已存在的交换函数<code>swap</code>函数。</p>
</blockquote>


<p><a name="type_parameters"></a></p>


<h2 id="-">类型参数</h2>


<p>在上面的<code>swapTwoValues</code>例子中，占位类型<code>T</code>是一种类型参数的示例。类型参数指定并命名为一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（如<t>）。</t></p>


<p>一旦一个类型参数被指定，那么其可以被使用来定义一个函数的参数类型（如<code>swapTwoValues</code>函数中的参数<code>a</code>和<code>b</code>），或作为一个函数返回类型，或用作函数主体中的注释类型。在这种情况下，被类型参数所代表的占位类型不管函数任何时候被调用，都会被实际类型所替换（在上面<code>swapTwoValues</code>例子中，当函数第一次被调用时，<code>T</code>被<code>Int</code>替换，第二次调用时，被<code>String</code>替换。）。</p>


<p>你可支持多个类型参数，命名在尖括号中，用逗号分开。</p>


<p><a name="naming_type_parameters"></a></p>


<h2 id="-">命名类型参数</h2>


<p>在简单的情况下，泛型函数或泛型类型需要指定一个占位类型（如上面的<code>swapTwoValues</code>泛型函数，或一个存储单一类型的泛型集，如数组），通常用一单个字母<code>T</code>来命名类型参数。不过，你可以使用任何有效的标识符来作为类型参数名。</p>


<p>如果你使用多个参数定义更复杂的泛型函数或泛型类型，那么使用更多的描述类型参数是非常有用的。例如，Swift 字典（Dictionary）类型有两个类型参数，一个是键，另外一个是值。如果你自己写字典，你或许会定义这两个类型参数为<code>KeyType</code>和<code>ValueType</code>，用来记住它们在你的泛型代码中的作用。</p>


<blockquote>
<p>注意
请始终使用大写字母开头的驼峰式命名法（例如<code>T</code>和<code>KeyType</code>）来给类型参数命名，以表明它们是类型的占位符，而非类型值。</p>
</blockquote>


<p><a name="generic_types"></a></p>


<h2 id="-">泛型类型</h2>


<p>通常在泛型函数中，Swift 允许你定义你自己的泛型类型。这些自定义类、结构体和枚举作用于任何类型，如同<code>Array</code>和<code>Dictionary</code>的用法。</p>


<p>这部分向你展示如何写一个泛型集类型&#8211;<code>Stack</code>（栈）。一个栈是一系列值域的集合，和<code>Array</code>（数组）类似，但其是一个比 Swift 的<code>Array</code>类型更多限制的集合。一个数组可以允许其里面任何位置的插入/删除操作，而栈，只允许在集合的末端添加新的项（如同<em>push</em>一个新值进栈）。同样的一个栈也只能从末端移除项（如同<em>pop</em>一个值出栈）。</p>


<blockquote>
<p>注意
栈的概念已被<code>UINavigationController</code>类使用来模拟试图控制器的导航结构。你通过调用<code>UINavigationController</code>的<code>pushViewController:animated:</code>方法来为导航栈添加（add）新的试图控制器；而通过<code>popViewControllerAnimated:</code>的方法来从导航栈中移除（pop）某个试图控制器。每当你需要一个严格的<code>后进先出</code>方式来管理集合，堆栈都是最实用的模型。</p>
</blockquote>


<p>下图展示了一个栈的压栈(push)/出栈(pop)的行为：</p>


<p>![此处输入图片的描述][2]</p>


<ol>
<li>现在有三个值在栈中；</li>
<li>第四个值“pushed”到栈的顶部；</li>
<li>现在有四个值在栈中，最近的那个在顶部；</li>
<li>栈中最顶部的那个项被移除，或称之为“popped”；</li>
<li>移除掉一个值后，现在栈又重新只有三个值。</li>
</ol>


<p>这里展示了如何写一个非泛型版本的栈，<code>Int</code>值型的栈：</p>


<pre><code>struct IntStack {
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
}
</code></pre>


<p>这个结构体在栈中使用一个<code>Array</code>性质的<code>items</code>存储值。<code>Stack</code>提供两个方法：<code>push</code>和<code>pop</code>，从栈中压进一个值和移除一个值。这些方法标记为可变的，因为他们需要修改（或<em>转换</em>）结构体的<code>items</code>数组。</p>


<p>上面所展现的<code>IntStack</code>类型只能用于<code>Int</code>值，不过，其对于定义一个泛型<code>Stack</code>类（可以处理<em>任何</em>类型值的栈）是非常有用的。</p>


<p>这里是一个相同代码的泛型版本：</p>


<pre><code>struct Stack&lt;T&gt; {
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
}
</code></pre>


<p>注意到<code>Stack</code>的泛型版本基本上和非泛型版本相同，但是泛型版本的占位类型参数为T代替了实际<code>Int</code>类型。这种类型参数包含在一对尖括号里（<code>&lt;T&gt;</code>），紧随在结构体名字后面。</p>


<p><code>T</code>定义了一个名为“某种类型T”的节点提供给后来用。这种将来类型可以在结构体的定义里任何地方表示为“T”。在这种情况下，<code>T</code>在如下三个地方被用作节点：</p>


<ul>
<li>创建一个名为<code>items</code>的属性，使用空的T类型值数组对其进行初始化；</li>
<li>指定一个包含一个参数名为<code>item</code>的<code>push</code>方法，该参数必须是T类型；</li>
<li>指定一个<code>pop</code>方法的返回值，该返回值将是一个T类型值。</li>
</ul>


<p>当创建一个新单例并初始化时， 通过用一对紧随在类型名后的尖括号里写出实际指定栈用到类型，创建一个<code>Stack</code>实例，同创建<code>Array</code>和<code>Dictionary</code>一样：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 现在栈已经有4个string了
</code></pre>


<p>下图将展示<code>stackOfStrings</code>如何<code>push</code>这四个值进栈的过程：</p>


<p>![此处输入图片的描述][3]</p>


<p>从栈中<code>pop</code>并移除值&#8221;cuatro&#8221;：</p>


<pre><code>let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to "cuatro", and the stack now contains 3 strings
</code></pre>


<p>下图展示了如何从栈中pop一个值的过程：
![此处输入图片的描述][4]</p>


<p>由于<code>Stack</code>是泛型类型，所以在 Swift 中其可以用来创建任何有效类型的栈，这种方式如同<code>Array</code>和<code>Dictionary</code>。</p>


<p><a name="type_constraints"></a></p>


<h2 id="-">类型约束</h2>


<p><code>swapTwoValues</code>函数和<code>Stack</code>类型可以作用于任何类型，不过，有的时候对使用在泛型函数和泛型类型上的类型强制约束为某种特定类型是非常有用的。类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成。</p>


<p>例如，Swift 的<code>Dictionary</code>类型对作用于其键的类型做了些限制。在[字典][5]的描述中，字典的键类型必须是<em>可哈希</em>，也就是说，必须有一种方法可以使其是唯一的表示。<code>Dictionary</code>之所以需要其键是可哈希是为了以便于其检查其是否包含某个特定键的值。如无此需求，<code>Dictionary</code>即不会告诉是否插入或者替换了某个特定键的值，也不能查找到已经存储在字典里面的给定键值。</p>


<p>这个需求强制加上一个类型约束作用于<code>Dictionary</code>的键上，当然其键类型必须遵循<code>Hashable</code>协议（Swift 标准库中定义的一个特定协议）。所有的 Swift 基本类型（如<code>String</code>，<code>Int</code>， <code>Double</code>和 <code>Bool</code>）默认都是可哈希。</p>


<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，当然，这些约束要支持泛型编程的强力特征中的多数。抽象概念如<code>可哈希</code>具有的类型特征是根据他们概念特征来界定的，而不是他们的直接类型特征。</p>


<h3 id="-">类型约束语法</h3>


<p>你可以写一个在一个类型参数名后面的类型约束，通过冒号分割，来作为类型参数链的一部分。这种作用于泛型函数的类型约束的基础语法如下所示（和泛型类型的语法相同）：</p>


<pre><code>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // function body goes here
}
</code></pre>


<p>上面这个假定函数有两个类型参数。第一个类型参数<code>T</code>，有一个需要<code>T</code>必须是<code>SomeClass</code>子类的类型约束；第二个类型参数<code>U</code>，有一个需要<code>U</code>必须遵循<code>SomeProtocol</code>协议的类型约束。</p>


<h3 id="-">类型约束行为</h3>


<p>这里有个名为<code>findStringIndex</code>的非泛型函数，该函数功能是去查找包含一给定<code>String</code>值的数组。若查找到匹配的字符串，<code>findStringIndex</code>函数返回该字符串在数组中的索引值（<code>Int</code>），反之则返回<code>nil</code>：</p>


<pre><code>func findStringIndex(array: String[], valueToFind: String) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findStringIndex</code>函数可以作用于查找一字符串数组中的某个字符串:</p>


<pre><code>let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findStringIndex(strings, "llama") {
    println("The index of llama is \(foundIndex)")
}
// 输出 "The index of llama is 2"
</code></pre>


<p>如果只是针对字符串而言查找在数组中的某个值的索引，用处不是很大，不过，你可以写出相同功能的泛型函数<code>findIndex</code>，用某个类型<code>T</code>值替换掉提到的字符串。</p>


<p>这里展示如何写一个你或许期望的<code>findStringIndex</code>的泛型版本<code>findIndex</code>。请注意这个函数仍然返回<code>Int</code>，是不是有点迷惑呢，而不是泛型类型?那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数不会编译，原因在例子后面会说明：</p>


<pre><code>func findIndex&lt;T&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p>上面所写的函数不会编译。这个问题的位置在等式的检查上，<code>“if value == valueToFind”</code>。不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。正因如此，这部分代码不能可能保证工作于每个可能的类型<code>T</code>，当你试图编译这部分代码时估计会出现相应的错误。</p>


<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个<code>Equatable</code>协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持<code>Equatable</code>协议。</p>


<p>任何<code>Equatable</code>类型都可以安全的使用在<code>findIndex</code>函数中，因为其保证支持等式操作。为了说明这个事实，当你定义一个函数时，你可以写一个<code>Equatable</code>类型约束作为类型参数定义的一部分：</p>


<pre><code>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findIndex</code>中这个单个类型参数写做：<code>T: Equatable</code>，也就意味着“任何T类型都遵循<code>Equatable</code>协议”。</p>


<p><code>findIndex</code>函数现在则可以成功的编译过，并且作用于任何遵循<code>Equatable</code>的类型，如<code>Double</code>或<code>String</code>:</p>


<pre><code>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
// stringIndex is an optional Int containing a value of 2
</code></pre>


<p><a name="associated_types"></a></p>


<h2 id="-">关联类型</h2>


<p>当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名（或<em>别名</em>）。作用于关联类型上实际类型是不需要指定的，直到该协议接受。关联类型被指定为<code>typealias</code>关键字。</p>


<h3 id="-">关联类型行为</h3>


<p>这里是一个<code>Container</code>协议的例子，定义了一个ItemType关联类型：</p>


<pre><code>protocol Container {
    typealias ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>


<p><code>Container</code>协议定义了三个任何容器必须支持的兼容要求：</p>


<ul>
<li>必须可能通过<code>append</code>方法添加一个新item到容器里；</li>
<li>必须可能通过使用<code>count</code>属性获取容器里items的数量，并返回一个<code>Int</code>值；</li>
<li>必须可能通过容器的<code>Int</code>索引值下标可以检索到每一个item。</li>
</ul>


<p>这个协议没有指定容器里item是如何存储的或何种类型是允许的。这个协议只指定三个任何遵循<code>Container</code>类型所必须支持的功能点。一个遵循的类型也可以提供其他额外的功能，只要满足这三个条件。</p>


<p>任何遵循<code>Container</code>协议的类型必须指定存储在其里面的值类型，必须保证只有正确类型的items可以加进容器里，必须明确可以通过其下标返回item类型。</p>


<p>为了定义这三个条件，<code>Container</code>协议需要一个方法指定容器里的元素将会保留，而不需要知道特定容器的类型。<code>Container</code>协议需要指定任何通过<code>append</code>方法添加到容器里的值和容器里元素是相同类型，并且通过容器下标返回的容器元素类型的值的类型是相同类型。</p>


<p>为了达到此目的，<code>Container</code>协议声明了一个ItemType的关联类型，写作<code>typealias ItemType</code>。The protocol does not define what ItemType is an alias for—that information is left for any conforming type to provide（这个协议不会定义<code>ItemType</code>是遵循类型所提供的何种信息的别名）。尽管如此，<code>ItemType</code>别名支持一种方法识别在一个容器里的items类型，以及定义一种使用在<code>append</code>方法和下标中的类型，以便保证任何期望的<code>Container</code>的行为是强制性的。</p>


<p>这里是一个早前IntStack类型的非泛型版本，适用于遵循Container协议：</p>


<pre><code>struct IntStack: Container {
    // original IntStack implementation
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}
</code></pre>


<p><code>IntStack</code>类型实现了<code>Container</code>协议的所有三个要求，在<code>IntStack</code>类型的每个包含部分的功能都满足这些要求。</p>


<p>此外，<code>IntStack</code>指定了<code>Container</code>的实现，适用的ItemType被用作<code>Int</code>类型。对于这个<code>Container</code>协议实现而言，定义 <code>typealias ItemType = Int</code>，将抽象的<code>ItemType</code>类型转换为具体的<code>Int</code>类型。</p>


<p>感谢Swift类型参考，你不用在<code>IntStack</code>定义部分声明一个具体的<code>Int</code>的<code>ItemType</code>。由于<code>IntStack</code>遵循<code>Container</code>协议的所有要求，只要通过简单的查找<code>append</code>方法的item参数类型和下标返回的类型，Swift就可以推断出合适的<code>ItemType</code>来使用。确实，如果上面的代码中你删除了 <code>typealias ItemType = Int</code>这一行，一切仍旧可以工作，因为它清楚的知道ItemType使用的是何种类型。</p>


<p>你也可以生成遵循<code>Container</code>协议的泛型<code>Stack</code>类型：</p>


<pre><code>struct Stack&lt;T&gt;: Container {
    // original Stack&lt;T&gt; implementation
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(item: T) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; T {
        return items[i]
    }
}
</code></pre>


<p>这个时候，占位类型参数<code>T</code>被用作<code>append</code>方法的item参数和下标的返回类型。Swift 因此可以推断出被用作这个特定容器的<code>ItemType</code>的<code>T</code>的合适类型。</p>


<h3 id="-">扩展一个存在的类型为一指定关联类型</h3>


<p>在[使用扩展来添加协议兼容性][6]中有描述扩展一个存在的类型添加遵循一个协议。这个类型包含一个关联类型的协议。</p>


<p>Swift的<code>Array</code>已经提供<code>append</code>方法，一个<code>count</code>属性和通过下标来查找一个自己的元素。这三个功能都达到<code>Container</code>协议的要求。也就意味着你可以扩展<code>Array</code>去遵循<code>Container</code>协议，只要通过简单声明<code>Array</code>适用于该协议而已。如何实践这样一个空扩展，在[使用扩展来声明协议的采纳][7]中有描述这样一个实现一个空扩展的行为：</p>


<pre><code>extension Array: Container {}
</code></pre>


<p>如同上面的泛型<code>Stack</code>类型一样，<code>Array的append</code>方法和下标保证<code>Swift</code>可以推断出<code>ItemType</code>所使用的适用的类型。定义了这个扩展后，你可以将任何<code>Array</code>当作<code>Container</code>来使用。</p>


<p><a name="where_clauses"></a></p>


<h2 id="where-">Where 语句</h2>


<p>[类型约束][8]中描述的类型约束确保你定义关于类型参数的需求和一泛型函数或类型有关联。</p>


<p>对于关联类型的定义需求也是非常有用的。你可以通过这样去定义<em>where语句</em>作为一个类型参数队列的一部分。一个<code>where</code>语句使你能够要求一个关联类型遵循一个特定的协议，以及（或）那个特定的类型参数和关联类型可以是相同的。你可写一个<code>where</code>语句，通过紧随放置<code>where</code>关键字在类型参数队列后面，其后跟着一个或者多个针对关联类型的约束，以及（或）一个或多个类型和关联类型的等于关系。</p>


<p>下面的列子定义了一个名为<code>allItemsMatch</code>的泛型函数，用来检查是否两个<code>Container</code>单例包含具有相同顺序的相同元素。如果匹配到所有的元素，那么返回一个为<code>true</code>的<code>Boolean</code>值，反之，则相反。</p>


<p>这两个容器可以被检查出是否是相同类型的容器（虽然它们可以是），但他们确实拥有相同类型的元素。这个需求通过一个类型约束和<code>where</code>语句结合来表示：</p>


<pre><code>func allItemsMatch&lt;
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;
    (someContainer: C1, anotherContainer: C2) -&gt; Bool {

        // check that both containers contain the same number of items
        if someContainer.count != anotherContainer.count {
            return false
        }

        // check each pair of items to see if they are equivalent
        for i in 0..someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }

        // all items match, so return true
        return true

}
</code></pre>


<p>这个函数用了两个参数：<code>someContainer</code>和<code>anotherContainer</code>。<code>someContainer</code>参数是类型<code>C1</code>，<code>anotherContainer</code>参数是类型<code>C2</code>。<code>C1</code>和<code>C2</code>是容器的两个占位类型参数，决定了这个函数何时被调用。</p>


<p>这个函数的类型参数列紧随在两个类型参数需求的后面：</p>


<ul>
<li><code>C1</code>必须遵循<code>Container</code>协议 (写作 <code>C1: Container</code>)。</li>
<li><code>C2</code>必须遵循<code>Container</code>协议 (写作 <code>C2: Container</code>)。</li>
<li><code>C1</code>的<code>ItemType</code>同样是C2的<code>ItemType</code>（写作 <code>C1.ItemType == C2.ItemType</code>）。</li>
<li><code>C1</code>的<code>ItemType</code>必须遵循<code>Equatable</code>协议 (写作 <code>C1.ItemType: Equatable</code>)。</li>
</ul>


<p>第三个和第四个要求被定义为一个<code>where</code>语句的一部分，写在关键字<code>where</code>后面，作为函数类型参数链的一部分。</p>


<p>这些要求意思是：</p>


<p><code>someContainer</code>是一个<code>C1</code>类型的容器。
<code>anotherContainer</code>是一个<code>C2</code>类型的容器。
<code>someContainer</code>和<code>anotherContainer</code>包含相同的元素类型。
<code>someContainer</code>中的元素可以通过不等于操作(<code>!=</code>)来检查它们是否彼此不同。</p>


<p>第三个和第四个要求结合起来的意思是<code>anotherContainer</code>中的元素也可以通过 <code>!=</code> 操作来检查，因为他们在<code>someContainer</code>中元素确实是相同的类型。</p>


<p>这些要求能够使<code>allItemsMatch</code>函数比较两个容器，即便他们是不同的容器类型。</p>


<p><code>allItemsMatch</code>首先检查两个容器是否拥有同样数目的items，如果他们的元素数目不同，没有办法进行匹配，函数就会<code>false</code>。</p>


<p>检查完之后，函数通过<code>for-in</code>循环和半闭区间操作（..）来迭代<code>someContainer</code>中的所有元素。对于每个元素，函数检查是否<code>someContainer</code>中的元素不等于对应的<code>anotherContainer</code>中的元素，如果这两个元素不等，则这两个容器不匹配，返回<code>false</code>。</p>


<p>如果循环体结束后未发现没有任何的不匹配，那表明两个容器匹配，函数返回<code>true</code>。</p>


<p>这里演示了allItemsMatch函数运算的过程：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    println("All items match.")
} else {
    println("Not all items match.")
}
// 输出 "All items match."
</code></pre>


<p> 上面的例子创建一个<code>Stack</code>单例来存储<code>String</code>，然后压了三个字符串进栈。这个例子也创建了一个<code>Array</code>单例，并初始化包含三个同栈里一样的原始字符串。即便栈和数组否是不同的类型，但他们都遵循<code>Container</code>协议，而且他们都包含同样的类型值。你因此可以调用<code>allItemsMatch</code>函数，用这两个容器作为它的参数。在上面的例子中，<code>allItemsMatch</code>函数正确的显示了所有的这两个容器的<code>items</code>匹配。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift集合类型]]></title>
    <link href="http://ba-xiang.com//blog/Swift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/Swift集合类型</id>
    <content type="html"><![CDATA[<p>Swift 语言提供经典的数组和字典两种集合类型来存储集合数据。数组用来按顺序存储相同类型的数据。字典虽然无序存储相同类型数据值但是需要由独有的标识符引用和寻址（就是键值对）。</p>


<p>Swift 语言里的数组和字典中存储的数据值类型必须明确。 这意味着我们不能把不正确的数据类型插入其中。 同时这也说明我们完全可以对获取出的值类型非常自信。 Swift 对显式类型集合的使用确保了我们的代码对工作所需要的类型非常清楚，也让我们在开发中可以早早地找到任何的类型不匹配错误。</p>


<!-- more -->


<blockquote>
<p>注意：</p>
<p>Swift 的数组结构在被声明成常量和变量或者被传入函数与方法中时会相对于其他类型展现出不同的特性。 获取更多信息请参见<a href="#mutability_of_collections">集合的可变性</a>与<a href="09_Classes_and_Structures.html#assignment_and_copy_behavior_for_collection_types">集合在赋值和复制中的行为</a>章节。</p>
</blockquote>


<p><a name="arrays"></a></p>


<h2 id="-">数组</h2>


<p>数组使用有序列表存储相同类型的多重数据。相同的值可以多次出现在一个数组的不同位置中。</p>


<p>Swift 数组对存储数据有具体要求。 不同于 Objective-C 的<code>NSArray</code>和<code>NSMutableArray</code>类，他们可以存储任何类型的实例而且不提供他们返回对象的任何本质信息。 在 Swift 中，数据值在被存储进入某个数组之前类型必须明确，方法是通过显式的类型标注或类型推断，而且不是必须是<code>class</code>类型。例如： 如果我们创建了一个<code>Int</code>值类型的数组，我们不能往其中插入任何不是<code>Int</code>类型的数据。 Swift 中的数组是类型安全的，并且它们中包含的类型必须明确。</p>


<p><a name="array_type_shorthand_syntax"></a></p>


<h3 id="-">数组的简单语法</h3>


<p>写 Swift 数组应该遵循像<code>Array&lt;SomeType&gt;</code>这样的形式，其中<code>SomeType</code>是这个数组中唯一允许存在的数据类型。 我们也可以使用像<code>SomeType[]</code>这样的简单语法。 尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</p>


<p><a name="array_literals"></a></p>


<h3 id="-">数组构造语句</h3>


<p>我们可以使用字面语句来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。字面语句是一系列由逗号分割并由方括号包含的数值。
<code>[value 1, value 2, value 3]</code>。</p>


<p>下面这个例子创建了一个叫做<code>shoppingList</code>并且存储字符串的数组：</p>


<pre><code>var shoppingList: String[] = ["Eggs", "Milk"]
// shoppingList 已经被构造并且拥有两个初始项。
</code></pre>


<p><code>shoppingList</code>变量被声明为“字符串值类型的数组“，记作<code>String[]</code>。 因为这个数组被规定只有<code>String</code>一种数据结构，所以只有<code>String</code>类型可以在其中被存取。 在这里，<code>shoppinglist</code>数组由两个<code>String</code>值（<code>"Eggs"</code> 和<code>"Milk"</code>）构造，并且由字面语句定义。</p>


<blockquote>
<p>注意：</p>
<p><code>Shoppinglist</code>数组被声明为变量（<code>var</code>关键字创建）而不是常量（<code>let</code>创建）是因为以后可能会有更多的数据项被插入其中。</p>
</blockquote>


<p>在这个例子中，字面语句仅仅包含两个<code>String</code>值。匹配了该数组的变量声明（只能包含<code>String</code>的数组），所以这个字面语句的分配过程就是允许用两个初始项来构造<code>shoppinglist</code>。</p>


<p>由于 Swift 的类型推断机制，当我们用字面语句构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。 <code>shoppinglist</code>的构造也可以这样写：</p>


<pre><code>var shoppingList = ["Eggs", "Milk"]
</code></pre>


<p>因为所有字面语句中的值都是相同的类型，Swift 可以推断出<code>String[]</code>是<code>shoppinglist</code>中变量的正确类型。</p>


<p><a name="accessing_and_modifying_an_array"></a></p>


<h3 id="-">访问和修改数组</h3>


<p>我们可以通过数组的方法和属性来访问和修改数组，或者下标语法。
还可以使用数组的只读属性<code>count</code>来获取数组中的数据项数量。</p>


<pre><code>println("The shopping list contains \(shoppingList.count) items.")
// 输出"The shopping list contains 2 items."（这个数组有2个项）
</code></pre>


<p>使用布尔项<code>isEmpty</code>来作为检查<code>count</code>属性的值是否为 0 的捷径。</p>


<pre><code>if shoppingList.isEmpty {
    println("The shopping list is empty.")
} else {
    println("The shopping list is not empty.")
}
// 打印 "The shopping list is not empty."（shoppinglist不是空的）
</code></pre>


<p>也可以使用<code>append</code>方法在数组后面添加新的数据项：</p>


<pre><code>shoppingList.append("Flour")
// shoppingList 现在有3个数据项，有人在摊煎饼
</code></pre>


<p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加数据项：</p>


<pre><code>shoppingList += "Baking Powder"
// shoppingList 现在有四项了
</code></pre>


<p>我们也可以使用加法赋值运算符（<code>+=</code>）直接添加拥有相同类型数据的数组。</p>


<pre><code>shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
// shoppingList 现在有7项了
</code></pre>


<p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>


<pre><code>var firstItem = shoppingList[0]
// 第一项是 "Eggs"
</code></pre>


<p>注意第一项在数组中的索引值是<code>0</code>而不是<code>1</code>。 Swift 中的数组索引总是从零开始。</p>


<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>


<pre><code>shoppingList[0] = "Six eggs"
// 其中的第一项现在是 "Six eggs" 而不是 "Eggs"
</code></pre>


<p>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把<code>"Chocolate Spread"</code>，<code>"Cheese"</code>，和<code>"Butter"</code>替换为<code>"Bananas"</code>和 <code>"Apples"</code>：</p>


<pre><code>shoppingList[4...6] = ["Bananas", "Apples"]
// shoppingList 现在有六项
</code></pre>


<blockquote>
<p>注意：</p>
<p>我们不能使用下标语法在数组尾部添加新项。如果我们试着用这种方法对索引越界的数据进行检索或者设置新值的操作，我们会引发一个运行期错误。我们可以使用索引值和数组的<code>count</code>属性进行比较来在使用某个索引之前先检验是否有效。除了当<code>count</code>等于 0 时（说明这是个空数组），最大索引值一直是<code>count - 1</code>，因为数组都是零起索引。</p>
</blockquote>


<p>调用数组的<code>insert(atIndex:)</code>方法来在某个具体索引值之前添加数据项：</p>


<pre><code>shoppingList.insert("Maple Syrup", atIndex: 0)
// shoppingList 现在有7项
// "Maple Syrup" 现在是这个列表中的第一项
</code></pre>


<p>这次<code>insert</code>函数调用把值为<code>"Maple Syrup"</code>的新数据项插入列表的最开始位置，并且使用<code>0</code>作为索引值。</p>


<p>类似的我们可以使用<code>removeAtIndex</code>方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）:</p>


<pre><code>let mapleSyrup = shoppingList.removeAtIndex(0)
//索引值为0的数据项被移除
// shoppingList 现在只有6项，而且不包括Maple Syrup
// mapleSyrup常量的值等于被移除数据项的值 "Maple Syrup"
</code></pre>


<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为<code>0</code>的数据项的值再次等于<code>"Six eggs"</code>:</p>


<pre><code>firstItem = shoppingList[0]
// firstItem 现在等于 "Six eggs"
</code></pre>


<p>如果我们只想把数组中的最后一项移除，可以使用<code>removeLast</code>方法而不是<code>removeAtIndex</code>方法来避免我们需要获取数组的<code>count</code>属性。就像后者一样，前者也会返回被移除的数据项：</p>


<pre><code>let apples = shoppingList.removeLast()
// 数组的最后一项被移除了
// shoppingList现在只有5项，不包括cheese
//  apples 常量的值现在等于"Apples" 字符串
</code></pre>


<p><a name="iterating_over_an_array"></a></p>


<h3 id="-">数组的遍历</h3>


<p>我们可以使用<code>for-in</code>循环来遍历所有数组中的数据项：</p>


<pre><code>for item in shoppingList {
    println(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
</code></pre>


<p>如果我们同时需要每个数据项的值和索引值，可以使用全局<code>enumerate</code>函数来进行数组遍历。<code>enumerate</code>返回一个由每一个数据项索引值和数据值组成的键值对组。我们可以把这个键值对组分解成临时常量或者变量来进行遍历：</p>


<pre><code>for (index, value) in enumerate(shoppingList) {
    println("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
</code></pre>


<p>更多关于<code>for-in</code>循环的介绍请参见<a href="05_Control_Flow.html#for_loops">for 循环</a>。</p>


<p><a name="creating_and_initializing_an_array"></a></p>


<h3 id="-">创建并且构造一个数组</h3>


<p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>


<pre><code>var someInts = Int[]()
println("someInts is of type Int[] with \(someInts。count) items。")
// 打印 "someInts is of type Int[] with 0 items。"（someInts是0数据项的Int[]数组）
</code></pre>


<p>注意<code>someInts</code>被设置为一个<code>Int[]</code>构造函数的输出所以它的变量类型被定义为<code>Int[]</code>。</p>


<p>除此之外，如果代码上下文中提供了类型信息， 例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：<code>[]</code>（一对空方括号）：</p>


<pre><code>someInts.append(3)
// someInts 现在包含一个INT值
someInts = []
// someInts 现在是空数组，但是仍然是Int[]类型的。
</code></pre>


<p>Swift 中的<code>Array</code>类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（<code>count</code>）和适当类型的初始值（<code>repeatedValue</code>）传入数组构造函数：</p>


<pre><code>var threeDoubles = Double[](count: 3, repeatedValue:0.0)
// threeDoubles 是一种 Double[]数组, 等于 [0.0, 0.0, 0.0]
</code></pre>


<p>因为类型推断的存在，我们使用这种构造方法的时候不需要特别指定数组中存储的数据类型，因为类型可以从默认值推断出来：</p>


<pre><code>var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]
</code></pre>


<p>最后，我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>


<pre><code>var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles 被推断为 Double[], 等于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
</code></pre>


<p><a name="dictionaries"></a></p>


<h2 id="-">字典</h2>


<p>字典是一种存储相同类型多重数据的存储器。每个值（value）都关联独特的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>


<p>Swift 的字典使用时需要具体规定可以存储键和值类型。不同于 Objective-C 的<code>NSDictionary</code>和<code>NSMutableDictionary</code> 类可以使用任何类型的对象来作键和值并且不提供任何关于这些对象的本质信息。在 Swift 中，在某个特定字典中可以存储的键和值必须提前定义清楚，方法是通过显性类型标注或者类型推断。</p>


<p>Swift 的字典使用<code>Dictionary&lt;KeyType, ValueType&gt;</code>定义,其中<code>KeyType</code>是字典中键的数据类型，<code>ValueType</code>是字典中对应于这些键所存储值的数据类型。</p>


<p><code>KeyType</code>的唯一限制就是可哈希的，这样可以保证它是独一无二的，所有的 Swift 基本类型（例如<code>String</code>，<code>Int</code>， <code>Double</code>和<code>Bool</code>）都是默认可哈希的，并且所有这些类型都可以在字典中当做键使用。未关联值的枚举成员（参见<a href="08_Enumerations.html">枚举</a>）也是默认可哈希的。</p>


<p><a name="dictionary_literals"></a></p>


<h2 id="-">字典字面语句</h2>


<p>我们可以使用字典字面语句来构造字典，他们和我们刚才介绍过的数组字面语句拥有相似语法。一个字典字面语句是一个定义拥有一个或者多个键值对的字典集合的简单语句。</p>


<p>一个键值对是一个<code>key</code>和一个<code>value</code>的结合体。在字典字面语句中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含并且由逗号分割：</p>


<pre><code>[key 1: value 1, key 2: value 2, key 3: value 3]
</code></pre>


<p>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>


<pre><code>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]
</code></pre>


<p><code>airports</code>字典被定义为一种<code>Dictionary&lt;String, String&gt;</code>,它意味着这个字典的键和值都是<code>String</code>类型。</p>


<blockquote>
<p>注意：</p>
<p><code>airports</code>字典被声明为变量（用<code>var</code>关键字）而不是常量（<code>let</code>关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
</blockquote>


<p><code>airports</code>字典使用字典字面语句初始化，包含两个键值对。第一对的键是<code>TYO</code>，值是<code>Tokyo</code>。第二对的键是<code>DUB</code>，值是<code>Dublin</code>。</p>


<p>这个字典语句包含了两个<code>String: String</code>类型的键值对。他们对应<code>airports</code>变量声明的类型（一个只有<code>String</code>键和<code>String</code>值的字典）所以这个字典字面语句是构造两个初始数据项的<code>airport</code>字典。</p>


<p>和数组一样，如果我们使用字面语句构造字典就不用把类型定义清楚。<code>airports</code>的也可以用这种方法简短定义：</p>


<pre><code>var airports = ["TYO": "Tokyo", "DUB": "Dublin"]
</code></pre>


<p>因为这个语句中所有的键和值都分别是相同的数据类型，Swift 可以推断出<code>Dictionary&lt;String, String&gt;</code>是<code>airports</code>字典的正确类型。</p>


<p><a name="accessing_and_modifying_a_dictionary"></a></p>


<h3 id="-">读取和修改字典</h3>


<p>我们可以通过字典的方法和属性来读取和修改字典，或者使用下标语法。和数组一样，我们可以通过字典的只读属性<code>count</code>来获取某个字典的数据项数量：</p>


<pre><code>println("The dictionary of airports contains \(airports.count) items.")
// 打印 "The dictionary of airports contains 2 items."（这个字典有两个数据项）
</code></pre>


<p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个合适类型的 key 作为下标索引，并且分配新的合适类型的值：</p>


<pre><code>airports["LHR"] = "London"
// airports 字典现在有三个数据项
</code></pre>


<p>我们也可以使用下标语法来改变特定键对应的值：</p>


<pre><code>airports["LHR"] = "London Heathrow"
// "LHR"对应的值 被改为 "London Heathrow
</code></pre>


<p>作为另一种下标方法，字典的<code>updateValue(forKey:)</code>方法可以设置或者更新特定键对应的值。就像上面所示的示例，<code>updateValue(forKey:)</code>方法在这个键不存在对应值的时候设置值或者在存在时更新已存在的值。和上面的下标方法不一样，这个方法返回更新值之前的原值。这样方便我们检查更新是否成功。</p>


<p><code>updateValue(forKey:)</code>函数会返回包含一个字典值类型的可选值。举例来说：对于存储<code>String</code>值的字典，这个函数会返回一个<code>String?</code>或者“可选 <code>String</code>”类型的值。如果值存在，则这个可选值值等于被替换的值，否则将会是<code>nil</code>。</p>


<pre><code>if let oldValue = airports.updateValue("Dublin Internation", forKey: "DUB") {
    println("The old value for DUB was \(oldValue).")
}
// 输出 "The old value for DUB was Dublin."（dub原值是dublin）
</code></pre>


<p>我们也可以使用下标语法来在字典中检索特定键对应的值。由于使用一个没有值的键这种情况是有可能发生的，可选类型返回这个键存在的相关值，否则就返回<code>nil</code>：</p>


<pre><code>if let airportName = airports["DUB"] {
    println("The name of the airport is \(airportName).")
} else {
    println("That airport is not in the airports dictionary.")
}
// 打印 "The name of the airport is Dublin INTernation."（机场的名字是都柏林国际）
</code></pre>


<p>我们还可以使用下标语法来通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对：</p>


<pre><code>airports["APL"] = "Apple Internation"
// "Apple Internation"不是真的 APL机场, 删除它
airports["APL"] = nil
// APL现在被移除了
</code></pre>


<p>另外，<code>removeValueForKey</code>方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的value或者在没有值的情况下返回<code>nil</code>：</p>


<pre><code>if let removedValue = airports.removeValueForKey("DUB") {
    println("The removed airport's name is \(removedValue).")
} else {
    println("The airports dictionary does not contain a value for DUB.")
}
// prints "The removed airport's name is Dublin International."
</code></pre>


<p><a name="iterating_over_a_dictionary"></a></p>


<h3 id="-">字典遍历</h3>


<p>我们可以使用<code>for-in</code>循环来遍历某个字典中的键值对。每一个字典中的数据项都由<code>(key, value)</code>元组形式返回，并且我们可以使用暂时性常量或者变量来分解这些元组：</p>


<pre><code>for (airportCode, airportName) in airports {
    prINTln("\(airportCode): \(airportName)")
}
// TYO: Tokyo
// LHR: London Heathrow
</code></pre>


<p><code>for-in</code>循环请参见<a href="05_Control_Flow.html#for_loops">For 循环</a>。</p>


<p>我们也可以通过访问他的<code>keys</code>或者<code>values</code>属性（都是可遍历集合）检索一个字典的键或者值：</p>


<pre><code>for airportCode in airports.keys {
    prINTln("Airport code: \(airportCode)")
}
// Airport code: TYO
// Airport code: LHR

for airportName in airports.values {
    prINTln("Airport name: \(airportName)")
}
// Airport name: Tokyo
// Airport name: London Heathrow
</code></pre>


<p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受<code>Array</code>实例 API 的参数，可以直接使用<code>keys</code>或者<code>values</code>属性直接构造一个新数组：</p>


<pre><code>let airportCodes = Array(airports.keys)
// airportCodes is ["TYO", "LHR"]

let airportNames = Array(airports.values)
// airportNames is ["Tokyo", "London Heathrow"]
</code></pre>


<blockquote>
<p>注意：</p>
<p>Swift 的字典类型是无序集合类型。其中字典键，值，键值对在遍历的时候会重新排列，而且其中顺序是不固定的。</p>
</blockquote>


<p><a name="creating_an_empty_dictionary"></a></p>


<h3 id="-">创建一个空字典</h3>


<p>我们可以像数组一样使用构造语法创建一个空字典：</p>


<pre><code>var namesOfIntegers = Dictionary&lt;Int, String&gt;()
// namesOfIntegers 是一个空的 Dictionary&lt;Int, String&gt;
</code></pre>


<p>这个例子创建了一个<code>Int, String</code>类型的空字典来储存英语对整数的命名。他的键是<code>Int</code>型，值是<code>String</code>型。</p>


<p>如果上下文已经提供了信息类型，我们可以使用空字典字面语句来创建一个空字典，记作<code>[:]</code>（中括号中放一个冒号）：</p>


<pre><code>namesOfIntegers[16] = "sixteen"
// namesOfIntegers 现在包含一个键值对
namesOfIntegers = [:]
// namesOfIntegers 又成为了一个 Int, String类型的空字典
</code></pre>


<blockquote>
<p>注意：</p>
<p>在后台，Swift 的数组和字典都是由泛型集合来实现的，想了解更多泛型和集合信息请参见<a href="22_Generics.html">泛型</a>。</p>
</blockquote>


<p><a name="mutability_of_collections"></a></p>


<h2 id="-">集合的可变性</h2>


<p>数组和字典都是在单个集合中存储可变值。如果我们创建一个数组或者字典并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小。与此相反，如果我们把数组或字典分配成常量，那么他就是不可变的，它的大小不能被改变。</p>


<p>对字典来说，不可变性也意味着我们不能替换其中任何现有键所对应的值。不可变字典的内容在被首次设定之后不能更改。
不可变行对数组来说有一点不同，当然我们不能试着改变任何不可变数组的大小，但是我们·可以重新设定相对现存索引所对应的值。这使得 Swift 数组在大小被固定的时候依然可以做的很棒。</p>


<p>Swift 数组的可变性行为同时影响了数组实例如何被分配和修改，想获取更多信息，请参见<a href="09_Classes_and_Structures.html#assignment_and_copy_behavior_for_collection_types">集合在赋值和复制中的行为</a>。</p>


<blockquote>
<p>注意：</p>
<p>在我们不需要改变数组大小的时候创建不可变数组是很好的习惯。如此 Swift 编译器可以优化我们创建的集合。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift附属脚本]]></title>
    <link href="http://ba-xiang.com//blog/Swift%E9%99%84%E5%B1%9E%E8%84%9A%E6%9C%AC.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/Swift附属脚本</id>
    <content type="html"><![CDATA[<p><em>附属脚本</em> 可以定义在类（Class）、结构体（structure）和枚举（enumeration）这些目标中，可以认为是访问对象、集合或序列的快捷方式，不需要再调用实例的特定的赋值和访问方法。举例来说，用附属脚本访问一个数组(Array)实例中的元素可以这样写 <code>someArray[index]</code> ，访问字典(Dictionary)实例中的元素可以这样写 <code>someDictionary[key]</code>。</p>


<p>对于同一个目标可以定义多个附属脚本，通过索引值类型的不同来进行重载，而且索引值的个数可以是多个。</p>


<!-- more -->


<blockquote>
<p>译者：这里附属脚本重载在本小节中原文并没有任何演示</p>
</blockquote>


<p><a name="subscript_syntax"></a></p>


<h2 id="-">附属脚本语法</h2>


<p>附属脚本允许你通过在实例后面的方括号中传入一个或者多个的索引值来对实例进行访问和赋值。语法类似于实例方法和计算型属性的混合。与定义实例方法类似，定义附属脚本使用<code>subscript</code>关键字，显式声明入参（一个或多个）和返回类型。与实例方法不同的是附属脚本可以设定为读写或只读。这种方式又有点像计算型属性的getter和setter：</p>


<pre><code>subscript(index: Int) -&gt; Int {
    get {
        // 返回与入参匹配的Int类型的值
    }

    set(newValue) {
        // 执行赋值操作
    }
}
</code></pre>


<p><code>newValue</code>的类型必须和附属脚本定义的返回类型相同。与计算型属性相同的是set的入参声明<code>newValue</code>就算不写，在set代码块中依然可以使用默认的<code>newValue</code>这个变量来访问新赋的值。</p>


<p>与只读计算型属性一样，可以直接将原本应该写在<code>get</code>代码块中的代码写在<code>subscript</code>中：</p>


<pre><code>subscript(index: Int) -&gt; Int {
    // 返回与入参匹配的Int类型的值
}
</code></pre>


<p>下面代码演示了一个在<code>TimesTable</code>结构体中使用只读附属脚本的用法，该结构体用来展示传入整数的<em>n</em>倍。</p>


<pre><code>struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
println("3的6倍是\(threeTimesTable[6])")
// 输出 "3的6倍是18"
</code></pre>


<p>在上例中，通过<code>TimesTable</code>结构体创建了一个用来表示索引值三倍的实例。数值<code>3</code>作为结构体<code>构造函数</code>入参初始化实例成员<code>multiplier</code>。</p>


<p>你可以通过附属脚本来来得到结果，比如<code>threeTimesTable[6]</code>。这句话访问了<code>threeTimesTable</code>的第六个元素，返回<code>18</code>或者<code>6</code>的<code>3</code>倍。</p>


<blockquote>
<p>注意：</p>
<p><code>TimesTable</code>例子是基于一个固定的数学公式。它并不适合开放写权限来对<code>threeTimesTable[someIndex]</code>进行赋值操作，这也是为什么附属脚本只定义为只读的原因。</p>
</blockquote>


<p><a name="subscript_usage"></a></p>


<h2 id="-">附属脚本用法</h2>


<p>根据使用场景不同附属脚本也具有不同的含义。通常附属脚本是用来访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。你可以在你自己特定的类或结构体中自由的实现附属脚本来提供合适的功能。</p>


<p>例如，Swift 的字典（Dictionary）实现了通过附属脚本来对其实例中存放的值进行存取操作。在附属脚本中使用和字典索引相同类型的值，并且把一个字典值类型的值赋值给这个附属脚本来为字典设值：</p>


<pre><code>var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
numberOfLegs["bird"] = 2
</code></pre>


<p>上例定义一个名为<code>numberOfLegs</code>的变量并用一个字典字面量初始化出了包含三对键值的字典实例。<code>numberOfLegs</code>的字典存放值类型推断为<code>Dictionary&lt;String, Int&gt;</code>。字典实例创建完成之后通过附属脚本的方式将整型值<code>2</code>赋值到字典实例的索引为<code>bird</code>的位置中。</p>


<p>更多关于字典（Dictionary）附属脚本的信息请参考<a href="../chapter2/04_Collection_Types.html">读取和修改字典</a></p>


<blockquote>
<p>注意：</p>
<p>Swift 中字典的附属脚本实现中，在<code>get</code>部分返回值是<code>Int?</code>，上例中的<code>numberOfLegs</code>字典通过下边返回的是一个<code>Int?</code>或者说“可选的int”，不是每个字典的索引都能得到一个整型值，对于没有设过值的索引的访问返回的结果就是<code>nil</code>；同样想要从字典实例中删除某个索引下的值也只需要给这个索引赋值为<code>nil</code>即可。</p>
</blockquote>


<p><a name="subscript_options"></a></p>


<h2 id="-">附属脚本选项</h2>


<p>附属脚本允许任意数量的入参索引，并且每个入参类型也没有限制。附属脚本的返回值也可以是任何类型。附属脚本可以使用变量参数和可变参数，但使用写入读出（in-out）参数或给参数设置默认值都是不允许的。</p>


<p>一个类或结构体可以根据自身需要提供多个附属脚本实现，在定义附属脚本时通过入参个类型进行区分，使用附属脚本时会自动匹配合适的附属脚本实现运行，这就是<em>附属脚本的重载</em>。</p>


<p>一个附属脚本入参是最常见的情况，但只要有合适的场景也可以定义多个附属脚本入参。如下例定义了一个<code>Matrix</code>结构体，将呈现一个<code>Double</code>类型的二维矩阵。<code>Matrix</code>结构体的附属脚本需要两个整型参数：</p>


<pre><code>struct Matrix {
    let rows: Int, columns: Int
    var grid: Double[]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            return grid[(row * columns) + column]
        }
        set {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            grid[(row * columns) + columns] = newValue
        }
    }
}
</code></pre>


<p><code>Matrix</code>提供了一个两个入参的构造方法，入参分别是<code>rows</code>和<code>columns</code>，创建了一个足够容纳<code>rows * columns</code>个数的<code>Double</code>类型数组。为了存储，将数组的大小和数组每个元素初始值0.0，都传入数组的构造方法中来创建一个正确大小的新数组。关于数组的构造方法和析构方法请参考<a href="../chapter2/04_Collection_Types.html">创建并且构造一个数组</a>。</p>


<p>你可以通过传入合适的<code>row</code>和<code>column</code>的数量来构造一个新的<code>Matrix</code>实例：</p>


<pre><code>var matrix = Matrix(rows: 2, columns: 2)
</code></pre>


<p>上例中创建了一个新的两行两列的<code>Matrix</code>实例。在阅读顺序从左上到右下的<code>Matrix</code>实例中的数组实例<code>grid</code>是矩阵二维数组的扁平化存储：</p>


<pre><code>// 示意图
grid = [0.0, 0.0, 0.0, 0.0]

        col0     col1
row0   [0.0,     0.0,
row1    0.0,     0.0]
</code></pre>


<p>将值赋给带有<code>row</code>和<code>column</code>附属脚本的<code>matrix</code>实例表达式可以完成赋值操作，附属脚本入参使用逗号分割</p>


<pre><code>matrix[0, 1] = 1.5
matrix[1, 0] = 3.2
</code></pre>


<p>上面两条语句分别<code>让matrix</code>的右上值为 1.5，坐下值为 3.2：</p>


<pre><code>[0.0, 1.5,
 3.2, 0.0]
</code></pre>


<p><code>Matrix</code>附属脚本的<code>getter</code>和<code>setter</code>中同时调用了附属脚本入参的<code>row</code>和<code>column</code>是否有效的判断。为了方便进行断言，<code>Matrix</code>包含了一个名为<code>indexIsValid</code>的成员方法，用来确认入参的<code>row</code>或<code>column</code>值是否会造成数组越界：</p>


<pre><code>func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
    return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
}
</code></pre>


<p>断言在附属脚本越界时触发：</p>


<pre><code>let someValue = matrix[2, 2]
// 断言将会触发，因为 [2, 2] 已经超过了matrix的最大长度
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift闭包]]></title>
    <link href="http://ba-xiang.com//blog/Swift%E9%97%AD%E5%8C%85.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/Swift闭包</id>
    <content type="html"><![CDATA[<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。
Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 lambdas 函数比较相似。</p>


<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。
这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。</p>


<!-- more -->


<blockquote>
<p>注意：</p>
<p>如果您不熟悉捕获（capturing）这个概念也不用担心，您可以在 <a href="#capturing_values">值捕获</a> 章节对其进行详细了解。</p>
</blockquote>


<p>在<a href="../chapter2/06_Function.html">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：</p>


<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>


<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>


<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随（Trailing）闭包语法</li>
</ul>


<p><a name="closure_expressions"></a></p>


<h2 id="-closure-expressions-">闭包表达式（Closure Expressions）</h2>


<p><a href="../chapter2/06_Function.html#nested_function">嵌套函数</a> 是一个在较复杂函数中方便进行命名和定义自包含代码模块的方式。
当然，有时候撰写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在您处理一些函数并需要将另外一些函数作为该函数的参数时。</p>


<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。
闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。
下面闭包表达式的例子通过使用几次迭代展示了<code>sort</code>函数定义和语法优化的方式。
每一次迭代都用更简洁的方式描述了相同的功能。</p>


<p><a name="the_sort_function"></a></p>


<h3 id="sort-the-sort-function-">sort 函数（The Sort Function）</h3>


<p>Swift 标准库提供了<code>sort</code>函数，会根据您提供的基于输出类型排序的闭包函数将已知类型数组中的值进行排序。
一旦排序完成，函数会返回一个与原数组大小相同的新数组，该数组中包含已经正确排序的同类型元素。</p>


<p>下面的闭包表达式示例使用<code>sort</code>函数对一个<code>String</code>类型的数组进行字母逆序排序，以下是初始数组值：</p>


<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</code></pre>


<p><code>sort</code>函数需要传入两个参数：</p>


<ul>
<li>已知类型的数组</li>
<li>闭包函数，该闭包函数需要传入与数组类型相同的两个值，并返回一个布尔类型值来告诉<code>sort</code>函数当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回<code>true</code>，反之返回<code>false</code>。</li>
</ul>


<p>该例子对一个<code>String</code>类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p>


<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为<code>sort</code>函数的第二个参数传入：</p>


<pre><code>func backwards(s1: String, s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversed = sort(names, backwards)
// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
</code></pre>


<p>如果第一个字符串 (<code>s1</code>) 大于第二个字符串 (<code>s2</code>)，<code>backwards</code>函数返回<code>true</code>，表示在新的数组中<code>s1</code>应该出现在<code>s2</code>前。
对于字符串中的字符来说，“大于” 表示 “按照字母顺序较晚出现”。
这意味着字母<code>"B"</code>大于字母<code>"A"</code>，字符串<code>"Tom"</code>大于字符串<code>"Tim"</code>。
其将进行字母逆序排序，<code>"Barry"</code>将会排在<code>"Alex"</code>之后。</p>


<p>然而，这是一个相当冗长的方式，本质上只是写了一个单表达式函数 (a &gt; b)。
在下面的例子中，利用闭合表达式语法可以更好的构造一个内联排序闭包。</p>


<p><a name="closure_expression_syntax"></a></p>


<h3 id="-closure-expression-syntax-">闭包表达式语法（Closure Expression Syntax）</h3>


<p>闭包表达式语法有如下一般形式：</p>


<pre><code>{ (parameters) -&gt; returnType in
    statements
}
</code></pre>


<p>闭包表达式语法可以使用常量、变量和<code>inout</code>类型作为参数，不提供默认值。
也可以在参数列表的最后使用可变参数。
元组也可以作为参数和返回值。</p>


<p>下面的例子展示了之前<code>backwards</code>函数对应的闭包表达式版本的代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
    })
</code></pre>


<p>需要注意的是内联闭包参数和返回值类型声明与<code>backwards</code>函数类型声明相同。
在这两种方式中，都写成了<code>(s1: String, s2: String) -&gt; Bool</code>。
然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>


<p>闭包的函数体部分由关键字<code>in</code>引入。
该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>


<p>因为这个闭包的函数体部分如此短以至于可以将其改写成一行代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )
</code></pre>


<p>这说明<code>sort</code>函数的整体调用保持不变，一对圆括号仍然包裹住了函数中整个参数集合。而其中一个参数现在变成了内联闭包（相比于<code>backwards</code>版本的代码）。</p>


<p><a name="inferring_type_from_context"></a></p>


<h3 id="-inferring-type-from-context-">根据上下文推断类型（Inferring Type From Context）</h3>


<p>因为排序闭包函数是作为<code>sort</code>函数的参数进行传入的，Swift可以推断其参数和返回值的类型。
<code>sort</code>期望第二个参数是类型为<code>(String, String) -&gt; Bool</code>的函数，因此实际上<code>String</code>,<code>String</code>和<code>Bool</code>类型并不需要作为闭包表达式定义中的一部分。
因为所有的类型都可以被正确推断，返回箭头 (<code>-&gt;</code>) 和围绕在参数周围的括号也可以被省略：</p>


<pre><code>reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )
</code></pre>


<p>实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数时，都可以推断出闭包的参数和返回值类型，这意味着您几乎不需要利用完整格式构造任何内联闭包。</p>


<p><a name="implicit_returns_from_single_expression_closures"></a></p>


<h3 id="-implicit-return-from-single-expression-clossures-">单表达式闭包隐式返回（Implicit Return From Single-Expression Clossures）</h3>


<p>单行表达式闭包可以通过隐藏<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>


<pre><code>reversed = sort(names, { s1, s2 in s1 &gt; s2 } )
</code></pre>


<p>在这个例子中，<code>sort</code>函数的第二个参数函数类型明确了闭包必须返回一个<code>Bool</code>类型值。
因为闭包函数体只包含了一个单一表达式 (<code>s1 &gt; s2</code>)，该表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略。</p>


<p><a name="shorthand_argument_names"></a></p>


<h3 id="-shorthand-argument-names-">参数名称缩写（Shorthand Argument Names）</h3>


<p>Swift 自动为内联函数提供了参数名称缩写功能，您可以直接通过<code>$0</code>,<code>$1</code>,<code>$2</code>来顺序调用闭包的参数。</p>


<p>如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。
<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>


<pre><code>reversed = sort(names, { $0 &gt; $1 } )
</code></pre>


<p>在这个例子中，<code>$0</code>和<code>$1</code>表示闭包中第一个和第二个<code>String</code>类型的参数。</p>


<p><a name="operator_functions"></a></p>


<h3 id="-operator-functions-">运算符函数（Operator Functions）</h3>


<p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。
Swift 的<code>String</code>类型定义了关于大于号 (<code>&gt;</code>) 的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。
而这正好与<code>sort</code>函数的第二个参数需要的函数类型相符合。
因此，您可以简单地传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现：</p>


<pre><code>reversed = sort(names, &gt;)
</code></pre>


<p>更多关于运算符表达式的内容请查看 <a href="../chapter2/23_Advanced_Operators.html#operator_functions">运算符函数</a>。</p>


<p><a name="trailing_closures"></a></p>


<h2 id="-trailing-closures-">尾随闭包（Trailing Closures）</h2>


<p>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。
尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</p>


<pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; ()) {
    // 函数体部分
}

// 以下是不使用尾随闭包进行函数调用

someFunctionThatTakesAClosure({
    // 闭包主体部分
    })

// 以下是使用尾随闭包进行函数调用

someFunctionThatTakesAClosure() {
    // 闭包主体部分
}
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把<code>()</code>省略掉。</p>
</blockquote>


<p>在上例中作为<code>sort</code>函数参数的字符串排序闭包可以改写为：</p>


<pre><code>reversed = sort(names) { $0 &gt; $1 }
</code></pre>


<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。
举例来说，Swift 的<code>Array</code>类型有一个<code>map</code>方法，其获取一个闭包表达式作为其唯一参数。
数组中的每一个元素调用一次该闭包函数，并返回该元素所映射的值(也可以是不同类型的值)。
具体的映射方式和返回值类型由闭包来指定。</p>


<p>当提供给数组闭包函数后，<code>map</code>方法将返回一个新的数组，数组中包含了与原数组一一对应的映射后的值。</p>


<p>下例介绍了如何在<code>map</code>方法中使用尾随闭包将<code>Int</code>类型数组<code>[16,58,510]</code>转换为包含对应<code>String</code>类型的数组<code>["OneSix", "FiveEight", "FiveOneZero"]</code>:</p>


<pre><code>let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
</code></pre>


<p>如上代码创建了一个数字位和他们名字映射的英文版本字典。
同时定义了一个准备转换为字符串的整型数组。</p>


<p>您现在可以通过传递一个尾随闭包给<code>numbers</code>的<code>map</code>方法来创建对应的字符串版本数组。
需要注意的时调用<code>numbers.map</code>不需要在<code>map</code>后面包含任何括号，因为其只需要传递闭包表达式这一个参数，并且该闭包表达式参数通过尾随方式进行撰写：</p>


<pre><code>let strings = numbers.map {
    (var number) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
// strings 常量被推断为字符串类型数组，即 String[]
// 其值为 ["OneSix", "FiveEight", "FiveOneZero"]
</code></pre>


<p><code>map</code>在数组中为每一个元素调用了闭包表达式。
您不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行推断。</p>


<p>闭包<code>number</code>参数被声明为一个变量参数（变量的具体描述请参看<a href="../chapter2/06_Functions.html#closure_expression_syntax">常量参数和变量参数</a>），因此可以在闭包函数体内对其进行修改。
闭包表达式制定了返回类型为<code>String</code>，以表明存储映射值的新数组类型为<code>String</code>。</p>


<p>闭包表达式在每次被调用的时候创建了一个字符串并返回。
其使用求余运算符 (number % 10) 计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。</p>


<blockquote>
<p>注意：</p>
<p>字典<code>digitNames</code>下标后跟着一个叹号 (!)，因为字典下标返回一个可选值 (optional value)，表明即使该 key 不存在也不会查找失败。
在上例中，它保证了<code>number % 10</code>可以总是作为一个<code>digitNames</code>字典的有效下标 key。
因此叹号可以用于强制解析 (force-unwrap) 存储在可选下标项中的<code>String</code>类型值。</p>
</blockquote>


<p>从<code>digitNames</code>字典中获取的字符串被添加到输出的前部，逆序建立了一个字符串版本的数字。
（在表达式<code>number % 10</code>中，如果number为16，则返回6，58返回8，510返回0）。</p>


<p><code>number</code>变量之后除以10。
因为其是整数，在计算过程中未除尽部分被忽略。
因此 16变成了1，58变成了5，510变成了51。</p>


<p>整个过程重复进行，直到<code>number /= 10</code>为0，这时闭包会将字符串输出，而<code>map</code>函数则会将字符串添加到所映射的数组中。</p>


<p>上例中尾随闭包语法在函数后整洁封装了具体的闭包功能，而不再需要将整个闭包包裹在<code>map</code>函数的括号内。</p>


<p><a name="capturing_values"></a></p>


<h2 id="-capturing-values-">捕获值（Capturing Values）</h2>


<p>闭包可以在其定义的上下文中捕获常量或变量。
即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>


<p>Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>


<p>下例为一个叫做<code>makeIncrementor</code>的函数，其包含了一个叫做<code>incrementor</code>嵌套函数。
嵌套函数<code>incrementor</code>从上下文中捕获了两个值，<code>runningTotal</code>和<code>amount</code>。
之后<code>makeIncrementor</code>将<code>incrementor</code>作为闭包返回。
每次调用<code>incrementor</code>时，其会以<code>amount</code>作为增量增加<code>runningTotal</code>的值。</p>


<pre><code>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}
</code></pre>


<p><code>makeIncrementor</code>返回类型为<code>() -&gt; Int</code>。
这意味着其返回的是一个函数，而不是一个简单类型值。
该函数在每次调用时不接受参数只返回一个<code>Int</code>类型的值。
关于函数返回其他函数的内容，请查看<a href="../chapter2/06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>


<p><code>makeIncrementor</code>函数定义了一个整型变量<code>runningTotal</code>(初始为0) 用来存储当前跑步总数。
该值通过<code>incrementor</code>返回。</p>


<p><code>makeIncrementor</code>有一个<code>Int</code>类型的参数，其外部命名为<code>forIncrement</code>， 内部命名为<code>amount</code>，表示每次<code>incrementor</code>被调用时<code>runningTotal</code>将要增加的量。</p>


<p><code>incrementor</code>函数用来执行实际的增加操作。
该函数简单地使<code>runningTotal</code>增加<code>amount</code>，并将其返回。</p>


<p>如果我们单独看这个函数，会发现看上去不同寻常：</p>


<pre><code>func incrementor() -&gt; Int {
    runningTotal += amount
    return runningTotal
}
</code></pre>


<p><code>incrementor</code>函数并没有获取任何参数，但是在函数体内访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为其通过捕获在包含它的函数体内已经存在的<code>runningTotal</code>和<code>amount</code>变量而实现。</p>


<p>由于没有修改<code>amount</code>变量，<code>incrementor</code>实际上捕获并存储了该变量的一个副本，而该副本随着<code>incrementor</code>一同被存储。</p>


<p>然而，因为每次调用该函数的时候都会修改<code>runningTotal</code>的值，<code>incrementor</code>捕获了当前<code>runningTotal</code>变量的引用，而不是仅仅复制该变量的初始值。捕获一个引用保证了当<code>makeIncrementor</code>结束时候并不会消失，也保证了当下一次执行<code>incrementor</code>函数时，<code>runningTotal</code>可以继续增加。</p>


<blockquote>
<p>注意：</p>
<p>Swift 会决定捕获引用还是拷贝值。
您不需要标注<code>amount</code>或者<code>runningTotal</code>来声明在嵌入的<code>incrementor</code>函数中的使用方式。
Swift 同时也处理<code>runingTotal</code>变量的内存管理操作，如果不再被<code>incrementor</code>函数使用，则会被清除。</p>
</blockquote>


<p>下面代码为一个使用<code>makeIncrementor</code>的例子：</p>


<pre><code>let incrementByTen = makeIncrementor(forIncrement: 10)
</code></pre>


<p>该例子定义了一个叫做<code>incrementByTen</code>的常量，该常量指向一个每次调用会加10的<code>incrementor</code>函数。
调用这个函数多次可以得到以下结果：</p>


<pre><code>incrementByTen()
// 返回的值为10
incrementByTen()
// 返回的值为20
incrementByTen()
// 返回的值为30
</code></pre>


<p>如果您创建了另一个<code>incrementor</code>，其会有一个属于自己的独立的<code>runningTotal</code>变量的引用。
下面的例子中，<code>incrementBySevne</code>捕获了一个新的<code>runningTotal</code>变量，该变量和<code>incrementByTen</code>中捕获的变量没有任何联系：</p>


<pre><code>let incrementBySeven = makeIncrementor(forIncrement: 7)
incrementBySeven()
// 返回的值为7
incrementByTen()
// 返回的值为40
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果您闭包分配给一个类实例的属性，并且该闭包通过指向该实例或其成员来捕获了该实例，您将创建一个在闭包和实例间的强引用环。
Swift 使用捕获列表来打破这种强引用环。更多信息，请参考 <a href="../chapter2/16_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>


<p><a name="closures_are_reference_types"></a></p>


<h2 id="-closures-are-reference-types-">闭包是引用类型（Closures Are Reference Types）</h2>


<p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。
这是因为函数和闭包都是引用类型。</p>


<p>无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。
上面的例子中，<code>incrementByTen</code>指向闭包的引用是一个常量，而并非闭包内容本身。</p>


<p>这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包：</p>


<pre><code>let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// 返回的值为50
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift基础]]></title>
    <link href="http://ba-xiang.com//blog/Swift%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/Swift语言简介</id>
    <content type="html"><![CDATA[<h3>常量和变量</h3>

<p>常量和变量把一个名字（比如maximumNumberOfLoginAttempts或者welcomeMessage）和一个指定类型的值（比如数字10或者字符串&#8221;Hello&#8221;）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>


<p>Swift 是 iOS 和 OS X 应用开发的一门新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>


<!-- more -->


<p>Swift 的类型是在 C 和 Objective-C 的基础上提出的，<code>Int</code>是整型；<code>Double</code>和<code>Float</code>是浮点型；<code>Bool</code>是布尔型；<code>String</code>是字符串。Swift 还有两个有用的集合类型，<code>Array</code>和<code>Dictionary</code>，请参考<a href="04_Collection_Types.html">集合类型</a>。</p>


<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，值不可变的变量有着广泛的应用，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更好地表达你的意图。</p>


<p>除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>


<p>Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用<code>nil</code>，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的<code>nil</code>指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>


<p>Swift 是一个类型安全的语言，可选就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个<code>String</code>，类型安全会阻止你不小心传入一个<code>Int</code>。你可以在开发阶段尽早发现并修正错误。</p>


<p><a name="constants_and_variables"></a></p>


<h2 id="-">常量和变量</h2>


<p>常量和变量把一个名字（比如<code>maximumNumberOfLoginAttempts</code>或者<code>welcomeMessage</code>）和一个指定类型的值（比如数字<code>10</code>或者字符串<code>"Hello"</code>）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>


<h3 id="-">声明常量和变量</h3>


<p>常量和变量必须在使用前声明，用<code>let</code>来声明常量，用<code>var</code>来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：</p>


<pre><code>let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
</code></pre>


<p>这两行代码可以被理解为：</p>


<p>“声明一个名字是<code>maximumNumberOfLoginAttempts</code>的新常量，并给它一个值<code>10</code>。然后，声明一个名字是<code>currentLoginAttempt</code>的变量并将它的值初始化为<code>0</code>.”</p>


<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>


<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>


<pre><code>var x = 0.0, y = 0.0, z = 0.0
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果你的代码中有不需要改变的值，请使用<code>let</code>关键字将它声明为常量。只将需要改变的值声明为变量。</p>
</blockquote>


<h3 id="-">类型标注</h3>


<p>当你声明常量或者变量的时候可以加上<em>类型标注(type annotation)</em>，说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>


<p>这个例子给<code>welcomeMessage</code>变量添加了类型标注，表示这个变量可以存储<code>String</code>类型的值：</p>


<pre><code>var welcomeMessage: String
</code></pre>


<p>声明中的冒号代表着“是&#8230;类型”，所以这行代码可以被理解为：</p>


<p>“声明一个类型为<code>String</code>，名字为<code>welcomeMessage</code>的变量。”</p>


<p>“类型为<code>String</code>”的意思是“可以存储任意<code>String</code>类型的值。”</p>


<p><code>welcomeMessage</code>变量现在可以被设置成任意字符串：</p>


<pre><code>welcomeMessage = "Hello"
</code></pre>


<blockquote>
<p>注意：</p>
<p>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。在上面的例子中，没有给<code>welcomeMessage</code>赋初始值，所以变量<code>welcomeMessage</code>的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
</blockquote>


<h3 id="-">常量和变量的命名</h3>


<p>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：</p>


<pre><code>let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
</code></pre>


<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>


<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</p>


<blockquote>
<p>注意：</p>
<p>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。</p>
</blockquote>


<p>你可以更改现有的变量值为其他同类型的值，在下面的例子中，<code>friendlyWelcome</code>的值从<code>"Hello!"</code>改为了<code>"Bonjour!"</code>:</p>


<pre><code>var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome 现在是 "Bonjour!"
</code></pre>


<p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>


<pre><code>let languageName = "Swift"
languageName = "Swift++"
// 这会报编译时错误 - languageName 不可改变
</code></pre>


<h3 id="-">输出常量和变量</h3>


<p>你可以用<code>println</code>函数来输出当前常量或变量的值:</p>


<pre><code>println(friendlyWelcome)
// 输出 "Bonjour!"
</code></pre>


<p><code>println</code>是一个用来输出的全局函数，输出的内容会在最后换行。如果你用 Xcode，<code>println</code>将会输出内容到“console”面板上。(另一种函数叫<code>print</code>，唯一区别是在输出内容最后不会换行。)</p>


<p><code>println</code>函数输出传入的<code>String</code>值：</p>


<pre><code>println("This is a string")
// 输出 "This is a string"
</code></pre>


<p>与 Cocoa 里的<code>NSLog</code>函数类似的是，<code>println</code>函数可以输出更复杂的信息。这些信息可以包含当前常量和变量的值。</p>


<p>Swift 用<em>字符串插值（string interpolation）</em>的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>


<pre><code>println("The current value of friendlyWelcome is \(friendlyWelcome)")
// 输出 "The current value of friendlyWelcome is Bonjour!
</code></pre>


<blockquote>
<p>注意：</p>
<p>字符串插值所有可用的选项，请参考<a href="03_Strings_and_Characters.html#string_interpolation">字符串插值</a>。</p>
</blockquote>


<p><a name="comments"></a></p>


<h2 id="-">注释</h2>


<p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>


<p>Swift 中的注释与C 语言的注释非常相似。单行注释以双正斜杠作(<code>//</code>)为起始标记:</p>


<pre><code>// 这是一个注释
</code></pre>


<p>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号(<code>/*</code>)，终止标记为一个星号后跟随单个正斜杠(<code>*/</code>):</p>


<pre><code>/* 这是一个,
多行注释 */
</code></pre>


<p>与C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：</p>


<pre><code>/* 这是第一个多行注释的开头
/* 这是第二个被嵌套的多行注释 */
这是第一个多行注释的结尾 */
</code></pre>


<p>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>


<p><a name="semicolons"></a></p>


<h2 id="-">分号</h2>


<p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（<code>;</code>），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：</p>


<pre><code>let cat = "🐱"; println(cat)
// 输出 "🐱"
</code></pre>


<p><a name="integers"></a></p>


<h2 id="-">整数</h2>


<p>整数就是没有小数部分的数字，比如<code>42</code>和<code>-23</code>。整数可以是<code>有符号</code>（正、负、零）或者<code>无符号</code>（正、零）。</p>


<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是<code>UInt8</code>，32位有符号整数类型是<code>Int32</code>。就像 Swift 的其他类型一样，整数类型采用大写命名法。</p>


<h3 id="-">整数范围</h3>


<p>你可以访问不同整数类型的<code>min</code>和<code>max</code>属性来获取对应类型的最大值和最小值：</p>


<pre><code>let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型的最小值
let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型的最大值
</code></pre>


<h3 id="int">Int</h3>


<p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型<code>Int</code>，长度与当前平台的原生字长相同：</p>


<ul>
<li>在32位平台上，<code>Int</code>和<code>Int32</code>长度相同。</li>
<li>在64位平台上，<code>Int</code>和<code>Int64</code>长度相同。</li>
</ul>


<p>除非你需要特定长度的整数，一般来说使用<code>Int</code>就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，<code>Int</code>可以存储的整数范围也可以达到<code>-2147483648</code>~<code>2147483647</code>，大多数时候这已经足够大了。</p>


<h3 id="uint">UInt</h3>


<p>Swift 也提供了一个特殊的无符号类型<code>UInt</code>，长度与当前平台的原生字长相同：</p>


<ul>
<li>在32位平台上，<code>UInt</code>和<code>UInt32</code>长度相同。</li>
<li>在64位平台上，<code>UInt</code>和<code>UInt64</code>长度相同。</li>
</ul>


<blockquote>
<p>注意：</p>
<p>尽量不要使用<code>UInt</code>，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推测，请参考<a href="#type_safety_and_type_inference">类型安全和类型推测</a>。</p>
</blockquote>


<p><a name="floating-point_numbers"></a></p>


<h2 id="-">浮点数</h2>


<p>浮点数是有小数部分的数字，比如<code>3.14159</code>，<code>0.1</code>和<code>-273.15</code>。</p>


<p>浮点类型比整数类型表示的范围更大，可以存储比<code>Int</code>类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>


<ul>
<li><code>Double</code>表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li><code>Float</code>表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>


<blockquote>
<p>注意：</p>
<p><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。</p>
</blockquote>


<p><a name="type_safety_and_type_inference"></a></p>


<h2 id="-">类型安全和类型推测</h2>


<p>Swift 是一个<em>类型安全(type safe )</em>的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个<code>String</code>，你绝对不可能不小心传进去一个<code>Int</code>。</p>


<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行<em>类型检查(type checks)</em>，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>


<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用<em>类型推测(type inference)</em>来选择合适的类型。有了类型推测，编译器可以在编译代码的时候自动推测出表达式的类型。原理很简单，只要检查你赋的值即可。</p>


<p>因为有类型推测，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>


<p>当你声明常量或者变量并赋初值的时候类型推测非常有用。当你在声明常量或者变量的时候赋给它们一个<em>字面量(literal value 或 literal)</em>即可触发类型推测。（字面量就是会直接出现在你代码中的值，比如<code>42</code>和<code>3.14159</code>。）</p>


<p>例如，如果你给一个新常量赋值<code>42</code>并且没有标明类型，Swift 可以推测出常量类型是<code>Int</code>，因为你给它赋的初始值看起来像一个整数：</p>


<pre><code>let meaningOfLife = 42
// meaningOfLife 会被推测为 Int 类型
</code></pre>


<p>同理，如果你没有给浮点字面量标明类型，Swift 会推测你想要的是<code>Double</code>：</p>


<pre><code>let pi = 3.14159
// pi 会被推测为 Double 类型
</code></pre>


<p>当推测浮点数的类型时，Swift 总是会选择<code>Double</code>而不是<code>Float</code>。</p>


<p>如果表达式中同时出现了整数和浮点数，会被推测为<code>Double</code>类型：</p>


<pre><code>let anotherPi = 3 + 0.14159
// anotherPi 会被推测为 Double 类型
</code></pre>


<p>原始值<code>3</code>没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推测为<code>Double</code>类型。</p>


<p><a name="numeric_literals"></a></p>


<h2 id="-">数值型字面量</h2>


<p>整数字面量可以被写作：</p>


<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是<code>0b</code></li>
<li>一个八进制数，前缀是<code>0o</code></li>
<li>一个十六进制数，前缀是<code>0x</code></li>
</ul>


<p>下面的所有整数字面量的十进制值都是<code>17</code>:</p>


<pre><code>let decimalInteger = 17
let binaryInteger = 0b10001       // 二进制的17
let octalInteger = 0o21           // 八进制的17
let hexadecimalInteger = 0x11     // 十六进制的17
</code></pre>


<p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是<code>0x</code>）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。浮点字面量还有一个可选的<em>指数(exponent)</em>，在十进制浮点数中通过大写或者小写的<code>e</code>来指定，在十六进制浮点数中通过大写或者小写的<code>p</code>来指定。</p>


<p>如果一个十进制数的指数为<code>exp</code>，那这个数相当于基数和<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-7-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-57"><span style="display: inline-block; position: relative; width: 2.116em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(3.115em 1000em 4.184em -0.399em); top: -4em; left: 0em;"><span class="mrow" id="MathJax-Span-58"><span class="msubsup" id="MathJax-Span-59"><span style="display: inline-block; position: relative; width: 2.116em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-60" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-61"><span class="mrow" id="MathJax-Span-62"><span class="mi" id="MathJax-Span-63" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-64" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-65" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">p</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.061em; vertical-align: -0.089em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-7">10^{exp}</script>的乘积：</p>


<ul>
<li><code>1.25e2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-8-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-66"><span style="display: inline-block; position: relative; width: 4.365em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-67"><span class="mn" id="MathJax-Span-68" style="font-family: STIXGeneral-Regular;">1.25</span><span class="mo" id="MathJax-Span-69" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-70" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.492em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-71" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-72"><span class="mrow" id="MathJax-Span-73"><span class="mn" id="MathJax-Span-74" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-8">1.25 × 10^{2}</script>，等于 <code>125.0</code>。</li>
<li><code>1.25e-2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-9-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-75"><span style="display: inline-block; position: relative; width: 4.819em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-76"><span class="mn" id="MathJax-Span-77" style="font-family: STIXGeneral-Regular;">1.25</span><span class="mo" id="MathJax-Span-78" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-79" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.946em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-80" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-81"><span class="mrow" id="MathJax-Span-82"><span class="mo" id="MathJax-Span-83" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">−</span><span class="mn" id="MathJax-Span-84" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-9">1.25 × 10^{-2}</script>，等于 <code>0.0125</code>。</li>
</ul>


<p>如果一个十六进制数的指数为<code>exp</code>，那这个数相当于基数和<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-10-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-85"><span style="display: inline-block; position: relative; width: 1.606em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(3.115em 1000em 4.17em -0.481em); top: -4em; left: 0em;"><span class="mrow" id="MathJax-Span-86"><span class="msubsup" id="MathJax-Span-87"><span style="display: inline-block; position: relative; width: 1.606em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-88" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-89"><span class="mrow" id="MathJax-Span-90"><span class="mi" id="MathJax-Span-91" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-92" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-93" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">p</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.044em; vertical-align: -0.071em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-10">2^{exp}</script>的乘积：</p>


<ul>
<li><code>0xFp2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-11-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-94"><span style="display: inline-block; position: relative; width: 3.118em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-95"><span class="mn" id="MathJax-Span-96" style="font-family: STIXGeneral-Regular;">15</span><span class="mo" id="MathJax-Span-97" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-98" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 0.982em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-99" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-100"><span class="mrow" id="MathJax-Span-101"><span class="mn" id="MathJax-Span-102" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-11">15 × 2^{2}</script>，等于 <code>60.0</code>。</li>
<li><code>0xFp-2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-12-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-103"><span style="display: inline-block; position: relative; width: 3.571em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-104"><span class="mn" id="MathJax-Span-105" style="font-family: STIXGeneral-Regular;">15</span><span class="mo" id="MathJax-Span-106" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-107" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.436em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-108" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-109"><span class="mrow" id="MathJax-Span-110"><span class="mo" id="MathJax-Span-111" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">−</span><span class="mn" id="MathJax-Span-112" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-12">15 × 2^{-2}</script>，等于 <code>3.75</code>。</li>
</ul>


<p>下面的这些浮点字面量都等于十进制的<code>12.1875</code>：</p>


<pre><code>let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
</code></pre>


<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>


<pre><code>let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>


<p><a name="numeric_type_conversion"></a></p>


<h2 id="-">数值型类型转换</h2>


<p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用<code>Int</code>类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推测。
只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>


<h3 id="-">整数转换</h3>


<p>不同整数类型的变量和常量可以存储不同范围的数字。<code>Int8</code>类型的常量或者变量可以存储的数字范围是<code>-128</code>~<code>127</code>，而<code>UInt8</code>类型的常量或者变量能存储的数字范围是<code>0</code>~<code>255</code>。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：</p>


<pre><code>let cannotBeNegative: UInt8 = -1
// UInt8 类型不能存储负数，所以会报错
let tooBig: Int8 = Int8.max + 1
// Int8 类型不能存储超过最大值的数，所以会报错
</code></pre>


<p>由于每中整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>


<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量<code>twoThousand</code>是<code>UInt16</code>类型，然而常量<code>one</code>是<code>Uint8</code>类型。它们不能直接相加，因为它们类型不同。所以要调用<code>UInt16(one)</code>来创建一个新的<code>UInt16</code>数字并用<code>one</code>的值来初始化，然后使用这个新数字来计算：</p>


<pre><code>let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>


<p>现在两个数字的类型都是<code>UInt16</code>，可以进行相加。目标常量<code>twoThousandAndOne</code>的类型被推测为<code>UInt16</code>，因为它是两个<code>UInt16</code>值的和。</p>


<p><code>SomeType(ofInitialValue)</code>是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，<code>UInt16</code>有一个构造器，可以接受一个<code>UInt8</code>类型的值，所以这个构造器可以用现有的<code>UInt8</code>来创建一个新的<code>UInt16</code>。注意，你并不能传入任意类型的值，只能传入<code>UInt16</code>内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考<a href="20_Extensions.html">扩展</a>。</p>


<h3 id="-">整数和浮点数转换</h3>


<p>整数和浮点数的转换必须显式指定类型：</p>


<pre><code>let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi 等于 3.14159，所以被推测为 Double 类型
</code></pre>


<p>这个例子中，常量<code>three</code>的值被用来创建一个<code>Double</code>类型的值，所以加号两边的数类型相同。如果不进行转换，两者无法相加。</p>


<p>浮点数到整数的反向转换同样行，整数类型可以用<code>Double</code>或者<code>Float</code>类型来初始化：</p>


<pre><code>let integerPi = Int(pi)
// integerPi 等于 3，所以被推测为 Int 类型
</code></pre>


<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说<code>4.75</code>会变成<code>4</code>，<code>-3.9</code>会变成<code>-3</code>。</p>


<blockquote>
<p>注意：</p>
<p>结合数字类常量和变量不同于结合数字类字面量。字面量<code>3</code>可以直接和字面量<code>0.14159</code>相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。</p>
</blockquote>


<p><a name="type_aliases"></a></p>


<h2 id="-">类型别名</h2>


<p><em>类型别名(type aliases)</em>就是给现有类型定义另一个名字。你可以使用<code>typealias</code>关键字来定义类型别名。</p>


<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p>


<pre><code>typealias AudioSample = UInt16
</code></pre>


<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>


<pre><code>var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound 现在是 0
</code></pre>


<p>本例中，<code>AudioSample</code>被定义为<code>UInt16</code>的一个别名。因为它是别名，<code>AudioSample.min</code>实际上是<code>UInt16.min</code>，所以会给<code>maxAmplitudeFound</code>赋一个初值<code>0</code>。</p>


<p><a name="booleans"></a></p>


<h2 id="-">布尔值</h2>


<p>Swift 有一个基本的<em>布尔(Boolean)</em>类型，叫做<code>Bool</code>。布尔值指<em>逻辑上的(logical)</em>，因为它们只能是真或者假。Swift 有两个布尔常量，<code>true</code>和<code>false</code>：</p>


<pre><code>let orangesAreOrange = true
let turnipsAreDelicious = false
</code></pre>


<p><code>orangesAreOrange</code>和<code>turnipsAreDelicious</code>的类型会被推测为<code>Bool</code>，因为它们的初值是布尔字面量。就像之前提到的<code>Int</code>和<code>Double</code>一样，如果你创建变量的时候给它们赋值<code>true</code>或者<code>false</code>，那你不需要将常量或者变量声明为<code>Bool</code>类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推测，这让 Swift 代码更加简洁并且可读性更高。</p>


<p>当你编写条件语句比如<code>if</code>语句的时候，布尔值非常有用：</p>


<pre><code>if turnipsAreDelicious {
    println("Mmm, tasty turnips!")
} else {
    println("Eww, turnips are horrible.")
}
// 输出 "Eww, turnips are horrible."
</code></pre>


<p>条件语句，例如<code>if</code>，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<p>如果你在需要使用<code>Bool</code>类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>


<pre><code>let i = 1
if i {
    // 这个例子不会通过编译，会报错
}
</code></pre>


<p>然而，下面的例子是合法的：</p>


<pre><code>let i = 1
if i == 1 {
    // 这个例子会编译成功
}
</code></pre>


<p><code>i == 1</code>的比较结果是<code>Bool</code>类型，所以第二个例子可以通过类型检查。类似<code>i == 1</code>这样的比较，请参考<a href="05_Control_Flow.html">基本操作符</a>。</p>


<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p>


<p><a name="tuples"></a></p>


<h2 id="-">元组</h2>


<p><em>元组（tuples）</em>把多个值组合成一个复合值。元组内的值可以使任意类型，并不要求是相同类型。</p>


<p>下面这个例子中，<code>(404, "Not Found")</code>是一个描述 <em>HTTP 状态码（HTTP status code）</em>的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个<code>404 Not Found</code>状态码。</p>


<pre><code>let http404Error = (404, "Not Found")
// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")
</code></pre>


<p><code>(404, "Not Found")</code>元组把一个<code>Int</code>值和一个<code>String</code>值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为<code>(Int, String)</code>的元组”。</p>


<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为<code>(Int, Int, Int)</code>或者<code>(String, Bool)</code>或者其他任何你想要的组合的元组。</p>


<p>你可以将一个元组的内容<em>分解（decompose）</em>成单独的常量和变量，然后你就可以正常使用它们了：</p>


<pre><code>let (statusCode, statusMessage) = http404Error
println("The status code is \(statusCode)")
// 输出 "The status code is 404"
println("The status message is \(statusMessage)")
// 输出 "The status message is Not Found"
</code></pre>


<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：</p>


<pre><code>let (justTheStatusCode, _) = http404Error
println("The status code is \(justTheStatusCode)")
// 输出 "The status code is 404"
</code></pre>


<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>


<pre><code>println("The status code is \(http404Error.0)")
// 输出 "The status code is 404"
println("The status message is \(http404Error.1)")
// 输出 "The status message is Not Found"
</code></pre>


<p>你可以在定义元组的时候给单个元素命名：</p>


<pre><code>let http200Status = (statusCode: 200, description: "OK")
</code></pre>


<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>


<pre><code>println("The status code is \(http200Status.statusCode)")
// 输出 "The status code is 200"
println("The status message is \(http200Status.description)")
// 输出 "The status message is OK"
</code></pre>


<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个<code>(Int, String)</code>元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考[函数参数与返回值(06_Functions.html#Function_Parameters_and_Return_Values)。</p>


<blockquote>
<p>注意：</p>
<p>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考<a href="09_Classes_and_Structures.html">类和结构体</a>。</p>
</blockquote>


<p><a name="optionals"></a></p>


<h2 id="-">可选</h2>


<p>使用<em>可选（optionals）</em>来处理值可能缺失的情况。可选表示：</p>


<ul>
<li><em>有</em>值，等于 x</li>
</ul>


<p>或者</p>


<ul>
<li><em>没有</em>值</li>
</ul>


<blockquote>
<p>注意：</p>
<p>C 和 Objective-C 中并没有可选这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回<code>nil</code>，<code>nil</code>表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选可以让你暗示<em>任意类型</em>的值缺失，并不需要一个特殊值。</p>
</blockquote>


<p>来看一个例子。Swift 的<code>String</code>类型有一个叫做<code>toInt</code>的方法，作用是将一个<code>String</code>值转换成一个<code>Int</code>值。然而，并不是所有的字符串都可以转换成一个整数。字符串<code>"123"</code>可以被转换成数字<code>123</code>，但是字符串<code>"hello, world"</code>不行。</p>


<p>下面的例子使用<code>toInt</code>方法来尝试将一个<code>String</code>转换成<code>Int</code>：</p>


<pre><code>let possibleNumber = "123"
let convertedNumber = possibleNumber.toInt()
// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"
</code></pre>


<p>因为<code>toInt</code>方法可能会失败，所以它返回一个<em>可选的（optional）</em><code>Int</code>，而不是一个<code>Int</code>。一个可选的<code>Int</code>被写作<code>Int?</code>而不是<code>Int</code>。问号暗示包含的值是可选，也就是说可能包含<code>Int</code>值也可能不包含值。（不能包含其他任何值比如<code>Bool</code>值或者<code>String</code>值。只能是<code>Int</code>或者什么都没有。）</p>


<h3 id="if-">if 语句以及强制解析</h3>


<p>你可以使用<code>if</code>语句来判断一个可选是否包含值。如果可选有值，结果是<code>true</code>；如果没有值，结果是<code>false</code>。</p>


<p>当你确定可选包<em>确实</em>含值之后，你可以在可选的名字后面加一个感叹号(<code>!</code>)来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的<em>强制解析（forced unwrapping）</em>：</p>


<pre><code>if convertedNumber {
    println("\(possibleNumber) has an integer value of \(convertedNumber!)")
} else {
    println("\(possibleNumber) could not be converted to an integer")
}
// 输出 "123 has an integer value of 123"
</code></pre>


<p>更多关于<code>if</code>语句的内容，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<blockquote>
<p>注意：</p>
<p>使用<code>!</code>来获取一个不存在的可选值会导致运行时错误。使用<code>!</code>来强制解析值之前，一定要确定可选包含一个非<code>nil</code>的值。</p>
</blockquote>


<h3 id="-">可选绑定</h3>


<p>使用<em>可选绑定（optional binding）</em>来判断可选是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在<code>if</code>和<code>while</code>语句中来对可选的值进行判断并把值赋给一个常量或者变量。<code>if</code>和<code>while</code>语句，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<p>像下面这样在<code>if</code>语句中写一个可选绑定：</p>


<pre><code>if let constantName = someOptional {
    statements
}
</code></pre>


<p>你可以像上面这样使用可选绑定来重写<code>possibleNumber</code>这个例子：</p>


<pre><code>if let actualNumber = possibleNumber.toInt() {
    println("\(possibleNumber) has an integer value of \(actualNumber)")
} else {
    println("\(possibleNumber) could not be converted to an integer")
}
// 输出 "123 has an integer value of 123"
</code></pre>


<p>这段代码可以被理解为：</p>


<p>“如果<code>possibleNumber.toInt</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。”</p>


<p>如果转换成功，<code>actualNumber</code>常量可以在<code>if</code>语句的第一个分支中使用。它已经被可选<em>包含的</em>值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。在这个例子中，<code>actualNumber</code>只被用来输出转换结果。</p>


<p>你可以在可选绑定中使用常量和变量。如果你想在<code>if</code>语句的第一个分支中操作<code>actualNumber</code>的值，你可以改成<code>if var actualNumber</code>，这样可选包含的值就会被赋给一个变量而非常量。</p>


<h3 id="nil">nil</h3>


<p>你可以给可选变量赋值为<code>nil</code>来表示它没有值：</p>


<pre><code>var serverResponseCode: Int? = 404
// serverResponseCode 包含一个可选的 Int 值 404
serverResponseCode = nil
// serverResponseCode 现在不包含值
</code></pre>


<blockquote>
<p>注意：</p>
<p><code>nil</code>不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>


<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为<code>nil</code>：</p>


<pre><code>var surveyAnswer: String?
// surveyAnswer 被自动设置为 nil
</code></pre>


<blockquote>
<p>注意：</p>
<p>Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。<em>任何</em>类型的可选都可以被设置为<code>nil</code>，不只是对象类型。</p>
</blockquote>


<h3 id="-">隐式解析可选</h3>


<p>如上所述，可选暗示了常量或者变量可以“没有值”。可选可以通过<code>if</code>语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>


<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>


<p>这种类型的可选被定义为<em>隐式解析可选（implicitly unwrapped optionals）</em>。把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选。</p>


<p>当可选被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选非常有用。隐式解析可选主要被用在 Swift 中类的构造过程中，请参考<a href="16_Automatic_Reference_Counting.html#strong_reference_cycles_between_class_instances">类实例之间的循环强引用</a>。</p>


<p>一个隐式解析可选其实就是一个普通的可选，但是可以被当做非可选来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选<code>String</code>和隐式解析可选<code>String</code>之间的区别：</p>


<pre><code>let possibleString: String? = "An optional string."
println(possibleString!) // 需要惊叹号来获取值
// 输出 "An optional string."

let assumedString: String! = "An implicitly unwrapped optional string."
println(assumedString)  // 不需要感叹号
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<p>你可以把隐式解析可选当做一个可以自动解析的可选。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>


<blockquote>
<p>注意：</p>
<p>如果你在隐式解析可选没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选后面加一个惊叹号一样。</p>
</blockquote>


<p>你仍然可以把隐式解析可选当做普通可选来判断它是否包含值：</p>


<pre><code>if assumedString {
    println(assumedString)
}
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<p>你也可以在可选绑定中使用隐式解析可选来检查并解析它的值：</p>


<pre><code>if let definiteString = assumedString {
    println(definiteString)
}
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果一个变量之后可能变成<code>nil</code>的话请不要使用隐式解析可选。如果你需要在变量的生命周期中判断是否是<code>nil</code>的话，请使用普通可选类型。</p>
</blockquote>


<p><a name="assertions"></a></p>


<h2 id="-">断言</h2>


<p>可选可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能并不需要继续执行。这时，你可以在你的代码中触发一个<em>断言（assertion）</em>来结束代码运行并通过调试来找到值缺失的原因。</p>


<h3 id="-">使用断言进行调试</h3>


<p>断言会在运行时判断一个逻辑条件是否为<code>true</code>。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为<code>true</code>，代码运行会继续进行；如果条件判断为<code>false</code>，代码运行停止，你的应用被终止。</p>


<p>如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>


<p>你可以使用全局<code>assert</code>函数来写一个断言。向<code>assert</code>函数传入一个结果为<code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式为<code>false</code>的时候这条信息会被显示：</p>


<pre><code>let age = -3
assert(age &gt;= 0, "A person's age cannot be less than zero")
// 因为 age &lt; 0，所以断言会触发
</code></pre>


<p>在这个例子中，只有<code>age &gt;= 0</code>为<code>true</code>的时候代码运行才会继续，也就是说，当<code>age</code>的值非负的时候。如果<code>age</code>的值是负数，就像代码中那样，<code>age &gt;= 0</code>为<code>false</code>，断言被触发，结束应用。</p>


<p>断言信息不能使用字符串插值。断言信息可以省略，就像这样：</p>


<pre><code>assert(age &gt;= 0)
</code></pre>


<h3 id="-">何时使用断言</h3>


<p>当条件可能为假时使用断言，但是最终一定要<em>保证</em>条件为真，这样你的代码才能继续运行。断言的适用情景：</p>


<ul>
<li>整数的附属脚本索引被传入一个自定义附属脚本实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>值。</li>
</ul>


<p>请参考<a href="12_Subscripts.html">附属脚本</a>和<a href="06_Functions.html">函数</a>。</p>


<blockquote>
<p>注意：</p>
<p>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift自动引用计数]]></title>
    <link href="http://ba-xiang.com//blog/Swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/Swift自动引用计数</id>
    <content type="html"><![CDATA[<p>Swift 使用自动引用计数（ARC）这一机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 的内存管理机制会一直起着作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>


<p>然而，在少数情况下，ARC 为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用 ARC 来管理你的应用程序的内存。</p>


<!-- more -->


<blockquote>
<p>注意:</p>
<p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
</blockquote>


<p><a name="how_arc_works"></a></p>


<h2 id="-">自动引用计数的工作机制</h2>


<p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>


<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>


<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为一，ARC都不会销毁这个实例。</p>


<p>为了使之成为可能，无论你将实例赋值给属性，常量或者是变量，属性，常量或者变量，都会对此实例创建强引用。之所以称之为强引用，是因为它会将实例牢牢的保持住，只要强引用还在，实例是不允许被销毁的。</p>


<p><a name="arc_in_action"></a></p>


<h2 id="-">自动引用计数实战</h2>


<p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的<code>Person</code>类开始，并定义了一个叫<code>name</code>的常量属性：</p>


<pre><code>    class Person {
        let name: String

            init(name: String) {
            self.name = name
            println("\(name) is being initialized")
        }

            deinit {
            println("\(name) is being deinitialized")
        }
    }
</code></pre>


<p><code>Person</code>类有一个构造函数，此构造函数为实例的<code>name</code>属性赋值并打印出信息，以表明初始化过程生效。<code>Person</code>类同时也拥有析构函数，同样会在实例被销毁的时候打印出信息。</p>


<p>接下来的代码片段定义了三个类型为<code>Person?</code>的变量，用来按照代码片段中的顺序，为新的<code>Person</code>实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为<code>nil</code>，目前还不会引用到<code>Person</code>类的实例。</p>


<pre><code>    var reference1: Person?
    var reference2: Person?
    var reference3: Person?
</code></pre>


<p>现在你可以创建<code>Person</code>类的新实例，并且将它赋值给三个变量其中的一个：</p>


<pre><code>    reference1 = Person(name: "John Appleseed")
    // prints "John Appleseed is being initialized”
</code></pre>


<p>应当注意到当你调用<code>Person</code>类的构造函数的时候，&#8221;John Appleseed is being initialized”会被打印出来。由此可以确定构造函数被执行。</p>


<p>由于<code>Person</code>类的新实例被赋值给了<code>reference1</code>变量，所以<code>reference1</code>到<code>Person</code>类的新实例之间建立了一个强引用。正是因为这个强引用，ARC 会保证<code>Person</code>实例被保持在内存中不被销毁。</p>


<p>如果你将同样的<code>Person</code>实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>


<pre><code>    reference2 = reference1
    reference3 = reference1
</code></pre>


<p>现在这个<code>Person</code>实例已经有三个强引用了。</p>


<p>如果你通过给两个变量赋值<code>nil</code>的方式断开两个强引用（）包括最先的那个强引用），只留下一个强引用，<code>Person</code>实例不会被销毁：</p>


<pre><code>reference2 = reference1
reference3 = reference1
</code></pre>


<p>ARC 会在第三个，也即最后一个强引用被断开的时候，销毁<code>Person</code>实例，这也意味着你不再使用这个<code>Person</code>实例：</p>


<pre><code>reference3 = nil
// prints "John Appleseed is being deinitialized"
</code></pre>


<p><a name="strong_reference_cycles_between_class_instances"></a></p>


<h2 id="-">类实例之间的循环强引用</h2>


<p>在上面的例子中，ARC 会跟踪你所新创建的<code>Person</code>实例的引用数量，并且会在<code>Person</code>实例不再被需要时销毁它。</p>


<p>然而，我们可能会写出这样的代码，一个类永远不会有0个强引用。这种情况发生在两个类实例互相保持对方的强引用，并让对方不被销毁。这就是所谓的循环强引用。</p>


<p>你可以通过定义类之间的关系为弱引用或者无主引用，以此替代强引用，从而解决循环强引用的问题。具体的过程在<a href="#1">解决类实例之间的循环强引用</a>中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>


<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民:</p>


<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { println("\(name) is being deinitialized") }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    var tenant: Person?
    deinit { println("Apartment #\(number) is being deinitialized") }
}
</code></pre>


<p>每一个<code>Person</code>实例有一个类型为<code>String</code>，名字为<code>name</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>


<p>类似的，每个<code>Apartment</code>实例有一个叫<code>number</code>，类型为<code>Int</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>


<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓<code>Person</code>和<code>Apartment</code>的实例是否像预期的那样被销毁。</p>


<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>number73</code>,并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，并为可选的：</p>


<pre><code>var john: Person?
var number73: Apartment?
</code></pre>


<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将类实例赋值给<code>john</code>和<code>number73</code>变量：</p>


<pre><code>john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)
</code></pre>


<p>在两个实例被创建和赋值后，下图表面了强引用的关系。变量<code>john</code>现在有一个指向<code>Person</code>实例的强引用，而变量<code>number73</code>有一个指向<code>Apartment</code>实例的强引用：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt=""></p>


<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量<code>john</code>和<code>number73</code>中的实例，这样实例的属性才能被赋值：</p>


<pre><code>john!.apartment = number73
number73!.tenant = john
</code></pre>


<p>在将两个实例联系在一起之后，强引用的关系如图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt=""></p>


<p>不幸的是，将这两个实例关联在一起之后，一个循环强引用被创建了。<code>Person</code>实例现在有了一个指向<code>Apartment</code>实例的强引用，而<code>Apartment</code>实例也有了一个指向<code>Person</code>实例的强引用。因此，当你断开<code>john</code>和<code>number73</code>变量所持有的强引用时，引用计数并不会降为 0，实例也不会被 ARC 销毁：</p>


<pre><code>john = nil
number73 = nil
</code></pre>


<p>注意，当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。强引用循环阻止了<code>Person</code>和<code>Apartment</code>类实例的销毁，并在你的应用程序中造成了内存泄漏。</p>


<p>在你将<code>john</code>和<code>number73</code>赋值为<code>nil</code>后，强引用关系如下图：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt=""></p>


<p><code>Person</code>和<code>Apartment</code>实例之间的强引用关系保留了下来并且不会被断开。</p>


<p><a name="resolving_strong_reference_cycles_between_class_instances"></a></p>


<h2 id="-a-name-1-a-"><a name="1">解决实例之间的循环强引用</a></h2>


<p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>


<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>


<p>对于生命周期中会变为<code>nil</code>的实例使用弱引用。相反的，对于初始化赋值后再也不会被赋值为<code>nil</code>的实例，使用无主引用。</p>


<h3 id="-">弱引用</h3>


<p>弱引用不会牢牢保持住引用的实例，并且不会阻止 ARC 销毁被引用的实例。这种行为阻止了引用变为循环强引用。声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。</p>


<p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以阻止循环强引用。如果引用总是有值，则可以使用无主引用，在<a href="#2">无主引用</a>中有描述。在上面<code>Apartment</code>的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。</p>


<blockquote>
<p>注意:</p>
<p>弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。</p>
</blockquote>


<p>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。可选类型是在 Swift 语言中推荐的用来表示可能没有值的类型。</p>


<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为<code>nil</code>。你可以像其他可选值一样，检查弱引用的值是否存在，你永远也不会遇到被销毁了而不存在的实例。</p>


<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>


<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { println("\(name) is being deinitialized") }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    weak var tenant: Person?
    deinit { println("Apartment #\(number) is being deinitialized") }
}
</code></pre>


<p>然后跟之前一样，建立两个变量（john和number73）之间的强引用，并关联两个实例：</p>


<pre><code>var john: Person?
var number73: Apartment?

john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)

john!.apartment = number73
number73!.tenant = john
</code></pre>


<p>现在，两个关联在一起的实例的引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt=""></p>


<p><code>Person</code>实例依然保持对<code>Apartment</code>实例的强引用，但是<code>Apartment</code>实例只是对<code>Person</code>实例的弱引用。这意味着当你断开<code>john</code>变量所保持的强引用时，再也没有指向<code>Person</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt=""></p>


<p>由于再也没有指向<code>Person</code>实例的强引用，该实例会被销毁：</p>


<pre><code>john = nil
// prints "John Appleseed is being deinitialized"
</code></pre>


<p>唯一剩下的指向<code>Apartment</code>实例的强引用来自于变量<code>number73</code>。如果你断开这个强引用，再也没有指向<code>Apartment</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt=""></p>


<p>由于再也没有指向<code>Apartment</code>实例的强引用，该实例也会被销毁：</p>


<pre><code>number73 = nil
// prints "Apartment #73 is being deinitialized"
</code></pre>


<p>上面的两段代码展示了变量<code>john</code>和<code>number73</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>


<h3 id="-a-name-2-a-"><a name="2">无主引用</a></h3>


<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>


<p>由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为<code>nil</code>，因为非可选类型的变量不允许被赋值为<code>nil</code>。</p>


<blockquote>
<p>注意:
如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。</p>
<p>还需要注意的是如果你试图访问实例已经被销毁的无主引用，程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。</p>
</blockquote>


<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系会潜在的创造循环强引用。</p>


<p><code>Customer</code>和<code>CreditCard</code>之间的关系与前面弱引用例子中<code>Apartment</code>和<code>Person</code>的关系截然不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code>类有一个可选类型的<code>card</code>属性，但是<code>CreditCard</code>类有一个非可选类型的<code>customer</code>属性。</p>


<p>此外，只能通过将一个<code>number</code>值和<code>customer</code>实例传递给<code>CreditCard</code>构造函数的方式来创建<code>CreditCard</code>实例。这样可以确保当创建<code>CreditCard</code>实例时总是有一个<code>customer</code>实例与之关联。</p>


<p>由于信用卡总是关联着一个客户，因此将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>


<pre><code>class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { println("\(name) is being deinitialized") }
}

class CreditCard {
    let number: Int
    unowned let customer: Customer
    init(number: Int, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { println("Card #\(number) is being deinitialized") }
}
</code></pre>


<p>下面的代码片段定义了一个叫<code>john</code>的可选类型<code>Customer</code>变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为<code>nil</code>。</p>


<pre><code>var john: Customer?
</code></pre>


<p>现在你可以创建<code>Customer</code>类的实例，用它初始化<code>CreditCard</code>实例，并将新创建的<code>CreditCard</code>实例赋值为客户的<code>card</code>属性。</p>


<pre><code>john = Customer(name: "John Appleseed")
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre>


<p>在你关联两个实例后，他们的引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt=""></p>


<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对<code>Customer</code>实例的无主引用。</p>


<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt=""></p>


<p>由于再也没有指向<code>Customer</code>实例的强引用，该实例被销毁了。其后，再也没有指向<code>CreditCard</code>实例的强引用，该实例也随之被销毁了：</p>


<pre><code>john = nil
// prints "John Appleseed is being deinitialized"
// prints "Card #1234567890123456 is being deinitialized"
</code></pre>


<p>最后的代码展示了在<code>john</code>变量被设为<code>nil</code>后<code>Customer</code>实例和<code>CreditCard</code>实例的构造函数都打印出了“销毁”的信息。</p>


<h3 id="-">无主引用以及显式展开的可选属性</h3>


<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>


<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>


<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。</p>


<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后不能为<code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用显示展开的可选属性。</p>


<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>


<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，而每一个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>


<pre><code>class Country {
    let name: String
    let capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>


<p>为了建立两个类的依赖关系，<code>City</code>的构造函数有一个<code>Country</code>实例的参数，并且将实例保存为<code>country</code>属性。</p>


<p><code>Country</code>的构造函数调用了<code>City</code>的构造函数。然而，只有<code>Country</code>的实例完全初始化完后，<code>Country</code>的构造函数才能把<code>self</code>传给<code>City</code>的构造函数。（<a href="14_Initialization.html">在两步构造函数中有具体描述</a>）</p>


<p>为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将<code>Country</code>的<code>capitalCity</code>属性声明为显示展开的可选类型属性。这表示像其他可选类型一样，<code>capitalCity</code>属性的默认值为<code>nil</code>，但是不需要展开他的值就能访问它。（<a href="01_The_Basics.html">在显示展开的可选类型中有描述</a>）</p>


<p>由于<code>capitalCity</code>默认值为<code>nil</code>，一旦<code>Country</code>的实例在构造函数中给<code>name</code>属性赋值后，整个初始化过程就完成了。这代表一旦<code>name</code>属性被后，<code>Country</code>的构造函数就能引用并传递显式的<code>self</code>。<code>Country</code>的构造函数在赋值<code>capitalCity</code>时，就能将<code>self</code>作为参数传递给<code>City</code>的构造函数。</p>


<p>以上的意义在于你可以通过一条语句同时创建<code>Country</code>和<code>City</code>的实例，而不产生循环强引用，并且<code>capitalCity</code>的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>


<pre><code>var country = Country(name: "Canada", capitalName: "Ottawa")
println("\(country.name)'s capital city is called \(country.capitalCity.name)")
// prints "Canada's capital city is called Ottawa"
</code></pre>


<p>在上面的例子中，使用显示展开可选值的意义在于满足了两个类构造函数的需求。<code>capitalCity</code>属性在初始化完成后，能作为非可选值使用同事还避免了循环强引用。</p>


<p><a name="strong_reference_cycles_for_closures"></a></p>


<h2 id="-">闭包引起的循环强引用</h2>


<p>前面我们看到了循环强引用环是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破循环强引用。</p>


<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod</code>。这两种情况都导致了闭包 “捕获&#8221; <code>self</code>，从而产生了循环强引用。</p>


<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你也把一个引用赋值给了这个闭包。实质上，这跟之前的问题是一样的－两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>


<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包占用列表（closuer capture list）。同样的，在学习如何用闭包占用列表破坏循环强引用之前，先来了解一下循环强引用是如何产生的，这对我们是很有帮助的。</p>


<p>下面的例子为你展示了当一个闭包引用了<code>self</code>后是如何产生一个循环强引用的。例子中定义了一个叫<code>HTMLElement</code>的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>


<pre><code>class HTMLElement {

    let name: String
    let text: String?

    @lazy var asHTML: () -&gt; String = {
        if let text = self.text {
            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println("\(name) is being deinitialized")
    }

}
</code></pre>


<p><code>HTMLElement</code>类定义了一个<code>name</code>属性来表示这个元素的名称，例如代表段落的&#8221;p&#8221;，或者代表换行的&#8221;br&#8221;。<code>HTMLElement</code>还定义了一个可选属性<code>text</code>，用来设置和展现 HTML 元素的文本。</p>


<p>除了上面的两个属性，<code>HTMLElement</code>还定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个闭包，将<code>name</code>和<code>text</code>组合成 HTML 字符串片段。该属性是<code>() -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。</p>


<p>默认情况下，闭包赋值给了<code>asHTML</code>属性，这个闭包返回一个代表 HTML 标签的字符串。如果<code>text</code>值存在，该标签就包含可选值<code>text</code>；如果<code>text</code>不存在，该标签就不包含文本。对于段落元素，根据<code>text</code>是&#8221;some text&#8221;还是<code>nil</code>，闭包会返回&#8221;<code>&lt;p&gt;some text&lt;/p&gt;</code>&#8220;或者&#8221;<code>&lt;p /&gt;</code>&#8220;。</p>


<p>可以像实例方法那样去命名、使用<code>asHTML</code>属性。然而，由于<code>asHTML</code>是闭包而不是实例方法，如果你想改变特定元素的 HTML 处理的话，可以用自定义的闭包来取代默认值。</p>


<blockquote>
<p>注意:</p>
<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>


<p><code>HTMLElement</code>类只提供一个构造函数，通过<code>name</code>和<code>text</code>（如果有的话）参数来初始化一个元素。该类也定义了一个析构函数，当<code>HTMLElement</code>实例被销毁时，打印一条消息。</p>


<p>下面的代码展示了如何用<code>HTMLElement</code>类创建实例并打印消息。</p>


<pre><code>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints"hello, world"
</code></pre>


<blockquote>
<p>注意:</p>
<p>上面的<code>paragraph</code>变量定义为<code>可选HTMLElement</code>，因此我们可以赋值<code>nil</code>给它来演示循环强引用。</p>
</blockquote>


<p>不幸的是，上面写的<code>HTMLElement</code>类产生了类实例和<code>asHTML</code>默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt=""></p>


<p>实例的<code>asHTML</code>属性持有闭包的强引用。但是，闭包在其闭包体内使用了<code>self</code>（引用了<code>self.name</code>和<code>self.text</code>），因此闭包占有了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包占有值的信息，请参考<a href="07_Closures.html">值捕获</a>）。</p>


<blockquote>
<p>注意:</p>
<p>虽然闭包多次使用了<code>self</code>，它只占有<code>HTMLElement</code>实例的一个强引用。</p>
</blockquote>


<p>如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为循环强引用：</p>


<pre><code>paragraph = nil
</code></pre>


<p>注意<code>HTMLElementdeinitializer</code>中的消息并没有别打印，证明了<code>HTMLElement</code>实例并没有被销毁。</p>


<h2 id="-">解决闭包引起的循环强引用</h2>


<p>在定义闭包时同时定义占有列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。占有列表定义了闭包体内占有一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个占有的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>


<blockquote>
<p>注意:</p>
<p>Swift 有如下要求：只要在闭包内使用<code>self</code>的成员，就要用<code>self.someProperty</code>或者<code>self.someMethod</code>（而不只是<code>someProperty</code>或<code>someMethod</code>）。这提醒你可能会不小心就占有了<code>self</code>。</p>
</blockquote>


<h3 id="-">定义占有列表</h3>


<p>占有列表中的每个元素都是由<code>weak</code>或者<code>unowned</code>关键字和实例的引用（如<code>self</code>或<code>someInstance</code>）成对组成。每一对都在花括号中，通过逗号分开。</p>


<p>占有列表放置在闭包参数列表和返回类型之前：</p>


<pre><code>@lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre>


<p>如果闭包没有指定参数列表或者返回类型，则可以通过上下文推断，那么可以占有列表放在闭包开始的地方，跟着是关键字<code>in</code>：</p>


<pre><code>@lazy var someClosure: () -&gt; String = {
    [unowned self] in
    // closure body goes here
}
</code></pre>


<h3 id="-">弱引用和无主引用</h3>


<p>当闭包和占有的实例总是互相引用时并且总是同时销毁时，将闭包内的占有定义为无主引用。</p>


<p>相反的，当占有引用有时可能会是<code>nil</code>时，将闭包内的占有定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为<code>nil</code>。这使我们可以在闭包内检查他们是否存在。</p>


<blockquote>
<p>注意:</p>
<p>如果占有的引用绝对不会置为<code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>


<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样这样编写<code>HTMLElement</code>类来避免循环强引用：</p>


<pre><code>class HTMLElement {

    let name: String
    let text: String?

    @lazy var asHTML: () -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println("\(name) is being deinitialized")
    }

}
</code></pre>


<p>上面的<code>HTMLElement</code>实现和之前的实现一致，只是在<code>asHTML</code>闭包中多了一个占有列表。这里，占有列表是<code>[unowned self]</code>，表示“用无主引用而不是强引用来占有<code>self</code>”。</p>


<p>和之前一样，我们可以创建并打印<code>HTMLElement</code>实例：</p>


<pre><code>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints "&lt;p&gt;hello, world&lt;/p&gt;"
</code></pre>


<p>使用占有列表后引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt=""></p>


<p>这一次，闭包以无主引用的形式占有<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息。</p>


<pre><code>paragraph = nil
// prints "p is being deinitialized"
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift继承]]></title>
    <link href="http://ba-xiang.com//blog/Swift%E7%BB%A7%E6%89%BF.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/Swift继承</id>
    <content type="html"><![CDATA[<p>一个类可以<em>继承（inherit）</em>另一个类的方法（methods），属性（property）和其它特性。当一个类继承其它类时，继承类叫<em>子类（subclass）</em>，被继承类叫<em>超类（或父类，superclass）</em>。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>


<!-- more -->


<p>在 Swift 中，类可以调用和访问超类的方法，属性和附属脚本（subscripts），并且可以重写（override）这些方法，属性和附属脚本来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>


<p>可以为类中继承来的属性添加属性观察器（property observer），这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性（stored property）还是计算型属性（computed property）。</p>


<p><a name="defining_a_base_class"></a></p>


<h2 id="-base-class-">定义一个基类（Base class）</h2>


<p>不继承于其它类的类，称之为<em>基类（base calss）</em>。</p>


<blockquote>
<p>注意：</p>
<p>Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>
</blockquote>


<p>下面的例子定义了一个叫<code>Vehicle</code>的基类。这个基类声明了两个对所有车辆都通用的属性（<code>numberOfWheels</code>和<code>maxPassengers</code>）。这些属性在<code>description</code>方法中使用，这个方法返回一个<code>String</code>类型的，对车辆特征的描述：</p>


<pre><code>class Vehicle {
    var numberOfWheels: Int
    var maxPassengers: Int
    func description() -&gt; String {
        return "\(numberOfWheels) wheels; up to \(maxPassengers) passengers"
    }
    init() {
        numberOfWheels = 0
        maxPassengers = 1
    }
}
</code></pre>


<p><code>Vehicle</code>类定义了<em>构造器（initializer）</em>来设置属性的值。构造器会在<a href="../chapter2/_14Initialization.html">构造过程</a>一节中详细介绍，这里我们做一下简单介绍，以便于讲解子类中继承来的属性如何被修改。</p>


<p>构造器用于创建某个类型的一个新实例。尽管构造器并不是方法，但在语法上，两者很相似。构造器的工作是准备新实例以供使用，并确保实例中的所有属性都拥有有效的初始化值。</p>


<p>构造器的最简单形式就像一个没有参数的实例方法，使用<code>init</code>关键字：</p>


<pre><code>init() {
    // 执行构造过程
}
</code></pre>


<p>如果要创建一个<code>Vehicle</code>类的新实例，使用<em>构造器</em>语法调用上面的初始化器，即类名后面跟一个空的小括号：</p>


<pre><code>let someVehicle = Vehicle()
</code></pre>


<p>这个<code>Vehicle</code>类的构造器为任意的一辆车设置一些初始化属性值（<code>numberOfWheels = 0</code>和<code>maxPassengers = 1</code>）。</p>


<p><code>Vehicle</code>类定义了车辆的共同特性，但这个类本身并没太大用处。为了使它更为实用，你需要进一步细化它来描述更具体的车辆。</p>


<p><a name="subclassing"></a></p>


<h2 id="-subclassing-">子类生成（Subclassing）</h2>


<p><em>子类生成（Subclassing）</em>指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以优化或改变它。你还可以为子类添加新的特性。</p>


<p>为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：</p>


<pre><code>class SomeClass: SomeSuperclass {
    // 类的定义
}
</code></pre>


<p>下一个例子，定义一个更具体的车辆类叫<code>Bicycle</code>。这个新类是在 <code>Vehicle</code>类的基础上创建起来。因此你需要将<code>Vehicle</code>类放在 <code>Bicycle</code>类后面，用冒号分隔。</p>


<p>我们可以将这读作：</p>


<p>“定义一个新的类叫<code>Bicycle</code>，它继承了<code>Vehicle</code>的特性”；</p>


<pre><code>class Bicycle: Vehicle {
    init() {
        super.init()
        numberOfWheels = 2
    }
}
</code></pre>


<p> <code>Bicycle</code>是<code>Vehicle</code>的子类，<code>Vehicle</code>是<code>Bicycle</code>的超类。新的<code>Bicycle</code>类自动获得<code>Vehicle</code>类的特性，比如 <code>maxPassengers</code>和<code>numberOfWheels</code>属性。你可以在子类中定制这些特性，或添加新的特性来更好地描述<code>Bicycle</code>类。</p>


<p><code>Bicycle</code>类定义了一个构造器来设置它定制的特性（自行车只有2个轮子）。<code>Bicycle</code>的构造器调用了它父类<code>Vehicle</code>的构造器 <code>super.init()</code>，以此确保在<code>Bicycle</code>类试图修改那些继承来的属性前<code>Vehicle</code>类已经初始化过它们了。</p>


<blockquote>
<p>注意：</p>
<p>不像 Objective-C，在 Swift 中，初始化器默认是不继承的，见<a href="../chapter2/_14Initialization.html#initializer_inheritance_and_ overriding">初始化器的继承与重写</a></p>
</blockquote>


<p><code>Vehicle</code>类中<code>maxPassengers</code>的默认值对自行车来说已经是正确的，因此在<code>Bicycle</code>的构造器中并没有改变它。而<code>numberOfWheels</code>原来的值对自行车来说是不正确的，因此在初始化器中将它更改为 2。</p>


<p><code>Bicycle</code>不仅可以继承<code>Vehicle</code>的属性，还可以继承它的方法。如果你创建了一个<code>Bicycle</code>类的实例，你就可以调用它继承来的<code>description</code>方法，并且可以看到，它输出的属性值已经发生了变化：</p>


<pre><code>let bicycle = Bicycle()
println("Bicycle: \(bicycle.description())")
// Bicycle: 2 wheels; up to 1 passengers
</code></pre>


<p>子类还可以继续被其它类继承：</p>


<pre><code>class Tandem: Bicycle {
    init() {
        super.init()
        maxPassengers = 2
    }
}
</code></pre>


<p>上面的例子创建了<code>Bicycle</code>的一个子类：双人自行车（tandem）。<code>Tandem</code>从<code>Bicycle</code>继承了两个属性，而这两个属性是<code>Bicycle</code>从<code>Vehicle</code>继承而来的。<code>Tandem</code>并不修改轮子的数量，因为它仍是一辆自行车，有 2 个轮子。但它需要修改<code>maxPassengers</code>的值，因为双人自行车可以坐两个人。</p>


<blockquote>
<p>注意：</p>
<p>子类只允许修改从超类继承来的变量属性，而不能修改继承来的常量属性。</p>
</blockquote>


<p>创建一个<code>Tandem</code>类的实例，打印它的描述，即可看到它的属性已被更新：</p>


<pre><code>let tandem = Tandem()
println("Tandem: \(tandem.description())")
// Tandem: 2 wheels; up to 2 passengers
</code></pre>


<p>注意，<code>Tandem</code>类也继承了<code>description</code>方法。一个类的实例方法会被这个类的所有子类继承。</p>


<p><a name="overriding"></a></p>


<h2 id="-overriding-">重写（Overriding）</h2>


<p>子类可以为继承来的实例方法（instance method），类方法（class method），实例属性（instance property），或附属脚本（subscript）提供自己定制的实现（implementation）。我们把这种行为叫<em>重写（overriding）</em>。</p>


<p>如果要重写某个特性，你需要在重写定义的前面加上<code>override</code>关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少<code>override</code>关键字的重写都会在编译时被诊断为错误。</p>


<p><code>override</code>关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>


<h3 id="-">访问超类的方法，属性及附属脚本</h3>


<p>当你在子类中重写超类的方法，属性或附属脚本时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以优化已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>


<p>在合适的地方，你可以通过使用<code>super</code>前缀来访问超类版本的方法，属性或附属脚本：</p>


<ul>
<li>在方法<code>someMethod</code>的重写实现中，可以通过<code>super.someMethod()</code>来调用超类版本的<code>someMethod</code>方法。</li>
<li>在属性<code>someProperty</code>的 getter 或 setter 的重写实现中，可以通过<code>super.someProperty</code>来访问超类版本的<code>someProperty</code>属性。</li>
<li>在附属脚本的重写实现中，可以通过<code>super[someIndex]</code>来访问超类版本中的相同附属脚本。</li>
</ul>


<h3 id="-">重写方法</h3>


<p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。</p>


<p>下面的例子定义了<code>Vehicle</code>的一个新的子类，叫<code>Car</code>，它重写了从<code>Vehicle</code>类继承来的<code>description</code>方法：</p>


<pre><code>class Car: Vehicle {
    var speed: Double = 0.0
    init() {
        super.init()
        maxPassengers = 5
        numberOfWheels = 4
    }
    override func description() -&gt; String {
        return super.description() + "; "
            + "traveling at \(speed) mph"
    }
}
</code></pre>


<p><code>Car</code>声明了一个新的存储型属性<code>speed</code>，它是<code>Double</code>类型的，默认值是<code>0.0</code>，表示“时速是0英里”。<code>Car</code>有自己的初始化器，它将乘客的最大数量设为5，轮子数量设为4。</p>


<p><code>Car</code>重写了继承来的<code>description</code>方法，它的声明与<code>Vehicle</code>中的<code>description</code>方法一致，声明前面加上了<code>override</code>关键字。</p>


<p><code>Car</code>中的<code>description</code>方法并非完全自定义，而是通过<code>super.description</code>使用了超类<code>Vehicle</code>中的<code>description</code>方法，然后再追加一些额外的信息，比如汽车的当前速度。</p>


<p>如果你创建一个<code>Car</code>的新实例，并打印<code>description</code>方法的输出，你就会发现描述信息已经发生了改变：</p>


<pre><code>let car = Car()
println("Car: \(car.description())")
// Car: 4 wheels; up to 5 passengers; traveling at 0.0 mph
</code></pre>


<h3 id="-">重写属性</h3>


<p>你可以重写继承来的实例属性或类属性，提供自己定制的getter和setter，或添加属性观察器使重写的属性观察属性值什么时候发生改变。</p>


<h4 id="-getters-setters">重写属性的Getters和Setters</h4>


<p>你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。</p>


<p>你可以将一个继承来的只读属性重写为一个读写属性，只需要你在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。</p>


<blockquote>
<p>注意：</p>
<p>如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接返回<code>super.someProperty</code>来返回继承来的值。正如下面的<code>SpeedLimitedCar</code>的例子所示。</p>
</blockquote>


<p>以下的例子定义了一个新类，叫<code>SpeedLimitedCar</code>，它是<code>Car</code>的子类。类<code>SpeedLimitedCar</code>表示安装了限速装置的车，它的最高速度只能达到40mph。你可以通过重写继承来的<code>speed</code>属性来实现这个速度限制：</p>


<pre><code>class SpeedLimitedCar: Car {
    override var speed: Double  {
    get {
        return super.speed
    }
    set {
        super.speed = min(newValue, 40.0)
    }
    }
}
</code></pre>


<p>当你设置一个<code>SpeedLimitedCar</code>实例的<code>speed</code>属性时，属性setter的实现会去检查新值与限制值40mph的大小，它会将超类的<code>speed</code>设置为<code>newValue</code>和<code>40.0</code>中较小的那个。这两个值哪个较小由<code>min</code>函数决定，它是Swift标准库中的一个全局函数。<code>min</code>函数接收两个或更多的数，返回其中最小的那个。</p>


<p>如果你尝试将<code>SpeedLimitedCar</code>实例的<code>speed</code>属性设置为一个大于40mph的数，然后打印<code>description</code>函数的输出，你会发现速度被限制在40mph：</p>


<pre><code>let limitedCar = SpeedLimitedCar()
limitedCar.speed = 60.0
println("SpeedLimitedCar: \(limitedCar.description())")
// SpeedLimitedCar: 4 wheels; up to 5 passengers; traveling at 40.0 mph
</code></pre>


<h4 id="-property-observer-">重写属性观察器（Property Observer）</h4>


<p>你可以在属性重写中为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。关于属性观察器的更多内容，请看<a href="../chapter2/_10Properties.html#property_observer">属性观察器</a>。</p>


<blockquote>
<p>注意：</p>
<p>你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供<code>willSet</code>或<code>didSet</code>实现是不恰当。此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>
</blockquote>


<p>下面的例子定义了一个新类叫<code>AutomaticCar</code>，它是<code>Car</code>的子类。<code>AutomaticCar</code>表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位。<code>AutomaticCar</code>也提供了定制的<code>description</code>方法，可以输出当前挡位。</p>


<pre><code>class AutomaticCar: Car {
    var gear = 1
    override var speed: Double {
    didSet {
        gear = Int(speed / 10.0) + 1
    }
    }
    override func description() -&gt; String {
        return super.description() + " in gear \(gear)"
    }
}
</code></pre>


<p>当你设置<code>AutomaticCar</code>的<code>speed</code>属性，属性的<code>didSet</code>观察器就会自动地设置<code>gear</code>属性，为新的速度选择一个合适的挡位。具体来说就是，属性观察器将新的速度值除以10，然后向下取得最接近的整数值，最后加1来得到档位<code>gear</code>的值。例如，速度为10.0时，挡位为1；速度为35.0时，挡位为4：</p>


<pre><code>let automatic = AutomaticCar()
automatic.speed = 35.0
println("AutomaticCar: \(automatic.description())")
// AutomaticCar: 4 wheels; up to 5 passengers; traveling at 35.0 mph in gear 4
</code></pre>


<p><a name="preventing_overrides"></a></p>


<h2 id="-">防止重写</h2>


<p>你可以通过把方法，属性或附属脚本标记为<em><code>final</code></em>来防止它们被重写，只需要在声明关键字前加上<code>@final</code>特性即可。（例如：<code>@final var</code>, <code>@final func</code>, <code>@final class func</code>, 以及 <code>@final subscript</code>）</p>


<p>如果你重写了<code>final</code>方法，属性或附属脚本，在编译时会报错。在扩展中，你添加到类里的方法，属性或附属脚本也可以在扩展的定义里标记为 final。</p>


<p>你可以通过在关键字<code>class</code>前添加<code>@final</code>特性（<code>@final class</code>）来将整个类标记为 final 的，这样的类是不可被继承的，否则会报编译错误。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift类型检查]]></title>
    <link href="http://ba-xiang.com//blog/Swift%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://ba-xiang.com//blog/Swift类型检查</id>
    <content type="html"><![CDATA[<p>  <em>类型检查</em>是一种检查类实例的方式，并且或者也是让实例作为它的父类或者子类的一种方式。</p>


<p>  类型检查在 Swift 中使用<code>is</code> 和 <code>as</code>操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p>


<!-- more -->


<p>  你也可以用来检查一个类是否实现了某个协议，就像在 <a href="Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_363">Protocols Checking for Protocol Conformance</a>部分讲述的一样。</p>


<p><a name="defining_a_class_hierarchy_for_type_casting"></a></p>


<h2 id="-">定义一个类层次作为例子</h2>


<p>  你可以将它用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。这下面的三个代码段定义了一个类层次和一个包含了几个这些类实例的数组，作为类型检查的例子。</p>


<p>  第一个代码片段定义了一个新的基础类<code>MediaItem</code>。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 <code>String</code> 类型的 <code>name</code> 属性，和一个<code>init name</code>初始化器。（它假定所有的媒体项都有个名称。）</p>


<pre><code>class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}
</code></pre>


<p>  下一个代码段定义了 <code>MediaItem</code> 的两个子类。第一个子类<code>Movie</code>，在父类（或者说基类）的基础上增加了一个 <code>director</code>（导演） 属性，和相应的初始化器。第二个类在父类的基础上增加了一个 <code>artist</code>（艺术家） 属性，和相应的初始化器：</p>


<pre><code>class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}
</code></pre>


<p>  最后一个代码段创建了一个数组常量 <code>library</code>
  ，包含两个<code>Movie</code>实例和三个<code>Song</code>实例。<code>library</code>的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够演绎出<code>Movie</code> 和 <code>Song</code> 有共同的父类 <code>MediaItem</code> ，所以它推断出 <code>MediaItem[]</code> 类作为 <code>library</code> 的类型。</p>


<pre><code>let library = [
Movie(name: "Casablanca", director: "Michael Curtiz"),
Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
Movie(name: "Citizen Kane", director: "Orson Welles"),
Song(name: "The One And Only", artist: "Chesney Hawkes"),
Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
]
// the type of "library" is inferred to be MediaItem[]
</code></pre>


<p>  在幕后<code>library</code> 里存储的媒体项依然是 <code>Movie</code> 和 <code>Song</code> 类型的，但是，若你迭代它，取出的实例会是 <code>MediaItem</code> 类型的，而不是 <code>Movie</code> 和 <code>Song</code> 类型的。为了让它们作为它们本来的类型工作，你需要检查它们的类型或者向下转换它们的类型到其它类型，就像下面描述的一样。</p>


<p><a name="checking_type"></a></p>


<h2 id="-">检查类型</h2>


<p>  用类型检查操作符(<code>is</code>)来检查一个实例是否属于特定子类型。类型检查操作符返回 <code>true</code> 若实例属于那个子类型，若不属于返回 <code>false</code> 。</p>


<p>  下面的例子定义了两个变量，<code>movieCount</code> 和 <code>songCount</code>，用来计算数组<code>library</code> 中 <code>Movie</code> 和 <code>Song</code> 类型的实例数量。</p>


<pre><code>var movieCount = 0
var songCount = 0

for item in library {
    if item is Movie {
        ++movieCount
    } else if item is Song {
        ++songCount
    }
}

println("Media library contains \(movieCount) movies and \(songCount) songs")
// prints "Media library contains 2 movies and 3 songs"
</code></pre>


<p>  示例迭代了数组 <code>library</code> 中的所有项。每一次， <code>for</code>-<code>in</code> 循环设置
  <code>item</code> 为数组中的下一个 <code>MediaItem</code>。</p>


<p>  若当前 <code>MediaItem</code> 是一个 <code>Movie</code> 类型的实例， <code>item is Movie</code> 返回
  <code>true</code>，相反返回 <code>false</code>。同样的，<code>item is
  Song</code>检查item是否为<code>Song</code>类型的实例。在循环结束后，<code>movieCount</code> 和 <code>songCount</code>的值就是被找到属于各自的类型的实例数量。</p>


<p><a name="downcasting"></a></p>


<h2 id="-downcasting-">向下转型（Downcasting）</h2>


<p>  某类型的一个常量或变量可能在幕后实际上属于一个子类。你可以相信，上面就是这种情况。你可以尝试向下转到它的子类型，用类型检查操作符(<code>as</code>)</p>


<p>  因为向下转型可能会失败，类型检查操作符带有两种不同形式。可选形式（ optional form） <code>as?</code> 返回一个你试图下转成的类型的可选值（optional value）。强制形式 <code>as</code> 把试图向下转型和强制解包（force-unwraps）结果作为一个混合动作。</p>


<p>  当你不确定下转可以成功时，用类型检查的可选形式(<code>as?</code>)。可选形式的类型检查总是返回一个可选值（optional value），并且若下转是不可能的，可选值将是 <code>nil</code> 。这使你能够检查下转是否成功。</p>


<p>  只有你可以确定下转一定会成功时，才使用强制形式。当你试图下转为一个不正确的类型时，强制形式的类型检查会触发一个运行时错误。</p>


<p>  下面的例子，迭代了<code>library</code>里的每一个 <code>MediaItem</code> ，并打印出适当的描述。要这样做，<code>item</code>需要真正作为<code>Movie</code> 或 <code>Song</code>的类型来使用。不仅仅是作为 <code>MediaItem</code>。为了能够使用<code>Movie</code> 或 <code>Song</code>的 <code>director</code> 或 <code>artist</code>属性，这是必要的。</p>


<p>  在这个示例中，数组中的每一个<code>item</code>可能是 <code>Movie</code> 或 <code>Song</code>。   事前你不知道每个<code>item</code>的真实类型，所以这里使用可选形式的类型检查 （<code>as?</code>）去检查循环里的每次下转。</p>


<pre><code>for item in library {
    if let movie = item as? Movie {
        println("Movie: '\(movie.name)', dir. \(movie.director)")
    } else if let song = item as? Song {
        println("Song: '\(song.name)', by \(song.artist)")
    }
}

// Movie: 'Casablanca', dir. Michael Curtiz
// Song: 'Blue Suede Shoes', by Elvis Presley
// Movie: 'Citizen Kane', dir. Orson Welles
// Song: 'The One And Only', by Chesney Hawkes
// Song: 'Never Gonna Give You Up', by Rick Astley
</code></pre>


<p>  示例首先试图将 <code>item</code> 下转为 <code>Movie</code>。因为 <code>item</code> 是一个 <code>MediaItem</code>
  类型的实例，它可能是一个<code>Movie</code>；同样，它可能是一个 <code>Song</code>，或者仅仅是基类
  <code>MediaItem</code>。因为不确定，<code>as?</code>形式在试图下转时将返还一个可选值。 <code>item as Movie</code> 的返回值是<code>Movie?</code>类型或 “optional <code>Movie</code>”。</p>


<p>  当下转为 <code>Movie</code> 应用在两个 <code>Song</code>
  实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 <code>Movie</code>真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“<code>if let movie = item as? Movie</code>”，可以这样解读：</p>


<p>  “尝试将 <code>item</code> 转为 <code>Movie</code>类型。若成功，设置一个新的临时常量 <code>movie</code>  来存储返回的可选<code>Movie</code>”</p>


<p>  若下转成功，然后<code>movie</code>的属性将用于打印一个<code>Movie</code>实例的描述，包括它的导演的名字<code>director</code>。当<code>Song</code>被找到时，一个相近的原理被用来检测 <code>Song</code> 实例和打印它的描述。</p>


<blockquote>
<p>注意：</p>
<p>转换没有真的改变实例或它的值。潜在的根本的实例保持不变；只是简单地把它作为它被转换成的类来使用。</p>
</blockquote>


<p><a name="type_casting_for_any_and_anyobject"></a></p>


<h2 id="-any-anyobject-"><code>Any</code>和<code>AnyObject</code>的类型检查</h2>


<p>  Swift为不确定类型提供了两种特殊类型别名：</p>


<ul>
<li><p><code>AnyObject</code>可以代表任何class类型的实例。</p>
</li>
<li><p><code>Any</code>可以表示任何类型，除了方法类型（function types）。</p>
</li>
</ul>


<blockquote>
<p>注意：</p>
<p>只有当你明确的需要它的行为和功能时才使用<code>Any</code>和<code>AnyObject</code>。在你的代码里使用你期望的明确的类型总是更好的。</p>
</blockquote>


<h3 id="-anyobject-"><code>AnyObject</code>类型</h3>


<p>  当需要在工作中使用 Cocoa
  APIs，它一般接收一个<code>AnyObject[]</code>类型的数组，或者说“一个任何对象类型的数组”。这是因为 Objective-C 没有明确的类型化数组。但是，你常常可以确定包含在仅从你知道的 API 信息提供的这样一个数组中的对象的类型。</p>


<p>  在这些情况下，你可以使用强制形式的类型检查(<code>as</code>)来下转在数组中的每一项到比 <code>AnyObject</code> 更明确的类型，不需要可选解析（optional unwrapping）。</p>


<p>  下面的示例定义了一个 <code>AnyObject[]</code> 类型的数组并填入三个<code>Movie</code>类型的实例：</p>


<pre><code>let someObjects: AnyObject[] = [
    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
    Movie(name: "Moon", director: "Duncan Jones"),
    Movie(name: "Alien", director: "Ridley Scott")
]
</code></pre>


<p>  因为知道这个数组只包含 <code>Movie</code> 实例，你可以直接用(<code>as</code>)下转并解包到不可选的<code>Movie</code>类型（ps：其实就是我们常用的正常类型，这里是为了和可选类型相对比）。</p>


<pre><code>for object in someObjects {
    let movie = object as Movie
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</code></pre>


<p>  为了变为一个更短的形式，下转<code>someObjects</code>数组为<code>Movie[]</code>类型来代替下转每一项方式。</p>


<pre><code>for movie in someObjects as Movie[] {
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</code></pre>


<h3 id="-any-"><code>Any</code>类型</h3>


<p>  这里有个示例，使用 <code>Any</code> 类型来和混合的不同类型一起工作，包括非<code>class</code>类型。它创建了一个可以存储<code>Any</code>类型的数组 <code>things</code>。</p>


<pre><code>var things = Any[]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))
</code></pre>


<p>  <code>things</code> 数组包含两个 <code>Int</code> 值，2个 <code>Double</code> 值，1个 <code>String</code> 值，一个元组 <code>(Double, Double)</code> ，Ivan Reitman 导演的电影“Ghostbusters”。</p>


<p>  你可以在 <code>switch</code> <code>cases</code>里用<code>is</code> 和 <code>as</code> 操作符来发觉只知道是 <code>Any</code> 或 <code>AnyObject</code>的常量或变量的类型。 下面的示例迭代 <code>things</code>数组中的每一项的并用<code>switch</code>语句查找每一项的类型。这几种<code>switch</code>语句的情形绑定它们匹配的值到一个规定类型的常量，让它们可以打印它们的值：</p>


<pre><code>for thing in things {
    switch thing {
    case 0 as Int:
        println("zero as an Int")
    case 0 as Double:
        println("zero as a Double")
    case let someInt as Int:
        println("an integer value of \(someInt)")
    case let someDouble as Double where someDouble &gt; 0:
        println("a positive double value of \(someDouble)")
    case is Double:
        println("some other double value that I don't want to print")
    case let someString as String:
        println("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        println("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        println("a movie called '\(movie.name)', dir. \(movie.director)")
    default:
        println("something else")
    }
}

// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of "hello"
// an (x, y) point at 3.0, 5.0
// a movie called 'Ghostbusters', dir. Ivan Reitman
</code></pre>


<p>。</p>


<blockquote>
<p>注意：</p>
<p>在一个switch语句的case中使用强制形式的类型检查操作符（as, 而不是 as?）来检查和转换到一个明确的类型。在 switch case 语句的内容中这种检查总是安全的。</p>
</blockquote>

]]></content>
  </entry>
  
</feed>
