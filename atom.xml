<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[小巴童鞋]]></title>
  <link href="http://baxiang123.com//atom.xml" rel="self"/>
  <link href="http://baxiang123.com//"/>
  <updated>2015-03-15T02:35:28+08:00</updated>
  <id>http://baxiang123.com//</id>
  <author>
    <name><![CDATA[小巴]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[swift泛型]]></title>
    <link href="http://baxiang123.com//blog/Swif%E6%B3%9B%E5%9E%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swif泛型</id>
    <content type="html"><![CDATA[<p><em>泛型代码</em>可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>


<p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个<code>Int</code>数组，也可创建一个<code>String</code>数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。</p>


<!-- more -->


<p><a name="the_problem_that_generics_solve"></a></p>


<h2 id="-">泛型所解决的问题</h2>


<p>这里是一个标准的，非泛型函数<code>swapTwoInts</code>,用来交换两个Int值：</p>


<pre><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="n">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></pre>


<p>这个函数使用写入读出（in-out）参数来交换<code>a</code>和<code>b</code>的值，请参考[写入读出参数][1]。</p>


<p><code>swapTwoInts</code>函数可以交换<code>b</code>的原始值到<code>a</code>，也可以交换a的原始值到<code>b</code>，你可以调用这个函数交换两个<code>Int</code>变量值：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;someInt, &amp;anotherInt)
println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 输出 "someInt is now 107, and anotherInt is now 3"
</code></pre>


<p><code>swapTwoInts</code>函数是非常有用的，但是它只能交换<code>Int</code>值，如果你想要交换两个<code>String</code>或者<code>Double</code>，就不得不写更多的函数，如 <code>swapTwoStrings</code>和<code>swapTwoDoublesfunctions</code>，如同如下所示：</p>


<pre><code>func swapTwoStrings(inout a: String, inout b: String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(inout a: Double, inout b: Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p>你可能注意到 <code>swapTwoInts</code>、 <code>swapTwoStrings</code>和<code>swapTwoDoubles</code>函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是<code>Int</code>、<code>String</code>和<code>Double</code>。</p>


<p>但实际应用中通常需要一个用处更强大并且尽可能的考虑到更多的灵活性单个函数，可以用来交换两个任何类型值，很幸运的是，泛型代码帮你解决了这种问题。（一个这种泛型函数后面已经定义好了。）</p>


<blockquote>
<p>注意：
在所有三个函数中，<code>a</code>和<code>b</code>的类型是一样的。如果<code>a</code>和<code>b</code>不是相同的类型，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个<code>String</code>类型的变量和一个<code>Double</code>类型的变量互相交换值。如果一定要做，Swift 将报编译错误。</p>
</blockquote>


<p><a name="generic_functions"></a></p>


<h2 id="-">泛型函数</h2>


<p><code>泛型函数</code>可以工作于任何类型，这里是一个上面<code>swapTwoInts</code>函数的泛型版本，用于交换两个值：</p>


<pre><code>func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</code></pre>


<p><code>swapTwoValues</code>函数主体和<code>swapTwoInts</code>函数是一样的，它只在第一行稍微有那么一点点不同于<code>swapTwoInts</code>，如下所示：</p>


<pre><code>func swapTwoInts(inout a: Int, inout b: Int)
func swapTwoValues&lt;T&gt;(inout a: T, inout b: T)
</code></pre>


<p>这个函数的泛型版本使用了占位类型名字（通常此情况下用字母<code>T</code>来表示）来代替实际类型名（如<code>In</code>、<code>String</code>或<code>Doubl</code>）。占位类型名没有提示<code>T</code>必须是什么类型，但是它提示了<code>a</code>和<code>b</code>必须是同一类型<code>T</code>，而不管<code>T</code>表示什么类型。只有<code>swapTwoValues</code>函数在每次调用时所传入的实际类型才能决定<code>T</code>所代表的类型。</p>


<p>另外一个不同之处在于这个泛型函数名后面跟着的展位类型名字（T）是用尖括号括起来的（<t>）。这个尖括号告诉 Swift 那个<code>T</code>是<code>swapTwoValues</code>函数所定义的一个类型。因为<code>T</code>是一个占位命名类型，Swift 不会去查找命名为T的实际类型。</t></p>


<p><code>swapTwoValues</code>函数除了要求传入的两个任何类型值是同一类型外，也可以作为<code>swapTwoInts</code>函数被调用。每次<code>swapTwoValues</code>被调用，T所代表的类型值都会传给函数。</p>


<p>在下面的两个例子中,<code>T</code>分别代表<code>Int</code>和<code>String</code>：</p>


<pre><code>var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;someInt, &amp;anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&amp;someString, &amp;anotherString)
// someString is now "world", and anotherString is now "hello"
</code></pre>


<blockquote>
<p>注意
上面定义的函数<code>swapTwoValues</code>是受<code>swap</code>函数启发而实现的。<code>swap</code>函数存在于 Swift 标准库，并可以在其它类中任意使用。如果你在自己代码中需要类似<code>swapTwoValues</code>函数的功能，你可以使用已存在的交换函数<code>swap</code>函数。</p>
</blockquote>


<p><a name="type_parameters"></a></p>


<h2 id="-">类型参数</h2>


<p>在上面的<code>swapTwoValues</code>例子中，占位类型<code>T</code>是一种类型参数的示例。类型参数指定并命名为一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（如<t>）。</t></p>


<p>一旦一个类型参数被指定，那么其可以被使用来定义一个函数的参数类型（如<code>swapTwoValues</code>函数中的参数<code>a</code>和<code>b</code>），或作为一个函数返回类型，或用作函数主体中的注释类型。在这种情况下，被类型参数所代表的占位类型不管函数任何时候被调用，都会被实际类型所替换（在上面<code>swapTwoValues</code>例子中，当函数第一次被调用时，<code>T</code>被<code>Int</code>替换，第二次调用时，被<code>String</code>替换。）。</p>


<p>你可支持多个类型参数，命名在尖括号中，用逗号分开。</p>


<p><a name="naming_type_parameters"></a></p>


<h2 id="-">命名类型参数</h2>


<p>在简单的情况下，泛型函数或泛型类型需要指定一个占位类型（如上面的<code>swapTwoValues</code>泛型函数，或一个存储单一类型的泛型集，如数组），通常用一单个字母<code>T</code>来命名类型参数。不过，你可以使用任何有效的标识符来作为类型参数名。</p>


<p>如果你使用多个参数定义更复杂的泛型函数或泛型类型，那么使用更多的描述类型参数是非常有用的。例如，Swift 字典（Dictionary）类型有两个类型参数，一个是键，另外一个是值。如果你自己写字典，你或许会定义这两个类型参数为<code>KeyType</code>和<code>ValueType</code>，用来记住它们在你的泛型代码中的作用。</p>


<blockquote>
<p>注意
请始终使用大写字母开头的驼峰式命名法（例如<code>T</code>和<code>KeyType</code>）来给类型参数命名，以表明它们是类型的占位符，而非类型值。</p>
</blockquote>


<p><a name="generic_types"></a></p>


<h2 id="-">泛型类型</h2>


<p>通常在泛型函数中，Swift 允许你定义你自己的泛型类型。这些自定义类、结构体和枚举作用于任何类型，如同<code>Array</code>和<code>Dictionary</code>的用法。</p>


<p>这部分向你展示如何写一个泛型集类型&#8211;<code>Stack</code>（栈）。一个栈是一系列值域的集合，和<code>Array</code>（数组）类似，但其是一个比 Swift 的<code>Array</code>类型更多限制的集合。一个数组可以允许其里面任何位置的插入/删除操作，而栈，只允许在集合的末端添加新的项（如同<em>push</em>一个新值进栈）。同样的一个栈也只能从末端移除项（如同<em>pop</em>一个值出栈）。</p>


<blockquote>
<p>注意
栈的概念已被<code>UINavigationController</code>类使用来模拟试图控制器的导航结构。你通过调用<code>UINavigationController</code>的<code>pushViewController:animated:</code>方法来为导航栈添加（add）新的试图控制器；而通过<code>popViewControllerAnimated:</code>的方法来从导航栈中移除（pop）某个试图控制器。每当你需要一个严格的<code>后进先出</code>方式来管理集合，堆栈都是最实用的模型。</p>
</blockquote>


<p>下图展示了一个栈的压栈(push)/出栈(pop)的行为：</p>


<p>![此处输入图片的描述][2]</p>


<ol>
<li>现在有三个值在栈中；</li>
<li>第四个值“pushed”到栈的顶部；</li>
<li>现在有四个值在栈中，最近的那个在顶部；</li>
<li>栈中最顶部的那个项被移除，或称之为“popped”；</li>
<li>移除掉一个值后，现在栈又重新只有三个值。</li>
</ol>


<p>这里展示了如何写一个非泛型版本的栈，<code>Int</code>值型的栈：</p>


<pre><code>struct IntStack {
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
}
</code></pre>


<p>这个结构体在栈中使用一个<code>Array</code>性质的<code>items</code>存储值。<code>Stack</code>提供两个方法：<code>push</code>和<code>pop</code>，从栈中压进一个值和移除一个值。这些方法标记为可变的，因为他们需要修改（或<em>转换</em>）结构体的<code>items</code>数组。</p>


<p>上面所展现的<code>IntStack</code>类型只能用于<code>Int</code>值，不过，其对于定义一个泛型<code>Stack</code>类（可以处理<em>任何</em>类型值的栈）是非常有用的。</p>


<p>这里是一个相同代码的泛型版本：</p>


<pre><code>struct Stack&lt;T&gt; {
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
}
</code></pre>


<p>注意到<code>Stack</code>的泛型版本基本上和非泛型版本相同，但是泛型版本的占位类型参数为T代替了实际<code>Int</code>类型。这种类型参数包含在一对尖括号里（<code>&lt;T&gt;</code>），紧随在结构体名字后面。</p>


<p><code>T</code>定义了一个名为“某种类型T”的节点提供给后来用。这种将来类型可以在结构体的定义里任何地方表示为“T”。在这种情况下，<code>T</code>在如下三个地方被用作节点：</p>


<ul>
<li>创建一个名为<code>items</code>的属性，使用空的T类型值数组对其进行初始化；</li>
<li>指定一个包含一个参数名为<code>item</code>的<code>push</code>方法，该参数必须是T类型；</li>
<li>指定一个<code>pop</code>方法的返回值，该返回值将是一个T类型值。</li>
</ul>


<p>当创建一个新单例并初始化时， 通过用一对紧随在类型名后的尖括号里写出实际指定栈用到类型，创建一个<code>Stack</code>实例，同创建<code>Array</code>和<code>Dictionary</code>一样：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 现在栈已经有4个string了
</code></pre>


<p>下图将展示<code>stackOfStrings</code>如何<code>push</code>这四个值进栈的过程：</p>


<p>![此处输入图片的描述][3]</p>


<p>从栈中<code>pop</code>并移除值&#8221;cuatro&#8221;：</p>


<pre><code>let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to "cuatro", and the stack now contains 3 strings
</code></pre>


<p>下图展示了如何从栈中pop一个值的过程：
![此处输入图片的描述][4]</p>


<p>由于<code>Stack</code>是泛型类型，所以在 Swift 中其可以用来创建任何有效类型的栈，这种方式如同<code>Array</code>和<code>Dictionary</code>。</p>


<p><a name="type_constraints"></a></p>


<h2 id="-">类型约束</h2>


<p><code>swapTwoValues</code>函数和<code>Stack</code>类型可以作用于任何类型，不过，有的时候对使用在泛型函数和泛型类型上的类型强制约束为某种特定类型是非常有用的。类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成。</p>


<p>例如，Swift 的<code>Dictionary</code>类型对作用于其键的类型做了些限制。在[字典][5]的描述中，字典的键类型必须是<em>可哈希</em>，也就是说，必须有一种方法可以使其是唯一的表示。<code>Dictionary</code>之所以需要其键是可哈希是为了以便于其检查其是否包含某个特定键的值。如无此需求，<code>Dictionary</code>即不会告诉是否插入或者替换了某个特定键的值，也不能查找到已经存储在字典里面的给定键值。</p>


<p>这个需求强制加上一个类型约束作用于<code>Dictionary</code>的键上，当然其键类型必须遵循<code>Hashable</code>协议（Swift 标准库中定义的一个特定协议）。所有的 Swift 基本类型（如<code>String</code>，<code>Int</code>， <code>Double</code>和 <code>Bool</code>）默认都是可哈希。</p>


<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，当然，这些约束要支持泛型编程的强力特征中的多数。抽象概念如<code>可哈希</code>具有的类型特征是根据他们概念特征来界定的，而不是他们的直接类型特征。</p>


<h3 id="-">类型约束语法</h3>


<p>你可以写一个在一个类型参数名后面的类型约束，通过冒号分割，来作为类型参数链的一部分。这种作用于泛型函数的类型约束的基础语法如下所示（和泛型类型的语法相同）：</p>


<pre><code>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // function body goes here
}
</code></pre>


<p>上面这个假定函数有两个类型参数。第一个类型参数<code>T</code>，有一个需要<code>T</code>必须是<code>SomeClass</code>子类的类型约束；第二个类型参数<code>U</code>，有一个需要<code>U</code>必须遵循<code>SomeProtocol</code>协议的类型约束。</p>


<h3 id="-">类型约束行为</h3>


<p>这里有个名为<code>findStringIndex</code>的非泛型函数，该函数功能是去查找包含一给定<code>String</code>值的数组。若查找到匹配的字符串，<code>findStringIndex</code>函数返回该字符串在数组中的索引值（<code>Int</code>），反之则返回<code>nil</code>：</p>


<pre><code>func findStringIndex(array: String[], valueToFind: String) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findStringIndex</code>函数可以作用于查找一字符串数组中的某个字符串:</p>


<pre><code>let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findStringIndex(strings, "llama") {
    println("The index of llama is \(foundIndex)")
}
// 输出 "The index of llama is 2"
</code></pre>


<p>如果只是针对字符串而言查找在数组中的某个值的索引，用处不是很大，不过，你可以写出相同功能的泛型函数<code>findIndex</code>，用某个类型<code>T</code>值替换掉提到的字符串。</p>


<p>这里展示如何写一个你或许期望的<code>findStringIndex</code>的泛型版本<code>findIndex</code>。请注意这个函数仍然返回<code>Int</code>，是不是有点迷惑呢，而不是泛型类型?那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数不会编译，原因在例子后面会说明：</p>


<pre><code>func findIndex&lt;T&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p>上面所写的函数不会编译。这个问题的位置在等式的检查上，<code>“if value == valueToFind”</code>。不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。正因如此，这部分代码不能可能保证工作于每个可能的类型<code>T</code>，当你试图编译这部分代码时估计会出现相应的错误。</p>


<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个<code>Equatable</code>协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持<code>Equatable</code>协议。</p>


<p>任何<code>Equatable</code>类型都可以安全的使用在<code>findIndex</code>函数中，因为其保证支持等式操作。为了说明这个事实，当你定义一个函数时，你可以写一个<code>Equatable</code>类型约束作为类型参数定义的一部分：</p>


<pre><code>func findIndex&lt;T: Equatable&gt;(array: T[], valueToFind: T) -&gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</code></pre>


<p><code>findIndex</code>中这个单个类型参数写做：<code>T: Equatable</code>，也就意味着“任何T类型都遵循<code>Equatable</code>协议”。</p>


<p><code>findIndex</code>函数现在则可以成功的编译过，并且作用于任何遵循<code>Equatable</code>的类型，如<code>Double</code>或<code>String</code>:</p>


<pre><code>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
// stringIndex is an optional Int containing a value of 2
</code></pre>


<p><a name="associated_types"></a></p>


<h2 id="-">关联类型</h2>


<p>当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名（或<em>别名</em>）。作用于关联类型上实际类型是不需要指定的，直到该协议接受。关联类型被指定为<code>typealias</code>关键字。</p>


<h3 id="-">关联类型行为</h3>


<p>这里是一个<code>Container</code>协议的例子，定义了一个ItemType关联类型：</p>


<pre><code>protocol Container {
    typealias ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&gt; ItemType { get }
}
</code></pre>


<p><code>Container</code>协议定义了三个任何容器必须支持的兼容要求：</p>


<ul>
<li>必须可能通过<code>append</code>方法添加一个新item到容器里；</li>
<li>必须可能通过使用<code>count</code>属性获取容器里items的数量，并返回一个<code>Int</code>值；</li>
<li>必须可能通过容器的<code>Int</code>索引值下标可以检索到每一个item。</li>
</ul>


<p>这个协议没有指定容器里item是如何存储的或何种类型是允许的。这个协议只指定三个任何遵循<code>Container</code>类型所必须支持的功能点。一个遵循的类型也可以提供其他额外的功能，只要满足这三个条件。</p>


<p>任何遵循<code>Container</code>协议的类型必须指定存储在其里面的值类型，必须保证只有正确类型的items可以加进容器里，必须明确可以通过其下标返回item类型。</p>


<p>为了定义这三个条件，<code>Container</code>协议需要一个方法指定容器里的元素将会保留，而不需要知道特定容器的类型。<code>Container</code>协议需要指定任何通过<code>append</code>方法添加到容器里的值和容器里元素是相同类型，并且通过容器下标返回的容器元素类型的值的类型是相同类型。</p>


<p>为了达到此目的，<code>Container</code>协议声明了一个ItemType的关联类型，写作<code>typealias ItemType</code>。The protocol does not define what ItemType is an alias for—that information is left for any conforming type to provide（这个协议不会定义<code>ItemType</code>是遵循类型所提供的何种信息的别名）。尽管如此，<code>ItemType</code>别名支持一种方法识别在一个容器里的items类型，以及定义一种使用在<code>append</code>方法和下标中的类型，以便保证任何期望的<code>Container</code>的行为是强制性的。</p>


<p>这里是一个早前IntStack类型的非泛型版本，适用于遵循Container协议：</p>


<pre><code>struct IntStack: Container {
    // original IntStack implementation
    var items = Int[]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&gt; Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; Int {
        return items[i]
    }
}
</code></pre>


<p><code>IntStack</code>类型实现了<code>Container</code>协议的所有三个要求，在<code>IntStack</code>类型的每个包含部分的功能都满足这些要求。</p>


<p>此外，<code>IntStack</code>指定了<code>Container</code>的实现，适用的ItemType被用作<code>Int</code>类型。对于这个<code>Container</code>协议实现而言，定义 <code>typealias ItemType = Int</code>，将抽象的<code>ItemType</code>类型转换为具体的<code>Int</code>类型。</p>


<p>感谢Swift类型参考，你不用在<code>IntStack</code>定义部分声明一个具体的<code>Int</code>的<code>ItemType</code>。由于<code>IntStack</code>遵循<code>Container</code>协议的所有要求，只要通过简单的查找<code>append</code>方法的item参数类型和下标返回的类型，Swift就可以推断出合适的<code>ItemType</code>来使用。确实，如果上面的代码中你删除了 <code>typealias ItemType = Int</code>这一行，一切仍旧可以工作，因为它清楚的知道ItemType使用的是何种类型。</p>


<p>你也可以生成遵循<code>Container</code>协议的泛型<code>Stack</code>类型：</p>


<pre><code>struct Stack&lt;T&gt;: Container {
    // original Stack&lt;T&gt; implementation
    var items = T[]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&gt; T {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(item: T) {
        self.push(item)
    }
    var count: Int {
    return items.count
    }
    subscript(i: Int) -&gt; T {
        return items[i]
    }
}
</code></pre>


<p>这个时候，占位类型参数<code>T</code>被用作<code>append</code>方法的item参数和下标的返回类型。Swift 因此可以推断出被用作这个特定容器的<code>ItemType</code>的<code>T</code>的合适类型。</p>


<h3 id="-">扩展一个存在的类型为一指定关联类型</h3>


<p>在[使用扩展来添加协议兼容性][6]中有描述扩展一个存在的类型添加遵循一个协议。这个类型包含一个关联类型的协议。</p>


<p>Swift的<code>Array</code>已经提供<code>append</code>方法，一个<code>count</code>属性和通过下标来查找一个自己的元素。这三个功能都达到<code>Container</code>协议的要求。也就意味着你可以扩展<code>Array</code>去遵循<code>Container</code>协议，只要通过简单声明<code>Array</code>适用于该协议而已。如何实践这样一个空扩展，在[使用扩展来声明协议的采纳][7]中有描述这样一个实现一个空扩展的行为：</p>


<pre><code>extension Array: Container {}
</code></pre>


<p>如同上面的泛型<code>Stack</code>类型一样，<code>Array的append</code>方法和下标保证<code>Swift</code>可以推断出<code>ItemType</code>所使用的适用的类型。定义了这个扩展后，你可以将任何<code>Array</code>当作<code>Container</code>来使用。</p>


<p><a name="where_clauses"></a></p>


<h2 id="where-">Where 语句</h2>


<p>[类型约束][8]中描述的类型约束确保你定义关于类型参数的需求和一泛型函数或类型有关联。</p>


<p>对于关联类型的定义需求也是非常有用的。你可以通过这样去定义<em>where语句</em>作为一个类型参数队列的一部分。一个<code>where</code>语句使你能够要求一个关联类型遵循一个特定的协议，以及（或）那个特定的类型参数和关联类型可以是相同的。你可写一个<code>where</code>语句，通过紧随放置<code>where</code>关键字在类型参数队列后面，其后跟着一个或者多个针对关联类型的约束，以及（或）一个或多个类型和关联类型的等于关系。</p>


<p>下面的列子定义了一个名为<code>allItemsMatch</code>的泛型函数，用来检查是否两个<code>Container</code>单例包含具有相同顺序的相同元素。如果匹配到所有的元素，那么返回一个为<code>true</code>的<code>Boolean</code>值，反之，则相反。</p>


<p>这两个容器可以被检查出是否是相同类型的容器（虽然它们可以是），但他们确实拥有相同类型的元素。这个需求通过一个类型约束和<code>where</code>语句结合来表示：</p>


<pre><code>func allItemsMatch&lt;
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;
    (someContainer: C1, anotherContainer: C2) -&gt; Bool {

        // check that both containers contain the same number of items
        if someContainer.count != anotherContainer.count {
            return false
        }

        // check each pair of items to see if they are equivalent
        for i in 0..someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }

        // all items match, so return true
        return true

}
</code></pre>


<p>这个函数用了两个参数：<code>someContainer</code>和<code>anotherContainer</code>。<code>someContainer</code>参数是类型<code>C1</code>，<code>anotherContainer</code>参数是类型<code>C2</code>。<code>C1</code>和<code>C2</code>是容器的两个占位类型参数，决定了这个函数何时被调用。</p>


<p>这个函数的类型参数列紧随在两个类型参数需求的后面：</p>


<ul>
<li><code>C1</code>必须遵循<code>Container</code>协议 (写作 <code>C1: Container</code>)。</li>
<li><code>C2</code>必须遵循<code>Container</code>协议 (写作 <code>C2: Container</code>)。</li>
<li><code>C1</code>的<code>ItemType</code>同样是C2的<code>ItemType</code>（写作 <code>C1.ItemType == C2.ItemType</code>）。</li>
<li><code>C1</code>的<code>ItemType</code>必须遵循<code>Equatable</code>协议 (写作 <code>C1.ItemType: Equatable</code>)。</li>
</ul>


<p>第三个和第四个要求被定义为一个<code>where</code>语句的一部分，写在关键字<code>where</code>后面，作为函数类型参数链的一部分。</p>


<p>这些要求意思是：</p>


<p><code>someContainer</code>是一个<code>C1</code>类型的容器。
<code>anotherContainer</code>是一个<code>C2</code>类型的容器。
<code>someContainer</code>和<code>anotherContainer</code>包含相同的元素类型。
<code>someContainer</code>中的元素可以通过不等于操作(<code>!=</code>)来检查它们是否彼此不同。</p>


<p>第三个和第四个要求结合起来的意思是<code>anotherContainer</code>中的元素也可以通过 <code>!=</code> 操作来检查，因为他们在<code>someContainer</code>中元素确实是相同的类型。</p>


<p>这些要求能够使<code>allItemsMatch</code>函数比较两个容器，即便他们是不同的容器类型。</p>


<p><code>allItemsMatch</code>首先检查两个容器是否拥有同样数目的items，如果他们的元素数目不同，没有办法进行匹配，函数就会<code>false</code>。</p>


<p>检查完之后，函数通过<code>for-in</code>循环和半闭区间操作（..）来迭代<code>someContainer</code>中的所有元素。对于每个元素，函数检查是否<code>someContainer</code>中的元素不等于对应的<code>anotherContainer</code>中的元素，如果这两个元素不等，则这两个容器不匹配，返回<code>false</code>。</p>


<p>如果循环体结束后未发现没有任何的不匹配，那表明两个容器匹配，函数返回<code>true</code>。</p>


<p>这里演示了allItemsMatch函数运算的过程：</p>


<pre><code>var stackOfStrings = Stack&lt;String&gt;()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    println("All items match.")
} else {
    println("Not all items match.")
}
// 输出 "All items match."
</code></pre>


<p> 上面的例子创建一个<code>Stack</code>单例来存储<code>String</code>，然后压了三个字符串进栈。这个例子也创建了一个<code>Array</code>单例，并初始化包含三个同栈里一样的原始字符串。即便栈和数组否是不同的类型，但他们都遵循<code>Container</code>协议，而且他们都包含同样的类型值。你因此可以调用<code>allItemsMatch</code>函数，用这两个容器作为它的参数。在上面的例子中，<code>allItemsMatch</code>函数正确的显示了所有的这两个容器的<code>items</code>匹配。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift集合类型]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift集合类型</id>
    <content type="html"><![CDATA[<p>Swift 语言提供经典的数组和字典两种集合类型来存储集合数据。数组用来按顺序存储相同类型的数据。字典虽然无序存储相同类型数据值但是需要由独有的标识符引用和寻址（就是键值对）。</p>


<p>Swift 语言里的数组和字典中存储的数据值类型必须明确。 这意味着我们不能把不正确的数据类型插入其中。 同时这也说明我们完全可以对获取出的值类型非常自信。 Swift 对显式类型集合的使用确保了我们的代码对工作所需要的类型非常清楚，也让我们在开发中可以早早地找到任何的类型不匹配错误。</p>


<!-- more -->


<blockquote>
<p>注意：</p>
<p>Swift 的数组结构在被声明成常量和变量或者被传入函数与方法中时会相对于其他类型展现出不同的特性。 获取更多信息请参见<a href="#mutability_of_collections">集合的可变性</a>与<a href="09_Classes_and_Structures.html#assignment_and_copy_behavior_for_collection_types">集合在赋值和复制中的行为</a>章节。</p>
</blockquote>


<p><a name="arrays"></a></p>


<h2 id="-">数组</h2>


<p>数组使用有序列表存储相同类型的多重数据。相同的值可以多次出现在一个数组的不同位置中。</p>


<p>Swift 数组对存储数据有具体要求。 不同于 Objective-C 的<code>NSArray</code>和<code>NSMutableArray</code>类，他们可以存储任何类型的实例而且不提供他们返回对象的任何本质信息。 在 Swift 中，数据值在被存储进入某个数组之前类型必须明确，方法是通过显式的类型标注或类型推断，而且不是必须是<code>class</code>类型。例如： 如果我们创建了一个<code>Int</code>值类型的数组，我们不能往其中插入任何不是<code>Int</code>类型的数据。 Swift 中的数组是类型安全的，并且它们中包含的类型必须明确。</p>


<p><a name="array_type_shorthand_syntax"></a></p>


<h3 id="-">数组的简单语法</h3>


<p>写 Swift 数组应该遵循像<code>Array&lt;SomeType&gt;</code>这样的形式，其中<code>SomeType</code>是这个数组中唯一允许存在的数据类型。 我们也可以使用像<code>SomeType[]</code>这样的简单语法。 尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</p>


<p><a name="array_literals"></a></p>


<h3 id="-">数组构造语句</h3>


<p>我们可以使用字面语句来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。字面语句是一系列由逗号分割并由方括号包含的数值。
<code>[value 1, value 2, value 3]</code>。</p>


<p>下面这个例子创建了一个叫做<code>shoppingList</code>并且存储字符串的数组：</p>


<pre><code>var shoppingList: String[] = ["Eggs", "Milk"]
// shoppingList 已经被构造并且拥有两个初始项。
</code></pre>


<p><code>shoppingList</code>变量被声明为“字符串值类型的数组“，记作<code>String[]</code>。 因为这个数组被规定只有<code>String</code>一种数据结构，所以只有<code>String</code>类型可以在其中被存取。 在这里，<code>shoppinglist</code>数组由两个<code>String</code>值（<code>"Eggs"</code> 和<code>"Milk"</code>）构造，并且由字面语句定义。</p>


<blockquote>
<p>注意：</p>
<p><code>Shoppinglist</code>数组被声明为变量（<code>var</code>关键字创建）而不是常量（<code>let</code>创建）是因为以后可能会有更多的数据项被插入其中。</p>
</blockquote>


<p>在这个例子中，字面语句仅仅包含两个<code>String</code>值。匹配了该数组的变量声明（只能包含<code>String</code>的数组），所以这个字面语句的分配过程就是允许用两个初始项来构造<code>shoppinglist</code>。</p>


<p>由于 Swift 的类型推断机制，当我们用字面语句构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。 <code>shoppinglist</code>的构造也可以这样写：</p>


<pre><code>var shoppingList = ["Eggs", "Milk"]
</code></pre>


<p>因为所有字面语句中的值都是相同的类型，Swift 可以推断出<code>String[]</code>是<code>shoppinglist</code>中变量的正确类型。</p>


<p><a name="accessing_and_modifying_an_array"></a></p>


<h3 id="-">访问和修改数组</h3>


<p>我们可以通过数组的方法和属性来访问和修改数组，或者下标语法。
还可以使用数组的只读属性<code>count</code>来获取数组中的数据项数量。</p>


<pre><code>println("The shopping list contains \(shoppingList.count) items.")
// 输出"The shopping list contains 2 items."（这个数组有2个项）
</code></pre>


<p>使用布尔项<code>isEmpty</code>来作为检查<code>count</code>属性的值是否为 0 的捷径。</p>


<pre><code>if shoppingList.isEmpty {
    println("The shopping list is empty.")
} else {
    println("The shopping list is not empty.")
}
// 打印 "The shopping list is not empty."（shoppinglist不是空的）
</code></pre>


<p>也可以使用<code>append</code>方法在数组后面添加新的数据项：</p>


<pre><code>shoppingList.append("Flour")
// shoppingList 现在有3个数据项，有人在摊煎饼
</code></pre>


<p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加数据项：</p>


<pre><code>shoppingList += "Baking Powder"
// shoppingList 现在有四项了
</code></pre>


<p>我们也可以使用加法赋值运算符（<code>+=</code>）直接添加拥有相同类型数据的数组。</p>


<pre><code>shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
// shoppingList 现在有7项了
</code></pre>


<p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>


<pre><code>var firstItem = shoppingList[0]
// 第一项是 "Eggs"
</code></pre>


<p>注意第一项在数组中的索引值是<code>0</code>而不是<code>1</code>。 Swift 中的数组索引总是从零开始。</p>


<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>


<pre><code>shoppingList[0] = "Six eggs"
// 其中的第一项现在是 "Six eggs" 而不是 "Eggs"
</code></pre>


<p>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把<code>"Chocolate Spread"</code>，<code>"Cheese"</code>，和<code>"Butter"</code>替换为<code>"Bananas"</code>和 <code>"Apples"</code>：</p>


<pre><code>shoppingList[4...6] = ["Bananas", "Apples"]
// shoppingList 现在有六项
</code></pre>


<blockquote>
<p>注意：</p>
<p>我们不能使用下标语法在数组尾部添加新项。如果我们试着用这种方法对索引越界的数据进行检索或者设置新值的操作，我们会引发一个运行期错误。我们可以使用索引值和数组的<code>count</code>属性进行比较来在使用某个索引之前先检验是否有效。除了当<code>count</code>等于 0 时（说明这是个空数组），最大索引值一直是<code>count - 1</code>，因为数组都是零起索引。</p>
</blockquote>


<p>调用数组的<code>insert(atIndex:)</code>方法来在某个具体索引值之前添加数据项：</p>


<pre><code>shoppingList.insert("Maple Syrup", atIndex: 0)
// shoppingList 现在有7项
// "Maple Syrup" 现在是这个列表中的第一项
</code></pre>


<p>这次<code>insert</code>函数调用把值为<code>"Maple Syrup"</code>的新数据项插入列表的最开始位置，并且使用<code>0</code>作为索引值。</p>


<p>类似的我们可以使用<code>removeAtIndex</code>方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）:</p>


<pre><code>let mapleSyrup = shoppingList.removeAtIndex(0)
//索引值为0的数据项被移除
// shoppingList 现在只有6项，而且不包括Maple Syrup
// mapleSyrup常量的值等于被移除数据项的值 "Maple Syrup"
</code></pre>


<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为<code>0</code>的数据项的值再次等于<code>"Six eggs"</code>:</p>


<pre><code>firstItem = shoppingList[0]
// firstItem 现在等于 "Six eggs"
</code></pre>


<p>如果我们只想把数组中的最后一项移除，可以使用<code>removeLast</code>方法而不是<code>removeAtIndex</code>方法来避免我们需要获取数组的<code>count</code>属性。就像后者一样，前者也会返回被移除的数据项：</p>


<pre><code>let apples = shoppingList.removeLast()
// 数组的最后一项被移除了
// shoppingList现在只有5项，不包括cheese
//  apples 常量的值现在等于"Apples" 字符串
</code></pre>


<p><a name="iterating_over_an_array"></a></p>


<h3 id="-">数组的遍历</h3>


<p>我们可以使用<code>for-in</code>循环来遍历所有数组中的数据项：</p>


<pre><code>for item in shoppingList {
    println(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
</code></pre>


<p>如果我们同时需要每个数据项的值和索引值，可以使用全局<code>enumerate</code>函数来进行数组遍历。<code>enumerate</code>返回一个由每一个数据项索引值和数据值组成的键值对组。我们可以把这个键值对组分解成临时常量或者变量来进行遍历：</p>


<pre><code>for (index, value) in enumerate(shoppingList) {
    println("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
</code></pre>


<p>更多关于<code>for-in</code>循环的介绍请参见<a href="05_Control_Flow.html#for_loops">for 循环</a>。</p>


<p><a name="creating_and_initializing_an_array"></a></p>


<h3 id="-">创建并且构造一个数组</h3>


<p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>


<pre><code>var someInts = Int[]()
println("someInts is of type Int[] with \(someInts。count) items。")
// 打印 "someInts is of type Int[] with 0 items。"（someInts是0数据项的Int[]数组）
</code></pre>


<p>注意<code>someInts</code>被设置为一个<code>Int[]</code>构造函数的输出所以它的变量类型被定义为<code>Int[]</code>。</p>


<p>除此之外，如果代码上下文中提供了类型信息， 例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：<code>[]</code>（一对空方括号）：</p>


<pre><code>someInts.append(3)
// someInts 现在包含一个INT值
someInts = []
// someInts 现在是空数组，但是仍然是Int[]类型的。
</code></pre>


<p>Swift 中的<code>Array</code>类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（<code>count</code>）和适当类型的初始值（<code>repeatedValue</code>）传入数组构造函数：</p>


<pre><code>var threeDoubles = Double[](count: 3, repeatedValue:0.0)
// threeDoubles 是一种 Double[]数组, 等于 [0.0, 0.0, 0.0]
</code></pre>


<p>因为类型推断的存在，我们使用这种构造方法的时候不需要特别指定数组中存储的数据类型，因为类型可以从默认值推断出来：</p>


<pre><code>var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
// anotherThreeDoubles is inferred as Double[], and equals [2.5, 2.5, 2.5]
</code></pre>


<p>最后，我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>


<pre><code>var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles 被推断为 Double[], 等于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
</code></pre>


<p><a name="dictionaries"></a></p>


<h2 id="-">字典</h2>


<p>字典是一种存储相同类型多重数据的存储器。每个值（value）都关联独特的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>


<p>Swift 的字典使用时需要具体规定可以存储键和值类型。不同于 Objective-C 的<code>NSDictionary</code>和<code>NSMutableDictionary</code> 类可以使用任何类型的对象来作键和值并且不提供任何关于这些对象的本质信息。在 Swift 中，在某个特定字典中可以存储的键和值必须提前定义清楚，方法是通过显性类型标注或者类型推断。</p>


<p>Swift 的字典使用<code>Dictionary&lt;KeyType, ValueType&gt;</code>定义,其中<code>KeyType</code>是字典中键的数据类型，<code>ValueType</code>是字典中对应于这些键所存储值的数据类型。</p>


<p><code>KeyType</code>的唯一限制就是可哈希的，这样可以保证它是独一无二的，所有的 Swift 基本类型（例如<code>String</code>，<code>Int</code>， <code>Double</code>和<code>Bool</code>）都是默认可哈希的，并且所有这些类型都可以在字典中当做键使用。未关联值的枚举成员（参见<a href="08_Enumerations.html">枚举</a>）也是默认可哈希的。</p>


<p><a name="dictionary_literals"></a></p>


<h2 id="-">字典字面语句</h2>


<p>我们可以使用字典字面语句来构造字典，他们和我们刚才介绍过的数组字面语句拥有相似语法。一个字典字面语句是一个定义拥有一个或者多个键值对的字典集合的简单语句。</p>


<p>一个键值对是一个<code>key</code>和一个<code>value</code>的结合体。在字典字面语句中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含并且由逗号分割：</p>


<pre><code>[key 1: value 1, key 2: value 2, key 3: value 3]
</code></pre>


<p>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>


<pre><code>var airports: Dictionary&lt;String, String&gt; = ["TYO": "Tokyo", "DUB": "Dublin"]
</code></pre>


<p><code>airports</code>字典被定义为一种<code>Dictionary&lt;String, String&gt;</code>,它意味着这个字典的键和值都是<code>String</code>类型。</p>


<blockquote>
<p>注意：</p>
<p><code>airports</code>字典被声明为变量（用<code>var</code>关键字）而不是常量（<code>let</code>关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
</blockquote>


<p><code>airports</code>字典使用字典字面语句初始化，包含两个键值对。第一对的键是<code>TYO</code>，值是<code>Tokyo</code>。第二对的键是<code>DUB</code>，值是<code>Dublin</code>。</p>


<p>这个字典语句包含了两个<code>String: String</code>类型的键值对。他们对应<code>airports</code>变量声明的类型（一个只有<code>String</code>键和<code>String</code>值的字典）所以这个字典字面语句是构造两个初始数据项的<code>airport</code>字典。</p>


<p>和数组一样，如果我们使用字面语句构造字典就不用把类型定义清楚。<code>airports</code>的也可以用这种方法简短定义：</p>


<pre><code>var airports = ["TYO": "Tokyo", "DUB": "Dublin"]
</code></pre>


<p>因为这个语句中所有的键和值都分别是相同的数据类型，Swift 可以推断出<code>Dictionary&lt;String, String&gt;</code>是<code>airports</code>字典的正确类型。</p>


<p><a name="accessing_and_modifying_a_dictionary"></a></p>


<h3 id="-">读取和修改字典</h3>


<p>我们可以通过字典的方法和属性来读取和修改字典，或者使用下标语法。和数组一样，我们可以通过字典的只读属性<code>count</code>来获取某个字典的数据项数量：</p>


<pre><code>println("The dictionary of airports contains \(airports.count) items.")
// 打印 "The dictionary of airports contains 2 items."（这个字典有两个数据项）
</code></pre>


<p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个合适类型的 key 作为下标索引，并且分配新的合适类型的值：</p>


<pre><code>airports["LHR"] = "London"
// airports 字典现在有三个数据项
</code></pre>


<p>我们也可以使用下标语法来改变特定键对应的值：</p>


<pre><code>airports["LHR"] = "London Heathrow"
// "LHR"对应的值 被改为 "London Heathrow
</code></pre>


<p>作为另一种下标方法，字典的<code>updateValue(forKey:)</code>方法可以设置或者更新特定键对应的值。就像上面所示的示例，<code>updateValue(forKey:)</code>方法在这个键不存在对应值的时候设置值或者在存在时更新已存在的值。和上面的下标方法不一样，这个方法返回更新值之前的原值。这样方便我们检查更新是否成功。</p>


<p><code>updateValue(forKey:)</code>函数会返回包含一个字典值类型的可选值。举例来说：对于存储<code>String</code>值的字典，这个函数会返回一个<code>String?</code>或者“可选 <code>String</code>”类型的值。如果值存在，则这个可选值值等于被替换的值，否则将会是<code>nil</code>。</p>


<pre><code>if let oldValue = airports.updateValue("Dublin Internation", forKey: "DUB") {
    println("The old value for DUB was \(oldValue).")
}
// 输出 "The old value for DUB was Dublin."（dub原值是dublin）
</code></pre>


<p>我们也可以使用下标语法来在字典中检索特定键对应的值。由于使用一个没有值的键这种情况是有可能发生的，可选类型返回这个键存在的相关值，否则就返回<code>nil</code>：</p>


<pre><code>if let airportName = airports["DUB"] {
    println("The name of the airport is \(airportName).")
} else {
    println("That airport is not in the airports dictionary.")
}
// 打印 "The name of the airport is Dublin INTernation."（机场的名字是都柏林国际）
</code></pre>


<p>我们还可以使用下标语法来通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对：</p>


<pre><code>airports["APL"] = "Apple Internation"
// "Apple Internation"不是真的 APL机场, 删除它
airports["APL"] = nil
// APL现在被移除了
</code></pre>


<p>另外，<code>removeValueForKey</code>方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的value或者在没有值的情况下返回<code>nil</code>：</p>


<pre><code>if let removedValue = airports.removeValueForKey("DUB") {
    println("The removed airport's name is \(removedValue).")
} else {
    println("The airports dictionary does not contain a value for DUB.")
}
// prints "The removed airport's name is Dublin International."
</code></pre>


<p><a name="iterating_over_a_dictionary"></a></p>


<h3 id="-">字典遍历</h3>


<p>我们可以使用<code>for-in</code>循环来遍历某个字典中的键值对。每一个字典中的数据项都由<code>(key, value)</code>元组形式返回，并且我们可以使用暂时性常量或者变量来分解这些元组：</p>


<pre><code>for (airportCode, airportName) in airports {
    prINTln("\(airportCode): \(airportName)")
}
// TYO: Tokyo
// LHR: London Heathrow
</code></pre>


<p><code>for-in</code>循环请参见<a href="05_Control_Flow.html#for_loops">For 循环</a>。</p>


<p>我们也可以通过访问他的<code>keys</code>或者<code>values</code>属性（都是可遍历集合）检索一个字典的键或者值：</p>


<pre><code>for airportCode in airports.keys {
    prINTln("Airport code: \(airportCode)")
}
// Airport code: TYO
// Airport code: LHR

for airportName in airports.values {
    prINTln("Airport name: \(airportName)")
}
// Airport name: Tokyo
// Airport name: London Heathrow
</code></pre>


<p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受<code>Array</code>实例 API 的参数，可以直接使用<code>keys</code>或者<code>values</code>属性直接构造一个新数组：</p>


<pre><code>let airportCodes = Array(airports.keys)
// airportCodes is ["TYO", "LHR"]

let airportNames = Array(airports.values)
// airportNames is ["Tokyo", "London Heathrow"]
</code></pre>


<blockquote>
<p>注意：</p>
<p>Swift 的字典类型是无序集合类型。其中字典键，值，键值对在遍历的时候会重新排列，而且其中顺序是不固定的。</p>
</blockquote>


<p><a name="creating_an_empty_dictionary"></a></p>


<h3 id="-">创建一个空字典</h3>


<p>我们可以像数组一样使用构造语法创建一个空字典：</p>


<pre><code>var namesOfIntegers = Dictionary&lt;Int, String&gt;()
// namesOfIntegers 是一个空的 Dictionary&lt;Int, String&gt;
</code></pre>


<p>这个例子创建了一个<code>Int, String</code>类型的空字典来储存英语对整数的命名。他的键是<code>Int</code>型，值是<code>String</code>型。</p>


<p>如果上下文已经提供了信息类型，我们可以使用空字典字面语句来创建一个空字典，记作<code>[:]</code>（中括号中放一个冒号）：</p>


<pre><code>namesOfIntegers[16] = "sixteen"
// namesOfIntegers 现在包含一个键值对
namesOfIntegers = [:]
// namesOfIntegers 又成为了一个 Int, String类型的空字典
</code></pre>


<blockquote>
<p>注意：</p>
<p>在后台，Swift 的数组和字典都是由泛型集合来实现的，想了解更多泛型和集合信息请参见<a href="22_Generics.html">泛型</a>。</p>
</blockquote>


<p><a name="mutability_of_collections"></a></p>


<h2 id="-">集合的可变性</h2>


<p>数组和字典都是在单个集合中存储可变值。如果我们创建一个数组或者字典并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小。与此相反，如果我们把数组或字典分配成常量，那么他就是不可变的，它的大小不能被改变。</p>


<p>对字典来说，不可变性也意味着我们不能替换其中任何现有键所对应的值。不可变字典的内容在被首次设定之后不能更改。
不可变行对数组来说有一点不同，当然我们不能试着改变任何不可变数组的大小，但是我们·可以重新设定相对现存索引所对应的值。这使得 Swift 数组在大小被固定的时候依然可以做的很棒。</p>


<p>Swift 数组的可变性行为同时影响了数组实例如何被分配和修改，想获取更多信息，请参见<a href="09_Classes_and_Structures.html#assignment_and_copy_behavior_for_collection_types">集合在赋值和复制中的行为</a>。</p>


<blockquote>
<p>注意：</p>
<p>在我们不需要改变数组大小的时候创建不可变数组是很好的习惯。如此 Swift 编译器可以优化我们创建的集合。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift附属脚本]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%99%84%E5%B1%9E%E8%84%9A%E6%9C%AC.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift附属脚本</id>
    <content type="html"><![CDATA[<p><em>附属脚本</em> 可以定义在类（Class）、结构体（structure）和枚举（enumeration）这些目标中，可以认为是访问对象、集合或序列的快捷方式，不需要再调用实例的特定的赋值和访问方法。举例来说，用附属脚本访问一个数组(Array)实例中的元素可以这样写 <code>someArray[index]</code> ，访问字典(Dictionary)实例中的元素可以这样写 <code>someDictionary[key]</code>。</p>


<p>对于同一个目标可以定义多个附属脚本，通过索引值类型的不同来进行重载，而且索引值的个数可以是多个。</p>


<!-- more -->


<blockquote>
<p>译者：这里附属脚本重载在本小节中原文并没有任何演示</p>
</blockquote>


<p><a name="subscript_syntax"></a></p>


<h2 id="-">附属脚本语法</h2>


<p>附属脚本允许你通过在实例后面的方括号中传入一个或者多个的索引值来对实例进行访问和赋值。语法类似于实例方法和计算型属性的混合。与定义实例方法类似，定义附属脚本使用<code>subscript</code>关键字，显式声明入参（一个或多个）和返回类型。与实例方法不同的是附属脚本可以设定为读写或只读。这种方式又有点像计算型属性的getter和setter：</p>


<pre><code>subscript(index: Int) -&gt; Int {
    get {
        // 返回与入参匹配的Int类型的值
    }

    set(newValue) {
        // 执行赋值操作
    }
}
</code></pre>


<p><code>newValue</code>的类型必须和附属脚本定义的返回类型相同。与计算型属性相同的是set的入参声明<code>newValue</code>就算不写，在set代码块中依然可以使用默认的<code>newValue</code>这个变量来访问新赋的值。</p>


<p>与只读计算型属性一样，可以直接将原本应该写在<code>get</code>代码块中的代码写在<code>subscript</code>中：</p>


<pre><code>subscript(index: Int) -&gt; Int {
    // 返回与入参匹配的Int类型的值
}
</code></pre>


<p>下面代码演示了一个在<code>TimesTable</code>结构体中使用只读附属脚本的用法，该结构体用来展示传入整数的<em>n</em>倍。</p>


<pre><code>struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
println("3的6倍是\(threeTimesTable[6])")
// 输出 "3的6倍是18"
</code></pre>


<p>在上例中，通过<code>TimesTable</code>结构体创建了一个用来表示索引值三倍的实例。数值<code>3</code>作为结构体<code>构造函数</code>入参初始化实例成员<code>multiplier</code>。</p>


<p>你可以通过附属脚本来来得到结果，比如<code>threeTimesTable[6]</code>。这句话访问了<code>threeTimesTable</code>的第六个元素，返回<code>18</code>或者<code>6</code>的<code>3</code>倍。</p>


<blockquote>
<p>注意：</p>
<p><code>TimesTable</code>例子是基于一个固定的数学公式。它并不适合开放写权限来对<code>threeTimesTable[someIndex]</code>进行赋值操作，这也是为什么附属脚本只定义为只读的原因。</p>
</blockquote>


<p><a name="subscript_usage"></a></p>


<h2 id="-">附属脚本用法</h2>


<p>根据使用场景不同附属脚本也具有不同的含义。通常附属脚本是用来访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。你可以在你自己特定的类或结构体中自由的实现附属脚本来提供合适的功能。</p>


<p>例如，Swift 的字典（Dictionary）实现了通过附属脚本来对其实例中存放的值进行存取操作。在附属脚本中使用和字典索引相同类型的值，并且把一个字典值类型的值赋值给这个附属脚本来为字典设值：</p>


<pre><code>var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
numberOfLegs["bird"] = 2
</code></pre>


<p>上例定义一个名为<code>numberOfLegs</code>的变量并用一个字典字面量初始化出了包含三对键值的字典实例。<code>numberOfLegs</code>的字典存放值类型推断为<code>Dictionary&lt;String, Int&gt;</code>。字典实例创建完成之后通过附属脚本的方式将整型值<code>2</code>赋值到字典实例的索引为<code>bird</code>的位置中。</p>


<p>更多关于字典（Dictionary）附属脚本的信息请参考<a href="../chapter2/04_Collection_Types.html">读取和修改字典</a></p>


<blockquote>
<p>注意：</p>
<p>Swift 中字典的附属脚本实现中，在<code>get</code>部分返回值是<code>Int?</code>，上例中的<code>numberOfLegs</code>字典通过下边返回的是一个<code>Int?</code>或者说“可选的int”，不是每个字典的索引都能得到一个整型值，对于没有设过值的索引的访问返回的结果就是<code>nil</code>；同样想要从字典实例中删除某个索引下的值也只需要给这个索引赋值为<code>nil</code>即可。</p>
</blockquote>


<p><a name="subscript_options"></a></p>


<h2 id="-">附属脚本选项</h2>


<p>附属脚本允许任意数量的入参索引，并且每个入参类型也没有限制。附属脚本的返回值也可以是任何类型。附属脚本可以使用变量参数和可变参数，但使用写入读出（in-out）参数或给参数设置默认值都是不允许的。</p>


<p>一个类或结构体可以根据自身需要提供多个附属脚本实现，在定义附属脚本时通过入参个类型进行区分，使用附属脚本时会自动匹配合适的附属脚本实现运行，这就是<em>附属脚本的重载</em>。</p>


<p>一个附属脚本入参是最常见的情况，但只要有合适的场景也可以定义多个附属脚本入参。如下例定义了一个<code>Matrix</code>结构体，将呈现一个<code>Double</code>类型的二维矩阵。<code>Matrix</code>结构体的附属脚本需要两个整型参数：</p>


<pre><code>struct Matrix {
    let rows: Int, columns: Int
    var grid: Double[]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            return grid[(row * columns) + column]
        }
        set {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            grid[(row * columns) + columns] = newValue
        }
    }
}
</code></pre>


<p><code>Matrix</code>提供了一个两个入参的构造方法，入参分别是<code>rows</code>和<code>columns</code>，创建了一个足够容纳<code>rows * columns</code>个数的<code>Double</code>类型数组。为了存储，将数组的大小和数组每个元素初始值0.0，都传入数组的构造方法中来创建一个正确大小的新数组。关于数组的构造方法和析构方法请参考<a href="../chapter2/04_Collection_Types.html">创建并且构造一个数组</a>。</p>


<p>你可以通过传入合适的<code>row</code>和<code>column</code>的数量来构造一个新的<code>Matrix</code>实例：</p>


<pre><code>var matrix = Matrix(rows: 2, columns: 2)
</code></pre>


<p>上例中创建了一个新的两行两列的<code>Matrix</code>实例。在阅读顺序从左上到右下的<code>Matrix</code>实例中的数组实例<code>grid</code>是矩阵二维数组的扁平化存储：</p>


<pre><code>// 示意图
grid = [0.0, 0.0, 0.0, 0.0]

        col0     col1
row0   [0.0,     0.0,
row1    0.0,     0.0]
</code></pre>


<p>将值赋给带有<code>row</code>和<code>column</code>附属脚本的<code>matrix</code>实例表达式可以完成赋值操作，附属脚本入参使用逗号分割</p>


<pre><code>matrix[0, 1] = 1.5
matrix[1, 0] = 3.2
</code></pre>


<p>上面两条语句分别<code>让matrix</code>的右上值为 1.5，坐下值为 3.2：</p>


<pre><code>[0.0, 1.5,
 3.2, 0.0]
</code></pre>


<p><code>Matrix</code>附属脚本的<code>getter</code>和<code>setter</code>中同时调用了附属脚本入参的<code>row</code>和<code>column</code>是否有效的判断。为了方便进行断言，<code>Matrix</code>包含了一个名为<code>indexIsValid</code>的成员方法，用来确认入参的<code>row</code>或<code>column</code>值是否会造成数组越界：</p>


<pre><code>func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
    return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
}
</code></pre>


<p>断言在附属脚本越界时触发：</p>


<pre><code>let someValue = matrix[2, 2]
// 断言将会触发，因为 [2, 2] 已经超过了matrix的最大长度
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift闭包]]></title>
    <link href="http://baxiang123.com//blog/Swift%E9%97%AD%E5%8C%85.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift闭包</id>
    <content type="html"><![CDATA[<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。
Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 lambdas 函数比较相似。</p>


<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。
这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。</p>


<!-- more -->


<blockquote>
<p>注意：</p>
<p>如果您不熟悉捕获（capturing）这个概念也不用担心，您可以在 <a href="#capturing_values">值捕获</a> 章节对其进行详细了解。</p>
</blockquote>


<p>在<a href="../chapter2/06_Function.html">函数</a> 章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：</p>


<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>


<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>


<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随（Trailing）闭包语法</li>
</ul>


<p><a name="closure_expressions"></a></p>


<h2 id="-closure-expressions-">闭包表达式（Closure Expressions）</h2>


<p><a href="../chapter2/06_Function.html#nested_function">嵌套函数</a> 是一个在较复杂函数中方便进行命名和定义自包含代码模块的方式。
当然，有时候撰写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在您处理一些函数并需要将另外一些函数作为该函数的参数时。</p>


<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。
闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。
下面闭包表达式的例子通过使用几次迭代展示了<code>sort</code>函数定义和语法优化的方式。
每一次迭代都用更简洁的方式描述了相同的功能。</p>


<p><a name="the_sort_function"></a></p>


<h3 id="sort-the-sort-function-">sort 函数（The Sort Function）</h3>


<p>Swift 标准库提供了<code>sort</code>函数，会根据您提供的基于输出类型排序的闭包函数将已知类型数组中的值进行排序。
一旦排序完成，函数会返回一个与原数组大小相同的新数组，该数组中包含已经正确排序的同类型元素。</p>


<p>下面的闭包表达式示例使用<code>sort</code>函数对一个<code>String</code>类型的数组进行字母逆序排序，以下是初始数组值：</p>


<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</code></pre>


<p><code>sort</code>函数需要传入两个参数：</p>


<ul>
<li>已知类型的数组</li>
<li>闭包函数，该闭包函数需要传入与数组类型相同的两个值，并返回一个布尔类型值来告诉<code>sort</code>函数当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回<code>true</code>，反之返回<code>false</code>。</li>
</ul>


<p>该例子对一个<code>String</code>类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p>


<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为<code>sort</code>函数的第二个参数传入：</p>


<pre><code>func backwards(s1: String, s2: String) -&gt; Bool {
    return s1 &gt; s2
}
var reversed = sort(names, backwards)
// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
</code></pre>


<p>如果第一个字符串 (<code>s1</code>) 大于第二个字符串 (<code>s2</code>)，<code>backwards</code>函数返回<code>true</code>，表示在新的数组中<code>s1</code>应该出现在<code>s2</code>前。
对于字符串中的字符来说，“大于” 表示 “按照字母顺序较晚出现”。
这意味着字母<code>"B"</code>大于字母<code>"A"</code>，字符串<code>"Tom"</code>大于字符串<code>"Tim"</code>。
其将进行字母逆序排序，<code>"Barry"</code>将会排在<code>"Alex"</code>之后。</p>


<p>然而，这是一个相当冗长的方式，本质上只是写了一个单表达式函数 (a &gt; b)。
在下面的例子中，利用闭合表达式语法可以更好的构造一个内联排序闭包。</p>


<p><a name="closure_expression_syntax"></a></p>


<h3 id="-closure-expression-syntax-">闭包表达式语法（Closure Expression Syntax）</h3>


<p>闭包表达式语法有如下一般形式：</p>


<pre><code>{ (parameters) -&gt; returnType in
    statements
}
</code></pre>


<p>闭包表达式语法可以使用常量、变量和<code>inout</code>类型作为参数，不提供默认值。
也可以在参数列表的最后使用可变参数。
元组也可以作为参数和返回值。</p>


<p>下面的例子展示了之前<code>backwards</code>函数对应的闭包表达式版本的代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
    })
</code></pre>


<p>需要注意的是内联闭包参数和返回值类型声明与<code>backwards</code>函数类型声明相同。
在这两种方式中，都写成了<code>(s1: String, s2: String) -&gt; Bool</code>。
然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>


<p>闭包的函数体部分由关键字<code>in</code>引入。
该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>


<p>因为这个闭包的函数体部分如此短以至于可以将其改写成一行代码：</p>


<pre><code>reversed = sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )
</code></pre>


<p>这说明<code>sort</code>函数的整体调用保持不变，一对圆括号仍然包裹住了函数中整个参数集合。而其中一个参数现在变成了内联闭包（相比于<code>backwards</code>版本的代码）。</p>


<p><a name="inferring_type_from_context"></a></p>


<h3 id="-inferring-type-from-context-">根据上下文推断类型（Inferring Type From Context）</h3>


<p>因为排序闭包函数是作为<code>sort</code>函数的参数进行传入的，Swift可以推断其参数和返回值的类型。
<code>sort</code>期望第二个参数是类型为<code>(String, String) -&gt; Bool</code>的函数，因此实际上<code>String</code>,<code>String</code>和<code>Bool</code>类型并不需要作为闭包表达式定义中的一部分。
因为所有的类型都可以被正确推断，返回箭头 (<code>-&gt;</code>) 和围绕在参数周围的括号也可以被省略：</p>


<pre><code>reversed = sort(names, { s1, s2 in return s1 &gt; s2 } )
</code></pre>


<p>实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数时，都可以推断出闭包的参数和返回值类型，这意味着您几乎不需要利用完整格式构造任何内联闭包。</p>


<p><a name="implicit_returns_from_single_expression_closures"></a></p>


<h3 id="-implicit-return-from-single-expression-clossures-">单表达式闭包隐式返回（Implicit Return From Single-Expression Clossures）</h3>


<p>单行表达式闭包可以通过隐藏<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>


<pre><code>reversed = sort(names, { s1, s2 in s1 &gt; s2 } )
</code></pre>


<p>在这个例子中，<code>sort</code>函数的第二个参数函数类型明确了闭包必须返回一个<code>Bool</code>类型值。
因为闭包函数体只包含了一个单一表达式 (<code>s1 &gt; s2</code>)，该表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略。</p>


<p><a name="shorthand_argument_names"></a></p>


<h3 id="-shorthand-argument-names-">参数名称缩写（Shorthand Argument Names）</h3>


<p>Swift 自动为内联函数提供了参数名称缩写功能，您可以直接通过<code>$0</code>,<code>$1</code>,<code>$2</code>来顺序调用闭包的参数。</p>


<p>如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。
<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>


<pre><code>reversed = sort(names, { $0 &gt; $1 } )
</code></pre>


<p>在这个例子中，<code>$0</code>和<code>$1</code>表示闭包中第一个和第二个<code>String</code>类型的参数。</p>


<p><a name="operator_functions"></a></p>


<h3 id="-operator-functions-">运算符函数（Operator Functions）</h3>


<p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。
Swift 的<code>String</code>类型定义了关于大于号 (<code>&gt;</code>) 的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。
而这正好与<code>sort</code>函数的第二个参数需要的函数类型相符合。
因此，您可以简单地传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现：</p>


<pre><code>reversed = sort(names, &gt;)
</code></pre>


<p>更多关于运算符表达式的内容请查看 <a href="../chapter2/23_Advanced_Operators.html#operator_functions">运算符函数</a>。</p>


<p><a name="trailing_closures"></a></p>


<h2 id="-trailing-closures-">尾随闭包（Trailing Closures）</h2>


<p>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。
尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</p>


<pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; ()) {
    // 函数体部分
}

// 以下是不使用尾随闭包进行函数调用

someFunctionThatTakesAClosure({
    // 闭包主体部分
    })

// 以下是使用尾随闭包进行函数调用

someFunctionThatTakesAClosure() {
    // 闭包主体部分
}
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把<code>()</code>省略掉。</p>
</blockquote>


<p>在上例中作为<code>sort</code>函数参数的字符串排序闭包可以改写为：</p>


<pre><code>reversed = sort(names) { $0 &gt; $1 }
</code></pre>


<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。
举例来说，Swift 的<code>Array</code>类型有一个<code>map</code>方法，其获取一个闭包表达式作为其唯一参数。
数组中的每一个元素调用一次该闭包函数，并返回该元素所映射的值(也可以是不同类型的值)。
具体的映射方式和返回值类型由闭包来指定。</p>


<p>当提供给数组闭包函数后，<code>map</code>方法将返回一个新的数组，数组中包含了与原数组一一对应的映射后的值。</p>


<p>下例介绍了如何在<code>map</code>方法中使用尾随闭包将<code>Int</code>类型数组<code>[16,58,510]</code>转换为包含对应<code>String</code>类型的数组<code>["OneSix", "FiveEight", "FiveOneZero"]</code>:</p>


<pre><code>let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
</code></pre>


<p>如上代码创建了一个数字位和他们名字映射的英文版本字典。
同时定义了一个准备转换为字符串的整型数组。</p>


<p>您现在可以通过传递一个尾随闭包给<code>numbers</code>的<code>map</code>方法来创建对应的字符串版本数组。
需要注意的时调用<code>numbers.map</code>不需要在<code>map</code>后面包含任何括号，因为其只需要传递闭包表达式这一个参数，并且该闭包表达式参数通过尾随方式进行撰写：</p>


<pre><code>let strings = numbers.map {
    (var number) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
// strings 常量被推断为字符串类型数组，即 String[]
// 其值为 ["OneSix", "FiveEight", "FiveOneZero"]
</code></pre>


<p><code>map</code>在数组中为每一个元素调用了闭包表达式。
您不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行推断。</p>


<p>闭包<code>number</code>参数被声明为一个变量参数（变量的具体描述请参看<a href="../chapter2/06_Functions.html#closure_expression_syntax">常量参数和变量参数</a>），因此可以在闭包函数体内对其进行修改。
闭包表达式制定了返回类型为<code>String</code>，以表明存储映射值的新数组类型为<code>String</code>。</p>


<p>闭包表达式在每次被调用的时候创建了一个字符串并返回。
其使用求余运算符 (number % 10) 计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。</p>


<blockquote>
<p>注意：</p>
<p>字典<code>digitNames</code>下标后跟着一个叹号 (!)，因为字典下标返回一个可选值 (optional value)，表明即使该 key 不存在也不会查找失败。
在上例中，它保证了<code>number % 10</code>可以总是作为一个<code>digitNames</code>字典的有效下标 key。
因此叹号可以用于强制解析 (force-unwrap) 存储在可选下标项中的<code>String</code>类型值。</p>
</blockquote>


<p>从<code>digitNames</code>字典中获取的字符串被添加到输出的前部，逆序建立了一个字符串版本的数字。
（在表达式<code>number % 10</code>中，如果number为16，则返回6，58返回8，510返回0）。</p>


<p><code>number</code>变量之后除以10。
因为其是整数，在计算过程中未除尽部分被忽略。
因此 16变成了1，58变成了5，510变成了51。</p>


<p>整个过程重复进行，直到<code>number /= 10</code>为0，这时闭包会将字符串输出，而<code>map</code>函数则会将字符串添加到所映射的数组中。</p>


<p>上例中尾随闭包语法在函数后整洁封装了具体的闭包功能，而不再需要将整个闭包包裹在<code>map</code>函数的括号内。</p>


<p><a name="capturing_values"></a></p>


<h2 id="-capturing-values-">捕获值（Capturing Values）</h2>


<p>闭包可以在其定义的上下文中捕获常量或变量。
即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>


<p>Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>


<p>下例为一个叫做<code>makeIncrementor</code>的函数，其包含了一个叫做<code>incrementor</code>嵌套函数。
嵌套函数<code>incrementor</code>从上下文中捕获了两个值，<code>runningTotal</code>和<code>amount</code>。
之后<code>makeIncrementor</code>将<code>incrementor</code>作为闭包返回。
每次调用<code>incrementor</code>时，其会以<code>amount</code>作为增量增加<code>runningTotal</code>的值。</p>


<pre><code>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementor
}
</code></pre>


<p><code>makeIncrementor</code>返回类型为<code>() -&gt; Int</code>。
这意味着其返回的是一个函数，而不是一个简单类型值。
该函数在每次调用时不接受参数只返回一个<code>Int</code>类型的值。
关于函数返回其他函数的内容，请查看<a href="../chapter2/06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>


<p><code>makeIncrementor</code>函数定义了一个整型变量<code>runningTotal</code>(初始为0) 用来存储当前跑步总数。
该值通过<code>incrementor</code>返回。</p>


<p><code>makeIncrementor</code>有一个<code>Int</code>类型的参数，其外部命名为<code>forIncrement</code>， 内部命名为<code>amount</code>，表示每次<code>incrementor</code>被调用时<code>runningTotal</code>将要增加的量。</p>


<p><code>incrementor</code>函数用来执行实际的增加操作。
该函数简单地使<code>runningTotal</code>增加<code>amount</code>，并将其返回。</p>


<p>如果我们单独看这个函数，会发现看上去不同寻常：</p>


<pre><code>func incrementor() -&gt; Int {
    runningTotal += amount
    return runningTotal
}
</code></pre>


<p><code>incrementor</code>函数并没有获取任何参数，但是在函数体内访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为其通过捕获在包含它的函数体内已经存在的<code>runningTotal</code>和<code>amount</code>变量而实现。</p>


<p>由于没有修改<code>amount</code>变量，<code>incrementor</code>实际上捕获并存储了该变量的一个副本，而该副本随着<code>incrementor</code>一同被存储。</p>


<p>然而，因为每次调用该函数的时候都会修改<code>runningTotal</code>的值，<code>incrementor</code>捕获了当前<code>runningTotal</code>变量的引用，而不是仅仅复制该变量的初始值。捕获一个引用保证了当<code>makeIncrementor</code>结束时候并不会消失，也保证了当下一次执行<code>incrementor</code>函数时，<code>runningTotal</code>可以继续增加。</p>


<blockquote>
<p>注意：</p>
<p>Swift 会决定捕获引用还是拷贝值。
您不需要标注<code>amount</code>或者<code>runningTotal</code>来声明在嵌入的<code>incrementor</code>函数中的使用方式。
Swift 同时也处理<code>runingTotal</code>变量的内存管理操作，如果不再被<code>incrementor</code>函数使用，则会被清除。</p>
</blockquote>


<p>下面代码为一个使用<code>makeIncrementor</code>的例子：</p>


<pre><code>let incrementByTen = makeIncrementor(forIncrement: 10)
</code></pre>


<p>该例子定义了一个叫做<code>incrementByTen</code>的常量，该常量指向一个每次调用会加10的<code>incrementor</code>函数。
调用这个函数多次可以得到以下结果：</p>


<pre><code>incrementByTen()
// 返回的值为10
incrementByTen()
// 返回的值为20
incrementByTen()
// 返回的值为30
</code></pre>


<p>如果您创建了另一个<code>incrementor</code>，其会有一个属于自己的独立的<code>runningTotal</code>变量的引用。
下面的例子中，<code>incrementBySevne</code>捕获了一个新的<code>runningTotal</code>变量，该变量和<code>incrementByTen</code>中捕获的变量没有任何联系：</p>


<pre><code>let incrementBySeven = makeIncrementor(forIncrement: 7)
incrementBySeven()
// 返回的值为7
incrementByTen()
// 返回的值为40
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果您闭包分配给一个类实例的属性，并且该闭包通过指向该实例或其成员来捕获了该实例，您将创建一个在闭包和实例间的强引用环。
Swift 使用捕获列表来打破这种强引用环。更多信息，请参考 <a href="../chapter2/16_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>


<p><a name="closures_are_reference_types"></a></p>


<h2 id="-closures-are-reference-types-">闭包是引用类型（Closures Are Reference Types）</h2>


<p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。
这是因为函数和闭包都是引用类型。</p>


<p>无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。
上面的例子中，<code>incrementByTen</code>指向闭包的引用是一个常量，而并非闭包内容本身。</p>


<p>这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包：</p>


<pre><code>let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// 返回的值为50
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift基础]]></title>
    <link href="http://baxiang123.com//blog/Swift%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift语言简介</id>
    <content type="html"><![CDATA[<h2>常量和变量</h2>


<p>常量和变量把一个名字（比如maximumNumberOfLoginAttempts或者welcomeMessage）和一个指定类型的值（比如数字10或者字符串&#8221;Hello&#8221;）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>

<p>Swift 是 iOS 和 OS X 应用开发的一门新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>


<!-- more -->


<p>Swift 的类型是在 C 和 Objective-C 的基础上提出的，<code>Int</code>是整型；<code>Double</code>和<code>Float</code>是浮点型；<code>Bool</code>是布尔型；<code>String</code>是字符串。Swift 还有两个有用的集合类型，<code>Array</code>和<code>Dictionary</code>，请参考<a href="04_Collection_Types.html">集合类型</a>。</p>


<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，值不可变的变量有着广泛的应用，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更好地表达你的意图。</p>


<p>除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>


<p>Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用<code>nil</code>，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的<code>nil</code>指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>


<p>Swift 是一个类型安全的语言，可选就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个<code>String</code>，类型安全会阻止你不小心传入一个<code>Int</code>。你可以在开发阶段尽早发现并修正错误。</p>


<p><a name="constants_and_variables"></a></p>


<h2 id="-">常量和变量</h2>


<p>常量和变量把一个名字（比如<code>maximumNumberOfLoginAttempts</code>或者<code>welcomeMessage</code>）和一个指定类型的值（比如数字<code>10</code>或者字符串<code>"Hello"</code>）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>


<h3 id="-">声明常量和变量</h3>


<p>常量和变量必须在使用前声明，用<code>let</code>来声明常量，用<code>var</code>来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：</p>


<pre><code>let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
</code></pre>


<p>这两行代码可以被理解为：</p>


<p>“声明一个名字是<code>maximumNumberOfLoginAttempts</code>的新常量，并给它一个值<code>10</code>。然后，声明一个名字是<code>currentLoginAttempt</code>的变量并将它的值初始化为<code>0</code>.”</p>


<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>


<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>


<pre><code>var x = 0.0, y = 0.0, z = 0.0
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果你的代码中有不需要改变的值，请使用<code>let</code>关键字将它声明为常量。只将需要改变的值声明为变量。</p>
</blockquote>


<h3 id="-">类型标注</h3>


<p>当你声明常量或者变量的时候可以加上<em>类型标注(type annotation)</em>，说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>


<p>这个例子给<code>welcomeMessage</code>变量添加了类型标注，表示这个变量可以存储<code>String</code>类型的值：</p>


<pre><code>var welcomeMessage: String
</code></pre>


<p>声明中的冒号代表着“是&#8230;类型”，所以这行代码可以被理解为：</p>


<p>“声明一个类型为<code>String</code>，名字为<code>welcomeMessage</code>的变量。”</p>


<p>“类型为<code>String</code>”的意思是“可以存储任意<code>String</code>类型的值。”</p>


<p><code>welcomeMessage</code>变量现在可以被设置成任意字符串：</p>


<pre><code>welcomeMessage = "Hello"
</code></pre>


<blockquote>
<p>注意：</p>
<p>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。在上面的例子中，没有给<code>welcomeMessage</code>赋初始值，所以变量<code>welcomeMessage</code>的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
</blockquote>


<h3 id="-">常量和变量的命名</h3>


<p>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：</p>


<pre><code>let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
</code></pre>


<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>


<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</p>


<blockquote>
<p>注意：</p>
<p>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。</p>
</blockquote>


<p>你可以更改现有的变量值为其他同类型的值，在下面的例子中，<code>friendlyWelcome</code>的值从<code>"Hello!"</code>改为了<code>"Bonjour!"</code>:</p>


<pre><code>var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome 现在是 "Bonjour!"
</code></pre>


<p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>


<pre><code>let languageName = "Swift"
languageName = "Swift++"
// 这会报编译时错误 - languageName 不可改变
</code></pre>


<h3 id="-">输出常量和变量</h3>


<p>你可以用<code>println</code>函数来输出当前常量或变量的值:</p>


<pre><code>println(friendlyWelcome)
// 输出 "Bonjour!"
</code></pre>


<p><code>println</code>是一个用来输出的全局函数，输出的内容会在最后换行。如果你用 Xcode，<code>println</code>将会输出内容到“console”面板上。(另一种函数叫<code>print</code>，唯一区别是在输出内容最后不会换行。)</p>


<p><code>println</code>函数输出传入的<code>String</code>值：</p>


<pre><code>println("This is a string")
// 输出 "This is a string"
</code></pre>


<p>与 Cocoa 里的<code>NSLog</code>函数类似的是，<code>println</code>函数可以输出更复杂的信息。这些信息可以包含当前常量和变量的值。</p>


<p>Swift 用<em>字符串插值（string interpolation）</em>的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>


<pre><code>println("The current value of friendlyWelcome is \(friendlyWelcome)")
// 输出 "The current value of friendlyWelcome is Bonjour!
</code></pre>


<blockquote>
<p>注意：</p>
<p>字符串插值所有可用的选项，请参考<a href="03_Strings_and_Characters.html#string_interpolation">字符串插值</a>。</p>
</blockquote>


<p><a name="comments"></a></p>


<h2 id="-">注释</h2>


<p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>


<p>Swift 中的注释与C 语言的注释非常相似。单行注释以双正斜杠作(<code>//</code>)为起始标记:</p>


<pre><code>// 这是一个注释
</code></pre>


<p>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号(<code>/*</code>)，终止标记为一个星号后跟随单个正斜杠(<code>*/</code>):</p>


<pre><code>/* 这是一个,
多行注释 */
</code></pre>


<p>与C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：</p>


<pre><code>/* 这是第一个多行注释的开头
/* 这是第二个被嵌套的多行注释 */
这是第一个多行注释的结尾 */
</code></pre>


<p>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>


<p><a name="semicolons"></a></p>


<h2 id="-">分号</h2>


<p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（<code>;</code>），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：</p>


<pre><code>let cat = "🐱"; println(cat)
// 输出 "🐱"
</code></pre>


<p><a name="integers"></a></p>


<h2 id="-">整数</h2>


<p>整数就是没有小数部分的数字，比如<code>42</code>和<code>-23</code>。整数可以是<code>有符号</code>（正、负、零）或者<code>无符号</code>（正、零）。</p>


<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是<code>UInt8</code>，32位有符号整数类型是<code>Int32</code>。就像 Swift 的其他类型一样，整数类型采用大写命名法。</p>


<h3 id="-">整数范围</h3>


<p>你可以访问不同整数类型的<code>min</code>和<code>max</code>属性来获取对应类型的最大值和最小值：</p>


<pre><code>let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型的最小值
let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型的最大值
</code></pre>


<h3 id="int">Int</h3>


<p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型<code>Int</code>，长度与当前平台的原生字长相同：</p>


<ul>
<li>在32位平台上，<code>Int</code>和<code>Int32</code>长度相同。</li>
<li>在64位平台上，<code>Int</code>和<code>Int64</code>长度相同。</li>
</ul>


<p>除非你需要特定长度的整数，一般来说使用<code>Int</code>就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，<code>Int</code>可以存储的整数范围也可以达到<code>-2147483648</code>~<code>2147483647</code>，大多数时候这已经足够大了。</p>


<h3 id="uint">UInt</h3>


<p>Swift 也提供了一个特殊的无符号类型<code>UInt</code>，长度与当前平台的原生字长相同：</p>


<ul>
<li>在32位平台上，<code>UInt</code>和<code>UInt32</code>长度相同。</li>
<li>在64位平台上，<code>UInt</code>和<code>UInt64</code>长度相同。</li>
</ul>


<blockquote>
<p>注意：</p>
<p>尽量不要使用<code>UInt</code>，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推测，请参考<a href="#type_safety_and_type_inference">类型安全和类型推测</a>。</p>
</blockquote>


<p><a name="floating-point_numbers"></a></p>


<h2 id="-">浮点数</h2>


<p>浮点数是有小数部分的数字，比如<code>3.14159</code>，<code>0.1</code>和<code>-273.15</code>。</p>


<p>浮点类型比整数类型表示的范围更大，可以存储比<code>Int</code>类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>


<ul>
<li><code>Double</code>表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li><code>Float</code>表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>


<blockquote>
<p>注意：</p>
<p><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。</p>
</blockquote>


<p><a name="type_safety_and_type_inference"></a></p>


<h2 id="-">类型安全和类型推测</h2>


<p>Swift 是一个<em>类型安全(type safe )</em>的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个<code>String</code>，你绝对不可能不小心传进去一个<code>Int</code>。</p>


<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行<em>类型检查(type checks)</em>，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>


<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用<em>类型推测(type inference)</em>来选择合适的类型。有了类型推测，编译器可以在编译代码的时候自动推测出表达式的类型。原理很简单，只要检查你赋的值即可。</p>


<p>因为有类型推测，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>


<p>当你声明常量或者变量并赋初值的时候类型推测非常有用。当你在声明常量或者变量的时候赋给它们一个<em>字面量(literal value 或 literal)</em>即可触发类型推测。（字面量就是会直接出现在你代码中的值，比如<code>42</code>和<code>3.14159</code>。）</p>


<p>例如，如果你给一个新常量赋值<code>42</code>并且没有标明类型，Swift 可以推测出常量类型是<code>Int</code>，因为你给它赋的初始值看起来像一个整数：</p>


<pre><code>let meaningOfLife = 42
// meaningOfLife 会被推测为 Int 类型
</code></pre>


<p>同理，如果你没有给浮点字面量标明类型，Swift 会推测你想要的是<code>Double</code>：</p>


<pre><code>let pi = 3.14159
// pi 会被推测为 Double 类型
</code></pre>


<p>当推测浮点数的类型时，Swift 总是会选择<code>Double</code>而不是<code>Float</code>。</p>


<p>如果表达式中同时出现了整数和浮点数，会被推测为<code>Double</code>类型：</p>


<pre><code>let anotherPi = 3 + 0.14159
// anotherPi 会被推测为 Double 类型
</code></pre>


<p>原始值<code>3</code>没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推测为<code>Double</code>类型。</p>


<p><a name="numeric_literals"></a></p>


<h2 id="-">数值型字面量</h2>


<p>整数字面量可以被写作：</p>


<ul>
<li>一个十进制数，没有前缀</li>
<li>一个二进制数，前缀是<code>0b</code></li>
<li>一个八进制数，前缀是<code>0o</code></li>
<li>一个十六进制数，前缀是<code>0x</code></li>
</ul>


<p>下面的所有整数字面量的十进制值都是<code>17</code>:</p>


<pre><code>let decimalInteger = 17
let binaryInteger = 0b10001       // 二进制的17
let octalInteger = 0o21           // 八进制的17
let hexadecimalInteger = 0x11     // 十六进制的17
</code></pre>


<p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是<code>0x</code>）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。浮点字面量还有一个可选的<em>指数(exponent)</em>，在十进制浮点数中通过大写或者小写的<code>e</code>来指定，在十六进制浮点数中通过大写或者小写的<code>p</code>来指定。</p>


<p>如果一个十进制数的指数为<code>exp</code>，那这个数相当于基数和<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-7-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-57"><span style="display: inline-block; position: relative; width: 2.116em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(3.115em 1000em 4.184em -0.399em); top: -4em; left: 0em;"><span class="mrow" id="MathJax-Span-58"><span class="msubsup" id="MathJax-Span-59"><span style="display: inline-block; position: relative; width: 2.116em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-60" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-61"><span class="mrow" id="MathJax-Span-62"><span class="mi" id="MathJax-Span-63" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-64" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-65" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">p</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.061em; vertical-align: -0.089em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-7">10^{exp}</script>的乘积：</p>


<ul>
<li><code>1.25e2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-8-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-66"><span style="display: inline-block; position: relative; width: 4.365em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-67"><span class="mn" id="MathJax-Span-68" style="font-family: STIXGeneral-Regular;">1.25</span><span class="mo" id="MathJax-Span-69" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-70" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.492em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-71" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-72"><span class="mrow" id="MathJax-Span-73"><span class="mn" id="MathJax-Span-74" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-8">1.25 × 10^{2}</script>，等于 <code>125.0</code>。</li>
<li><code>1.25e-2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-9-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-75"><span style="display: inline-block; position: relative; width: 4.819em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-76"><span class="mn" id="MathJax-Span-77" style="font-family: STIXGeneral-Regular;">1.25</span><span class="mo" id="MathJax-Span-78" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-79" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.946em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.715em -0.399em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-80" style="font-family: STIXGeneral-Regular;">10</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 1.02em;"><span class="texatom" id="MathJax-Span-81"><span class="mrow" id="MathJax-Span-82"><span class="mo" id="MathJax-Span-83" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">−</span><span class="mn" id="MathJax-Span-84" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-9">1.25 × 10^{-2}</script>，等于 <code>0.0125</code>。</li>
</ul>


<p>如果一个十六进制数的指数为<code>exp</code>，那这个数相当于基数和<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-10-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-85"><span style="display: inline-block; position: relative; width: 1.606em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(3.115em 1000em 4.17em -0.481em); top: -4em; left: 0em;"><span class="mrow" id="MathJax-Span-86"><span class="msubsup" id="MathJax-Span-87"><span style="display: inline-block; position: relative; width: 1.606em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-88" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-89"><span class="mrow" id="MathJax-Span-90"><span class="mi" id="MathJax-Span-91" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-92" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.002em;"></span></span><span class="mi" id="MathJax-Span-93" style="font-size: 70.7%; font-family: STIXGeneral-Italic;">p</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.044em; vertical-align: -0.071em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-10">2^{exp}</script>的乘积：</p>


<ul>
<li><code>0xFp2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-11-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-94"><span style="display: inline-block; position: relative; width: 3.118em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-95"><span class="mn" id="MathJax-Span-96" style="font-family: STIXGeneral-Regular;">15</span><span class="mo" id="MathJax-Span-97" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-98" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 0.982em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-99" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-100"><span class="mrow" id="MathJax-Span-101"><span class="mn" id="MathJax-Span-102" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-11">15 × 2^{2}</script>，等于 <code>60.0</code>。</li>
<li><code>0xFp-2</code> 表示 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-12-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-103"><span style="display: inline-block; position: relative; width: 3.571em; height: 0px; font-size: 126%;"><span style="position: absolute; clip: rect(1.48em 1000em 2.726em -0.399em); top: -2.531em; left: 0em;"><span class="mrow" id="MathJax-Span-104"><span class="mn" id="MathJax-Span-105" style="font-family: STIXGeneral-Regular;">15</span><span class="mo" id="MathJax-Span-106" style="font-family: STIXGeneral-Regular; padding-left: 0.25em;">×</span><span class="msubsup" id="MathJax-Span-107" style="padding-left: 0.25em;"><span style="display: inline-block; position: relative; width: 1.436em; height: 0px;"><span style="position: absolute; clip: rect(1.685em 1000em 2.701em -0.481em); top: -2.531em; left: 0em;"><span class="mn" id="MathJax-Span-108" style="font-family: STIXGeneral-Regular;">2</span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span><span style="position: absolute; top: -2.707em; left: 0.51em;"><span class="texatom" id="MathJax-Span-109"><span class="mrow" id="MathJax-Span-110"><span class="mo" id="MathJax-Span-111" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">−</span><span class="mn" id="MathJax-Span-112" style="font-size: 70.7%; font-family: STIXGeneral-Regular;">2</span></span></span><span style="display: inline-block; width: 0px; height: 2.304em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.531em;"></span></span></span><span style="border-left-width: 0em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.284em; vertical-align: -0.103em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-12">15 × 2^{-2}</script>，等于 <code>3.75</code>。</li>
</ul>


<p>下面的这些浮点字面量都等于十进制的<code>12.1875</code>：</p>


<pre><code>let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
</code></pre>


<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>


<pre><code>let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</code></pre>


<p><a name="numeric_type_conversion"></a></p>


<h2 id="-">数值型类型转换</h2>


<p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用<code>Int</code>类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推测。
只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>


<h3 id="-">整数转换</h3>


<p>不同整数类型的变量和常量可以存储不同范围的数字。<code>Int8</code>类型的常量或者变量可以存储的数字范围是<code>-128</code>~<code>127</code>，而<code>UInt8</code>类型的常量或者变量能存储的数字范围是<code>0</code>~<code>255</code>。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：</p>


<pre><code>let cannotBeNegative: UInt8 = -1
// UInt8 类型不能存储负数，所以会报错
let tooBig: Int8 = Int8.max + 1
// Int8 类型不能存储超过最大值的数，所以会报错
</code></pre>


<p>由于每中整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>


<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量<code>twoThousand</code>是<code>UInt16</code>类型，然而常量<code>one</code>是<code>Uint8</code>类型。它们不能直接相加，因为它们类型不同。所以要调用<code>UInt16(one)</code>来创建一个新的<code>UInt16</code>数字并用<code>one</code>的值来初始化，然后使用这个新数字来计算：</p>


<pre><code>let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>


<p>现在两个数字的类型都是<code>UInt16</code>，可以进行相加。目标常量<code>twoThousandAndOne</code>的类型被推测为<code>UInt16</code>，因为它是两个<code>UInt16</code>值的和。</p>


<p><code>SomeType(ofInitialValue)</code>是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，<code>UInt16</code>有一个构造器，可以接受一个<code>UInt8</code>类型的值，所以这个构造器可以用现有的<code>UInt8</code>来创建一个新的<code>UInt16</code>。注意，你并不能传入任意类型的值，只能传入<code>UInt16</code>内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考<a href="20_Extensions.html">扩展</a>。</p>


<h3 id="-">整数和浮点数转换</h3>


<p>整数和浮点数的转换必须显式指定类型：</p>


<pre><code>let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi 等于 3.14159，所以被推测为 Double 类型
</code></pre>


<p>这个例子中，常量<code>three</code>的值被用来创建一个<code>Double</code>类型的值，所以加号两边的数类型相同。如果不进行转换，两者无法相加。</p>


<p>浮点数到整数的反向转换同样行，整数类型可以用<code>Double</code>或者<code>Float</code>类型来初始化：</p>


<pre><code>let integerPi = Int(pi)
// integerPi 等于 3，所以被推测为 Int 类型
</code></pre>


<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说<code>4.75</code>会变成<code>4</code>，<code>-3.9</code>会变成<code>-3</code>。</p>


<blockquote>
<p>注意：</p>
<p>结合数字类常量和变量不同于结合数字类字面量。字面量<code>3</code>可以直接和字面量<code>0.14159</code>相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。</p>
</blockquote>


<p><a name="type_aliases"></a></p>


<h2 id="-">类型别名</h2>


<p><em>类型别名(type aliases)</em>就是给现有类型定义另一个名字。你可以使用<code>typealias</code>关键字来定义类型别名。</p>


<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p>


<pre><code>typealias AudioSample = UInt16
</code></pre>


<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>


<pre><code>var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound 现在是 0
</code></pre>


<p>本例中，<code>AudioSample</code>被定义为<code>UInt16</code>的一个别名。因为它是别名，<code>AudioSample.min</code>实际上是<code>UInt16.min</code>，所以会给<code>maxAmplitudeFound</code>赋一个初值<code>0</code>。</p>


<p><a name="booleans"></a></p>


<h2 id="-">布尔值</h2>


<p>Swift 有一个基本的<em>布尔(Boolean)</em>类型，叫做<code>Bool</code>。布尔值指<em>逻辑上的(logical)</em>，因为它们只能是真或者假。Swift 有两个布尔常量，<code>true</code>和<code>false</code>：</p>


<pre><code>let orangesAreOrange = true
let turnipsAreDelicious = false
</code></pre>


<p><code>orangesAreOrange</code>和<code>turnipsAreDelicious</code>的类型会被推测为<code>Bool</code>，因为它们的初值是布尔字面量。就像之前提到的<code>Int</code>和<code>Double</code>一样，如果你创建变量的时候给它们赋值<code>true</code>或者<code>false</code>，那你不需要将常量或者变量声明为<code>Bool</code>类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推测，这让 Swift 代码更加简洁并且可读性更高。</p>


<p>当你编写条件语句比如<code>if</code>语句的时候，布尔值非常有用：</p>


<pre><code>if turnipsAreDelicious {
    println("Mmm, tasty turnips!")
} else {
    println("Eww, turnips are horrible.")
}
// 输出 "Eww, turnips are horrible."
</code></pre>


<p>条件语句，例如<code>if</code>，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<p>如果你在需要使用<code>Bool</code>类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>


<pre><code>let i = 1
if i {
    // 这个例子不会通过编译，会报错
}
</code></pre>


<p>然而，下面的例子是合法的：</p>


<pre><code>let i = 1
if i == 1 {
    // 这个例子会编译成功
}
</code></pre>


<p><code>i == 1</code>的比较结果是<code>Bool</code>类型，所以第二个例子可以通过类型检查。类似<code>i == 1</code>这样的比较，请参考<a href="05_Control_Flow.html">基本操作符</a>。</p>


<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p>


<p><a name="tuples"></a></p>


<h2 id="-">元组</h2>


<p><em>元组（tuples）</em>把多个值组合成一个复合值。元组内的值可以使任意类型，并不要求是相同类型。</p>


<p>下面这个例子中，<code>(404, "Not Found")</code>是一个描述 <em>HTTP 状态码（HTTP status code）</em>的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个<code>404 Not Found</code>状态码。</p>


<pre><code>let http404Error = (404, "Not Found")
// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")
</code></pre>


<p><code>(404, "Not Found")</code>元组把一个<code>Int</code>值和一个<code>String</code>值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为<code>(Int, String)</code>的元组”。</p>


<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为<code>(Int, Int, Int)</code>或者<code>(String, Bool)</code>或者其他任何你想要的组合的元组。</p>


<p>你可以将一个元组的内容<em>分解（decompose）</em>成单独的常量和变量，然后你就可以正常使用它们了：</p>


<pre><code>let (statusCode, statusMessage) = http404Error
println("The status code is \(statusCode)")
// 输出 "The status code is 404"
println("The status message is \(statusMessage)")
// 输出 "The status message is Not Found"
</code></pre>


<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：</p>


<pre><code>let (justTheStatusCode, _) = http404Error
println("The status code is \(justTheStatusCode)")
// 输出 "The status code is 404"
</code></pre>


<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>


<pre><code>println("The status code is \(http404Error.0)")
// 输出 "The status code is 404"
println("The status message is \(http404Error.1)")
// 输出 "The status message is Not Found"
</code></pre>


<p>你可以在定义元组的时候给单个元素命名：</p>


<pre><code>let http200Status = (statusCode: 200, description: "OK")
</code></pre>


<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>


<pre><code>println("The status code is \(http200Status.statusCode)")
// 输出 "The status code is 200"
println("The status message is \(http200Status.description)")
// 输出 "The status message is OK"
</code></pre>


<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个<code>(Int, String)</code>元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考[函数参数与返回值(06_Functions.html#Function_Parameters_and_Return_Values)。</p>


<blockquote>
<p>注意：</p>
<p>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考<a href="09_Classes_and_Structures.html">类和结构体</a>。</p>
</blockquote>


<p><a name="optionals"></a></p>


<h2 id="-">可选</h2>


<p>使用<em>可选（optionals）</em>来处理值可能缺失的情况。可选表示：</p>


<ul>
<li><em>有</em>值，等于 x</li>
</ul>


<p>或者</p>


<ul>
<li><em>没有</em>值</li>
</ul>


<blockquote>
<p>注意：</p>
<p>C 和 Objective-C 中并没有可选这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回<code>nil</code>，<code>nil</code>表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选可以让你暗示<em>任意类型</em>的值缺失，并不需要一个特殊值。</p>
</blockquote>


<p>来看一个例子。Swift 的<code>String</code>类型有一个叫做<code>toInt</code>的方法，作用是将一个<code>String</code>值转换成一个<code>Int</code>值。然而，并不是所有的字符串都可以转换成一个整数。字符串<code>"123"</code>可以被转换成数字<code>123</code>，但是字符串<code>"hello, world"</code>不行。</p>


<p>下面的例子使用<code>toInt</code>方法来尝试将一个<code>String</code>转换成<code>Int</code>：</p>


<pre><code>let possibleNumber = "123"
let convertedNumber = possibleNumber.toInt()
// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"
</code></pre>


<p>因为<code>toInt</code>方法可能会失败，所以它返回一个<em>可选的（optional）</em><code>Int</code>，而不是一个<code>Int</code>。一个可选的<code>Int</code>被写作<code>Int?</code>而不是<code>Int</code>。问号暗示包含的值是可选，也就是说可能包含<code>Int</code>值也可能不包含值。（不能包含其他任何值比如<code>Bool</code>值或者<code>String</code>值。只能是<code>Int</code>或者什么都没有。）</p>


<h3 id="if-">if 语句以及强制解析</h3>


<p>你可以使用<code>if</code>语句来判断一个可选是否包含值。如果可选有值，结果是<code>true</code>；如果没有值，结果是<code>false</code>。</p>


<p>当你确定可选包<em>确实</em>含值之后，你可以在可选的名字后面加一个感叹号(<code>!</code>)来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的<em>强制解析（forced unwrapping）</em>：</p>


<pre><code>if convertedNumber {
    println("\(possibleNumber) has an integer value of \(convertedNumber!)")
} else {
    println("\(possibleNumber) could not be converted to an integer")
}
// 输出 "123 has an integer value of 123"
</code></pre>


<p>更多关于<code>if</code>语句的内容，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<blockquote>
<p>注意：</p>
<p>使用<code>!</code>来获取一个不存在的可选值会导致运行时错误。使用<code>!</code>来强制解析值之前，一定要确定可选包含一个非<code>nil</code>的值。</p>
</blockquote>


<h3 id="-">可选绑定</h3>


<p>使用<em>可选绑定（optional binding）</em>来判断可选是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在<code>if</code>和<code>while</code>语句中来对可选的值进行判断并把值赋给一个常量或者变量。<code>if</code>和<code>while</code>语句，请参考<a href="05_Control_Flow.html">控制流</a>。</p>


<p>像下面这样在<code>if</code>语句中写一个可选绑定：</p>


<pre><code>if let constantName = someOptional {
    statements
}
</code></pre>


<p>你可以像上面这样使用可选绑定来重写<code>possibleNumber</code>这个例子：</p>


<pre><code>if let actualNumber = possibleNumber.toInt() {
    println("\(possibleNumber) has an integer value of \(actualNumber)")
} else {
    println("\(possibleNumber) could not be converted to an integer")
}
// 输出 "123 has an integer value of 123"
</code></pre>


<p>这段代码可以被理解为：</p>


<p>“如果<code>possibleNumber.toInt</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。”</p>


<p>如果转换成功，<code>actualNumber</code>常量可以在<code>if</code>语句的第一个分支中使用。它已经被可选<em>包含的</em>值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。在这个例子中，<code>actualNumber</code>只被用来输出转换结果。</p>


<p>你可以在可选绑定中使用常量和变量。如果你想在<code>if</code>语句的第一个分支中操作<code>actualNumber</code>的值，你可以改成<code>if var actualNumber</code>，这样可选包含的值就会被赋给一个变量而非常量。</p>


<h3 id="nil">nil</h3>


<p>你可以给可选变量赋值为<code>nil</code>来表示它没有值：</p>


<pre><code>var serverResponseCode: Int? = 404
// serverResponseCode 包含一个可选的 Int 值 404
serverResponseCode = nil
// serverResponseCode 现在不包含值
</code></pre>


<blockquote>
<p>注意：</p>
<p><code>nil</code>不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>


<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为<code>nil</code>：</p>


<pre><code>var surveyAnswer: String?
// surveyAnswer 被自动设置为 nil
</code></pre>


<blockquote>
<p>注意：</p>
<p>Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。<em>任何</em>类型的可选都可以被设置为<code>nil</code>，不只是对象类型。</p>
</blockquote>


<h3 id="-">隐式解析可选</h3>


<p>如上所述，可选暗示了常量或者变量可以“没有值”。可选可以通过<code>if</code>语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>


<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>


<p>这种类型的可选被定义为<em>隐式解析可选（implicitly unwrapped optionals）</em>。把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选。</p>


<p>当可选被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选非常有用。隐式解析可选主要被用在 Swift 中类的构造过程中，请参考<a href="16_Automatic_Reference_Counting.html#strong_reference_cycles_between_class_instances">类实例之间的循环强引用</a>。</p>


<p>一个隐式解析可选其实就是一个普通的可选，但是可以被当做非可选来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选<code>String</code>和隐式解析可选<code>String</code>之间的区别：</p>


<pre><code>let possibleString: String? = "An optional string."
println(possibleString!) // 需要惊叹号来获取值
// 输出 "An optional string."

let assumedString: String! = "An implicitly unwrapped optional string."
println(assumedString)  // 不需要感叹号
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<p>你可以把隐式解析可选当做一个可以自动解析的可选。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>


<blockquote>
<p>注意：</p>
<p>如果你在隐式解析可选没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选后面加一个惊叹号一样。</p>
</blockquote>


<p>你仍然可以把隐式解析可选当做普通可选来判断它是否包含值：</p>


<pre><code>if assumedString {
    println(assumedString)
}
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<p>你也可以在可选绑定中使用隐式解析可选来检查并解析它的值：</p>


<pre><code>if let definiteString = assumedString {
    println(definiteString)
}
// 输出 "An implicitly unwrapped optional string."
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果一个变量之后可能变成<code>nil</code>的话请不要使用隐式解析可选。如果你需要在变量的生命周期中判断是否是<code>nil</code>的话，请使用普通可选类型。</p>
</blockquote>


<p><a name="assertions"></a></p>


<h2 id="-">断言</h2>


<p>可选可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能并不需要继续执行。这时，你可以在你的代码中触发一个<em>断言（assertion）</em>来结束代码运行并通过调试来找到值缺失的原因。</p>


<h3 id="-">使用断言进行调试</h3>


<p>断言会在运行时判断一个逻辑条件是否为<code>true</code>。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为<code>true</code>，代码运行会继续进行；如果条件判断为<code>false</code>，代码运行停止，你的应用被终止。</p>


<p>如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>


<p>你可以使用全局<code>assert</code>函数来写一个断言。向<code>assert</code>函数传入一个结果为<code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式为<code>false</code>的时候这条信息会被显示：</p>


<pre><code>let age = -3
assert(age &gt;= 0, "A person's age cannot be less than zero")
// 因为 age &lt; 0，所以断言会触发
</code></pre>


<p>在这个例子中，只有<code>age &gt;= 0</code>为<code>true</code>的时候代码运行才会继续，也就是说，当<code>age</code>的值非负的时候。如果<code>age</code>的值是负数，就像代码中那样，<code>age &gt;= 0</code>为<code>false</code>，断言被触发，结束应用。</p>


<p>断言信息不能使用字符串插值。断言信息可以省略，就像这样：</p>


<pre><code>assert(age &gt;= 0)
</code></pre>


<h3 id="-">何时使用断言</h3>


<p>当条件可能为假时使用断言，但是最终一定要<em>保证</em>条件为真，这样你的代码才能继续运行。断言的适用情景：</p>


<ul>
<li>整数的附属脚本索引被传入一个自定义附属脚本实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>值。</li>
</ul>


<p>请参考<a href="12_Subscripts.html">附属脚本</a>和<a href="06_Functions.html">函数</a>。</p>


<blockquote>
<p>注意：</p>
<p>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift自动引用计数]]></title>
    <link href="http://baxiang123.com//blog/Swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift自动引用计数</id>
    <content type="html"><![CDATA[<p>Swift 使用自动引用计数（ARC）这一机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 的内存管理机制会一直起着作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>


<p>然而，在少数情况下，ARC 为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用 ARC 来管理你的应用程序的内存。</p>


<!-- more -->


<blockquote>
<p>注意:</p>
<p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
</blockquote>


<p><a name="how_arc_works"></a></p>


<h2 id="-">自动引用计数的工作机制</h2>


<p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>


<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>


<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为一，ARC都不会销毁这个实例。</p>


<p>为了使之成为可能，无论你将实例赋值给属性，常量或者是变量，属性，常量或者变量，都会对此实例创建强引用。之所以称之为强引用，是因为它会将实例牢牢的保持住，只要强引用还在，实例是不允许被销毁的。</p>


<p><a name="arc_in_action"></a></p>


<h2 id="-">自动引用计数实战</h2>


<p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的<code>Person</code>类开始，并定义了一个叫<code>name</code>的常量属性：</p>


<pre><code>    class Person {
        let name: String

            init(name: String) {
            self.name = name
            println("\(name) is being initialized")
        }

            deinit {
            println("\(name) is being deinitialized")
        }
    }
</code></pre>


<p><code>Person</code>类有一个构造函数，此构造函数为实例的<code>name</code>属性赋值并打印出信息，以表明初始化过程生效。<code>Person</code>类同时也拥有析构函数，同样会在实例被销毁的时候打印出信息。</p>


<p>接下来的代码片段定义了三个类型为<code>Person?</code>的变量，用来按照代码片段中的顺序，为新的<code>Person</code>实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为<code>nil</code>，目前还不会引用到<code>Person</code>类的实例。</p>


<pre><code>    var reference1: Person?
    var reference2: Person?
    var reference3: Person?
</code></pre>


<p>现在你可以创建<code>Person</code>类的新实例，并且将它赋值给三个变量其中的一个：</p>


<pre><code>    reference1 = Person(name: "John Appleseed")
    // prints "John Appleseed is being initialized”
</code></pre>


<p>应当注意到当你调用<code>Person</code>类的构造函数的时候，&#8221;John Appleseed is being initialized”会被打印出来。由此可以确定构造函数被执行。</p>


<p>由于<code>Person</code>类的新实例被赋值给了<code>reference1</code>变量，所以<code>reference1</code>到<code>Person</code>类的新实例之间建立了一个强引用。正是因为这个强引用，ARC 会保证<code>Person</code>实例被保持在内存中不被销毁。</p>


<p>如果你将同样的<code>Person</code>实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>


<pre><code>    reference2 = reference1
    reference3 = reference1
</code></pre>


<p>现在这个<code>Person</code>实例已经有三个强引用了。</p>


<p>如果你通过给两个变量赋值<code>nil</code>的方式断开两个强引用（）包括最先的那个强引用），只留下一个强引用，<code>Person</code>实例不会被销毁：</p>


<pre><code>reference2 = reference1
reference3 = reference1
</code></pre>


<p>ARC 会在第三个，也即最后一个强引用被断开的时候，销毁<code>Person</code>实例，这也意味着你不再使用这个<code>Person</code>实例：</p>


<pre><code>reference3 = nil
// prints "John Appleseed is being deinitialized"
</code></pre>


<p><a name="strong_reference_cycles_between_class_instances"></a></p>


<h2 id="-">类实例之间的循环强引用</h2>


<p>在上面的例子中，ARC 会跟踪你所新创建的<code>Person</code>实例的引用数量，并且会在<code>Person</code>实例不再被需要时销毁它。</p>


<p>然而，我们可能会写出这样的代码，一个类永远不会有0个强引用。这种情况发生在两个类实例互相保持对方的强引用，并让对方不被销毁。这就是所谓的循环强引用。</p>


<p>你可以通过定义类之间的关系为弱引用或者无主引用，以此替代强引用，从而解决循环强引用的问题。具体的过程在<a href="#1">解决类实例之间的循环强引用</a>中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>


<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民:</p>


<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { println("\(name) is being deinitialized") }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    var tenant: Person?
    deinit { println("Apartment #\(number) is being deinitialized") }
}
</code></pre>


<p>每一个<code>Person</code>实例有一个类型为<code>String</code>，名字为<code>name</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>


<p>类似的，每个<code>Apartment</code>实例有一个叫<code>number</code>，类型为<code>Int</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>


<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓<code>Person</code>和<code>Apartment</code>的实例是否像预期的那样被销毁。</p>


<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>number73</code>,并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，并为可选的：</p>


<pre><code>var john: Person?
var number73: Apartment?
</code></pre>


<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将类实例赋值给<code>john</code>和<code>number73</code>变量：</p>


<pre><code>john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)
</code></pre>


<p>在两个实例被创建和赋值后，下图表面了强引用的关系。变量<code>john</code>现在有一个指向<code>Person</code>实例的强引用，而变量<code>number73</code>有一个指向<code>Apartment</code>实例的强引用：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt=""></p>


<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量<code>john</code>和<code>number73</code>中的实例，这样实例的属性才能被赋值：</p>


<pre><code>john!.apartment = number73
number73!.tenant = john
</code></pre>


<p>在将两个实例联系在一起之后，强引用的关系如图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt=""></p>


<p>不幸的是，将这两个实例关联在一起之后，一个循环强引用被创建了。<code>Person</code>实例现在有了一个指向<code>Apartment</code>实例的强引用，而<code>Apartment</code>实例也有了一个指向<code>Person</code>实例的强引用。因此，当你断开<code>john</code>和<code>number73</code>变量所持有的强引用时，引用计数并不会降为 0，实例也不会被 ARC 销毁：</p>


<pre><code>john = nil
number73 = nil
</code></pre>


<p>注意，当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。强引用循环阻止了<code>Person</code>和<code>Apartment</code>类实例的销毁，并在你的应用程序中造成了内存泄漏。</p>


<p>在你将<code>john</code>和<code>number73</code>赋值为<code>nil</code>后，强引用关系如下图：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt=""></p>


<p><code>Person</code>和<code>Apartment</code>实例之间的强引用关系保留了下来并且不会被断开。</p>


<p><a name="resolving_strong_reference_cycles_between_class_instances"></a></p>


<h2 id="-a-name-1-a-"><a name="1">解决实例之间的循环强引用</a></h2>


<p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>


<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>


<p>对于生命周期中会变为<code>nil</code>的实例使用弱引用。相反的，对于初始化赋值后再也不会被赋值为<code>nil</code>的实例，使用无主引用。</p>


<h3 id="-">弱引用</h3>


<p>弱引用不会牢牢保持住引用的实例，并且不会阻止 ARC 销毁被引用的实例。这种行为阻止了引用变为循环强引用。声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。</p>


<p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以阻止循环强引用。如果引用总是有值，则可以使用无主引用，在<a href="#2">无主引用</a>中有描述。在上面<code>Apartment</code>的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。</p>


<blockquote>
<p>注意:</p>
<p>弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。</p>
</blockquote>


<p>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。可选类型是在 Swift 语言中推荐的用来表示可能没有值的类型。</p>


<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为<code>nil</code>。你可以像其他可选值一样，检查弱引用的值是否存在，你永远也不会遇到被销毁了而不存在的实例。</p>


<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>


<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { println("\(name) is being deinitialized") }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    weak var tenant: Person?
    deinit { println("Apartment #\(number) is being deinitialized") }
}
</code></pre>


<p>然后跟之前一样，建立两个变量（john和number73）之间的强引用，并关联两个实例：</p>


<pre><code>var john: Person?
var number73: Apartment?

john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)

john!.apartment = number73
number73!.tenant = john
</code></pre>


<p>现在，两个关联在一起的实例的引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt=""></p>


<p><code>Person</code>实例依然保持对<code>Apartment</code>实例的强引用，但是<code>Apartment</code>实例只是对<code>Person</code>实例的弱引用。这意味着当你断开<code>john</code>变量所保持的强引用时，再也没有指向<code>Person</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt=""></p>


<p>由于再也没有指向<code>Person</code>实例的强引用，该实例会被销毁：</p>


<pre><code>john = nil
// prints "John Appleseed is being deinitialized"
</code></pre>


<p>唯一剩下的指向<code>Apartment</code>实例的强引用来自于变量<code>number73</code>。如果你断开这个强引用，再也没有指向<code>Apartment</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt=""></p>


<p>由于再也没有指向<code>Apartment</code>实例的强引用，该实例也会被销毁：</p>


<pre><code>number73 = nil
// prints "Apartment #73 is being deinitialized"
</code></pre>


<p>上面的两段代码展示了变量<code>john</code>和<code>number73</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>


<h3 id="-a-name-2-a-"><a name="2">无主引用</a></h3>


<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>


<p>由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为<code>nil</code>，因为非可选类型的变量不允许被赋值为<code>nil</code>。</p>


<blockquote>
<p>注意:
如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。</p>
<p>还需要注意的是如果你试图访问实例已经被销毁的无主引用，程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。</p>
</blockquote>


<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系会潜在的创造循环强引用。</p>


<p><code>Customer</code>和<code>CreditCard</code>之间的关系与前面弱引用例子中<code>Apartment</code>和<code>Person</code>的关系截然不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code>类有一个可选类型的<code>card</code>属性，但是<code>CreditCard</code>类有一个非可选类型的<code>customer</code>属性。</p>


<p>此外，只能通过将一个<code>number</code>值和<code>customer</code>实例传递给<code>CreditCard</code>构造函数的方式来创建<code>CreditCard</code>实例。这样可以确保当创建<code>CreditCard</code>实例时总是有一个<code>customer</code>实例与之关联。</p>


<p>由于信用卡总是关联着一个客户，因此将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>


<pre><code>class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { println("\(name) is being deinitialized") }
}

class CreditCard {
    let number: Int
    unowned let customer: Customer
    init(number: Int, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { println("Card #\(number) is being deinitialized") }
}
</code></pre>


<p>下面的代码片段定义了一个叫<code>john</code>的可选类型<code>Customer</code>变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为<code>nil</code>。</p>


<pre><code>var john: Customer?
</code></pre>


<p>现在你可以创建<code>Customer</code>类的实例，用它初始化<code>CreditCard</code>实例，并将新创建的<code>CreditCard</code>实例赋值为客户的<code>card</code>属性。</p>


<pre><code>john = Customer(name: "John Appleseed")
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre>


<p>在你关联两个实例后，他们的引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt=""></p>


<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对<code>Customer</code>实例的无主引用。</p>


<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt=""></p>


<p>由于再也没有指向<code>Customer</code>实例的强引用，该实例被销毁了。其后，再也没有指向<code>CreditCard</code>实例的强引用，该实例也随之被销毁了：</p>


<pre><code>john = nil
// prints "John Appleseed is being deinitialized"
// prints "Card #1234567890123456 is being deinitialized"
</code></pre>


<p>最后的代码展示了在<code>john</code>变量被设为<code>nil</code>后<code>Customer</code>实例和<code>CreditCard</code>实例的构造函数都打印出了“销毁”的信息。</p>


<h3 id="-">无主引用以及显式展开的可选属性</h3>


<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>


<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>


<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。</p>


<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后不能为<code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用显示展开的可选属性。</p>


<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>


<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，而每一个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>


<pre><code>class Country {
    let name: String
    let capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre>


<p>为了建立两个类的依赖关系，<code>City</code>的构造函数有一个<code>Country</code>实例的参数，并且将实例保存为<code>country</code>属性。</p>


<p><code>Country</code>的构造函数调用了<code>City</code>的构造函数。然而，只有<code>Country</code>的实例完全初始化完后，<code>Country</code>的构造函数才能把<code>self</code>传给<code>City</code>的构造函数。（<a href="14_Initialization.html">在两步构造函数中有具体描述</a>）</p>


<p>为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将<code>Country</code>的<code>capitalCity</code>属性声明为显示展开的可选类型属性。这表示像其他可选类型一样，<code>capitalCity</code>属性的默认值为<code>nil</code>，但是不需要展开他的值就能访问它。（<a href="01_The_Basics.html">在显示展开的可选类型中有描述</a>）</p>


<p>由于<code>capitalCity</code>默认值为<code>nil</code>，一旦<code>Country</code>的实例在构造函数中给<code>name</code>属性赋值后，整个初始化过程就完成了。这代表一旦<code>name</code>属性被后，<code>Country</code>的构造函数就能引用并传递显式的<code>self</code>。<code>Country</code>的构造函数在赋值<code>capitalCity</code>时，就能将<code>self</code>作为参数传递给<code>City</code>的构造函数。</p>


<p>以上的意义在于你可以通过一条语句同时创建<code>Country</code>和<code>City</code>的实例，而不产生循环强引用，并且<code>capitalCity</code>的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>


<pre><code>var country = Country(name: "Canada", capitalName: "Ottawa")
println("\(country.name)'s capital city is called \(country.capitalCity.name)")
// prints "Canada's capital city is called Ottawa"
</code></pre>


<p>在上面的例子中，使用显示展开可选值的意义在于满足了两个类构造函数的需求。<code>capitalCity</code>属性在初始化完成后，能作为非可选值使用同事还避免了循环强引用。</p>


<p><a name="strong_reference_cycles_for_closures"></a></p>


<h2 id="-">闭包引起的循环强引用</h2>


<p>前面我们看到了循环强引用环是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破循环强引用。</p>


<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod</code>。这两种情况都导致了闭包 “捕获&#8221; <code>self</code>，从而产生了循环强引用。</p>


<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你也把一个引用赋值给了这个闭包。实质上，这跟之前的问题是一样的－两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>


<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包占用列表（closuer capture list）。同样的，在学习如何用闭包占用列表破坏循环强引用之前，先来了解一下循环强引用是如何产生的，这对我们是很有帮助的。</p>


<p>下面的例子为你展示了当一个闭包引用了<code>self</code>后是如何产生一个循环强引用的。例子中定义了一个叫<code>HTMLElement</code>的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>


<pre><code>class HTMLElement {

    let name: String
    let text: String?

    @lazy var asHTML: () -&gt; String = {
        if let text = self.text {
            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println("\(name) is being deinitialized")
    }

}
</code></pre>


<p><code>HTMLElement</code>类定义了一个<code>name</code>属性来表示这个元素的名称，例如代表段落的&#8221;p&#8221;，或者代表换行的&#8221;br&#8221;。<code>HTMLElement</code>还定义了一个可选属性<code>text</code>，用来设置和展现 HTML 元素的文本。</p>


<p>除了上面的两个属性，<code>HTMLElement</code>还定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个闭包，将<code>name</code>和<code>text</code>组合成 HTML 字符串片段。该属性是<code>() -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。</p>


<p>默认情况下，闭包赋值给了<code>asHTML</code>属性，这个闭包返回一个代表 HTML 标签的字符串。如果<code>text</code>值存在，该标签就包含可选值<code>text</code>；如果<code>text</code>不存在，该标签就不包含文本。对于段落元素，根据<code>text</code>是&#8221;some text&#8221;还是<code>nil</code>，闭包会返回&#8221;<code>&lt;p&gt;some text&lt;/p&gt;</code>&#8220;或者&#8221;<code>&lt;p /&gt;</code>&#8220;。</p>


<p>可以像实例方法那样去命名、使用<code>asHTML</code>属性。然而，由于<code>asHTML</code>是闭包而不是实例方法，如果你想改变特定元素的 HTML 处理的话，可以用自定义的闭包来取代默认值。</p>


<blockquote>
<p>注意:</p>
<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>


<p><code>HTMLElement</code>类只提供一个构造函数，通过<code>name</code>和<code>text</code>（如果有的话）参数来初始化一个元素。该类也定义了一个析构函数，当<code>HTMLElement</code>实例被销毁时，打印一条消息。</p>


<p>下面的代码展示了如何用<code>HTMLElement</code>类创建实例并打印消息。</p>


<pre><code>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints"hello, world"
</code></pre>


<blockquote>
<p>注意:</p>
<p>上面的<code>paragraph</code>变量定义为<code>可选HTMLElement</code>，因此我们可以赋值<code>nil</code>给它来演示循环强引用。</p>
</blockquote>


<p>不幸的是，上面写的<code>HTMLElement</code>类产生了类实例和<code>asHTML</code>默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt=""></p>


<p>实例的<code>asHTML</code>属性持有闭包的强引用。但是，闭包在其闭包体内使用了<code>self</code>（引用了<code>self.name</code>和<code>self.text</code>），因此闭包占有了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包占有值的信息，请参考<a href="07_Closures.html">值捕获</a>）。</p>


<blockquote>
<p>注意:</p>
<p>虽然闭包多次使用了<code>self</code>，它只占有<code>HTMLElement</code>实例的一个强引用。</p>
</blockquote>


<p>如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为循环强引用：</p>


<pre><code>paragraph = nil
</code></pre>


<p>注意<code>HTMLElementdeinitializer</code>中的消息并没有别打印，证明了<code>HTMLElement</code>实例并没有被销毁。</p>


<h2 id="-">解决闭包引起的循环强引用</h2>


<p>在定义闭包时同时定义占有列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。占有列表定义了闭包体内占有一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个占有的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>


<blockquote>
<p>注意:</p>
<p>Swift 有如下要求：只要在闭包内使用<code>self</code>的成员，就要用<code>self.someProperty</code>或者<code>self.someMethod</code>（而不只是<code>someProperty</code>或<code>someMethod</code>）。这提醒你可能会不小心就占有了<code>self</code>。</p>
</blockquote>


<h3 id="-">定义占有列表</h3>


<p>占有列表中的每个元素都是由<code>weak</code>或者<code>unowned</code>关键字和实例的引用（如<code>self</code>或<code>someInstance</code>）成对组成。每一对都在花括号中，通过逗号分开。</p>


<p>占有列表放置在闭包参数列表和返回类型之前：</p>


<pre><code>@lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre>


<p>如果闭包没有指定参数列表或者返回类型，则可以通过上下文推断，那么可以占有列表放在闭包开始的地方，跟着是关键字<code>in</code>：</p>


<pre><code>@lazy var someClosure: () -&gt; String = {
    [unowned self] in
    // closure body goes here
}
</code></pre>


<h3 id="-">弱引用和无主引用</h3>


<p>当闭包和占有的实例总是互相引用时并且总是同时销毁时，将闭包内的占有定义为无主引用。</p>


<p>相反的，当占有引用有时可能会是<code>nil</code>时，将闭包内的占有定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为<code>nil</code>。这使我们可以在闭包内检查他们是否存在。</p>


<blockquote>
<p>注意:</p>
<p>如果占有的引用绝对不会置为<code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>


<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样这样编写<code>HTMLElement</code>类来避免循环强引用：</p>


<pre><code>class HTMLElement {

    let name: String
    let text: String?

    @lazy var asHTML: () -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println("\(name) is being deinitialized")
    }

}
</code></pre>


<p>上面的<code>HTMLElement</code>实现和之前的实现一致，只是在<code>asHTML</code>闭包中多了一个占有列表。这里，占有列表是<code>[unowned self]</code>，表示“用无主引用而不是强引用来占有<code>self</code>”。</p>


<p>和之前一样，我们可以创建并打印<code>HTMLElement</code>实例：</p>


<pre><code>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints "&lt;p&gt;hello, world&lt;/p&gt;"
</code></pre>


<p>使用占有列表后引用关系如下图所示：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt=""></p>


<p>这一次，闭包以无主引用的形式占有<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息。</p>


<pre><code>paragraph = nil
// prints "p is being deinitialized"
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift继承]]></title>
    <link href="http://baxiang123.com//blog/Swift%E7%BB%A7%E6%89%BF.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift继承</id>
    <content type="html"><![CDATA[<p>一个类可以<em>继承（inherit）</em>另一个类的方法（methods），属性（property）和其它特性。当一个类继承其它类时，继承类叫<em>子类（subclass）</em>，被继承类叫<em>超类（或父类，superclass）</em>。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>


<!-- more -->


<p>在 Swift 中，类可以调用和访问超类的方法，属性和附属脚本（subscripts），并且可以重写（override）这些方法，属性和附属脚本来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>


<p>可以为类中继承来的属性添加属性观察器（property observer），这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性（stored property）还是计算型属性（computed property）。</p>


<p><a name="defining_a_base_class"></a></p>


<h2 id="-base-class-">定义一个基类（Base class）</h2>


<p>不继承于其它类的类，称之为<em>基类（base calss）</em>。</p>


<blockquote>
<p>注意：</p>
<p>Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>
</blockquote>


<p>下面的例子定义了一个叫<code>Vehicle</code>的基类。这个基类声明了两个对所有车辆都通用的属性（<code>numberOfWheels</code>和<code>maxPassengers</code>）。这些属性在<code>description</code>方法中使用，这个方法返回一个<code>String</code>类型的，对车辆特征的描述：</p>


<pre><code>class Vehicle {
    var numberOfWheels: Int
    var maxPassengers: Int
    func description() -&gt; String {
        return "\(numberOfWheels) wheels; up to \(maxPassengers) passengers"
    }
    init() {
        numberOfWheels = 0
        maxPassengers = 1
    }
}
</code></pre>


<p><code>Vehicle</code>类定义了<em>构造器（initializer）</em>来设置属性的值。构造器会在<a href="../chapter2/_14Initialization.html">构造过程</a>一节中详细介绍，这里我们做一下简单介绍，以便于讲解子类中继承来的属性如何被修改。</p>


<p>构造器用于创建某个类型的一个新实例。尽管构造器并不是方法，但在语法上，两者很相似。构造器的工作是准备新实例以供使用，并确保实例中的所有属性都拥有有效的初始化值。</p>


<p>构造器的最简单形式就像一个没有参数的实例方法，使用<code>init</code>关键字：</p>


<pre><code>init() {
    // 执行构造过程
}
</code></pre>


<p>如果要创建一个<code>Vehicle</code>类的新实例，使用<em>构造器</em>语法调用上面的初始化器，即类名后面跟一个空的小括号：</p>


<pre><code>let someVehicle = Vehicle()
</code></pre>


<p>这个<code>Vehicle</code>类的构造器为任意的一辆车设置一些初始化属性值（<code>numberOfWheels = 0</code>和<code>maxPassengers = 1</code>）。</p>


<p><code>Vehicle</code>类定义了车辆的共同特性，但这个类本身并没太大用处。为了使它更为实用，你需要进一步细化它来描述更具体的车辆。</p>


<p><a name="subclassing"></a></p>


<h2 id="-subclassing-">子类生成（Subclassing）</h2>


<p><em>子类生成（Subclassing）</em>指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以优化或改变它。你还可以为子类添加新的特性。</p>


<p>为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：</p>


<pre><code>class SomeClass: SomeSuperclass {
    // 类的定义
}
</code></pre>


<p>下一个例子，定义一个更具体的车辆类叫<code>Bicycle</code>。这个新类是在 <code>Vehicle</code>类的基础上创建起来。因此你需要将<code>Vehicle</code>类放在 <code>Bicycle</code>类后面，用冒号分隔。</p>


<p>我们可以将这读作：</p>


<p>“定义一个新的类叫<code>Bicycle</code>，它继承了<code>Vehicle</code>的特性”；</p>


<pre><code>class Bicycle: Vehicle {
    init() {
        super.init()
        numberOfWheels = 2
    }
}
</code></pre>


<p> <code>Bicycle</code>是<code>Vehicle</code>的子类，<code>Vehicle</code>是<code>Bicycle</code>的超类。新的<code>Bicycle</code>类自动获得<code>Vehicle</code>类的特性，比如 <code>maxPassengers</code>和<code>numberOfWheels</code>属性。你可以在子类中定制这些特性，或添加新的特性来更好地描述<code>Bicycle</code>类。</p>


<p><code>Bicycle</code>类定义了一个构造器来设置它定制的特性（自行车只有2个轮子）。<code>Bicycle</code>的构造器调用了它父类<code>Vehicle</code>的构造器 <code>super.init()</code>，以此确保在<code>Bicycle</code>类试图修改那些继承来的属性前<code>Vehicle</code>类已经初始化过它们了。</p>


<blockquote>
<p>注意：</p>
<p>不像 Objective-C，在 Swift 中，初始化器默认是不继承的，见<a href="../chapter2/_14Initialization.html#initializer_inheritance_and_ overriding">初始化器的继承与重写</a></p>
</blockquote>


<p><code>Vehicle</code>类中<code>maxPassengers</code>的默认值对自行车来说已经是正确的，因此在<code>Bicycle</code>的构造器中并没有改变它。而<code>numberOfWheels</code>原来的值对自行车来说是不正确的，因此在初始化器中将它更改为 2。</p>


<p><code>Bicycle</code>不仅可以继承<code>Vehicle</code>的属性，还可以继承它的方法。如果你创建了一个<code>Bicycle</code>类的实例，你就可以调用它继承来的<code>description</code>方法，并且可以看到，它输出的属性值已经发生了变化：</p>


<pre><code>let bicycle = Bicycle()
println("Bicycle: \(bicycle.description())")
// Bicycle: 2 wheels; up to 1 passengers
</code></pre>


<p>子类还可以继续被其它类继承：</p>


<pre><code>class Tandem: Bicycle {
    init() {
        super.init()
        maxPassengers = 2
    }
}
</code></pre>


<p>上面的例子创建了<code>Bicycle</code>的一个子类：双人自行车（tandem）。<code>Tandem</code>从<code>Bicycle</code>继承了两个属性，而这两个属性是<code>Bicycle</code>从<code>Vehicle</code>继承而来的。<code>Tandem</code>并不修改轮子的数量，因为它仍是一辆自行车，有 2 个轮子。但它需要修改<code>maxPassengers</code>的值，因为双人自行车可以坐两个人。</p>


<blockquote>
<p>注意：</p>
<p>子类只允许修改从超类继承来的变量属性，而不能修改继承来的常量属性。</p>
</blockquote>


<p>创建一个<code>Tandem</code>类的实例，打印它的描述，即可看到它的属性已被更新：</p>


<pre><code>let tandem = Tandem()
println("Tandem: \(tandem.description())")
// Tandem: 2 wheels; up to 2 passengers
</code></pre>


<p>注意，<code>Tandem</code>类也继承了<code>description</code>方法。一个类的实例方法会被这个类的所有子类继承。</p>


<p><a name="overriding"></a></p>


<h2 id="-overriding-">重写（Overriding）</h2>


<p>子类可以为继承来的实例方法（instance method），类方法（class method），实例属性（instance property），或附属脚本（subscript）提供自己定制的实现（implementation）。我们把这种行为叫<em>重写（overriding）</em>。</p>


<p>如果要重写某个特性，你需要在重写定义的前面加上<code>override</code>关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少<code>override</code>关键字的重写都会在编译时被诊断为错误。</p>


<p><code>override</code>关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>


<h3 id="-">访问超类的方法，属性及附属脚本</h3>


<p>当你在子类中重写超类的方法，属性或附属脚本时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以优化已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>


<p>在合适的地方，你可以通过使用<code>super</code>前缀来访问超类版本的方法，属性或附属脚本：</p>


<ul>
<li>在方法<code>someMethod</code>的重写实现中，可以通过<code>super.someMethod()</code>来调用超类版本的<code>someMethod</code>方法。</li>
<li>在属性<code>someProperty</code>的 getter 或 setter 的重写实现中，可以通过<code>super.someProperty</code>来访问超类版本的<code>someProperty</code>属性。</li>
<li>在附属脚本的重写实现中，可以通过<code>super[someIndex]</code>来访问超类版本中的相同附属脚本。</li>
</ul>


<h3 id="-">重写方法</h3>


<p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。</p>


<p>下面的例子定义了<code>Vehicle</code>的一个新的子类，叫<code>Car</code>，它重写了从<code>Vehicle</code>类继承来的<code>description</code>方法：</p>


<pre><code>class Car: Vehicle {
    var speed: Double = 0.0
    init() {
        super.init()
        maxPassengers = 5
        numberOfWheels = 4
    }
    override func description() -&gt; String {
        return super.description() + "; "
            + "traveling at \(speed) mph"
    }
}
</code></pre>


<p><code>Car</code>声明了一个新的存储型属性<code>speed</code>，它是<code>Double</code>类型的，默认值是<code>0.0</code>，表示“时速是0英里”。<code>Car</code>有自己的初始化器，它将乘客的最大数量设为5，轮子数量设为4。</p>


<p><code>Car</code>重写了继承来的<code>description</code>方法，它的声明与<code>Vehicle</code>中的<code>description</code>方法一致，声明前面加上了<code>override</code>关键字。</p>


<p><code>Car</code>中的<code>description</code>方法并非完全自定义，而是通过<code>super.description</code>使用了超类<code>Vehicle</code>中的<code>description</code>方法，然后再追加一些额外的信息，比如汽车的当前速度。</p>


<p>如果你创建一个<code>Car</code>的新实例，并打印<code>description</code>方法的输出，你就会发现描述信息已经发生了改变：</p>


<pre><code>let car = Car()
println("Car: \(car.description())")
// Car: 4 wheels; up to 5 passengers; traveling at 0.0 mph
</code></pre>


<h3 id="-">重写属性</h3>


<p>你可以重写继承来的实例属性或类属性，提供自己定制的getter和setter，或添加属性观察器使重写的属性观察属性值什么时候发生改变。</p>


<h4 id="-getters-setters">重写属性的Getters和Setters</h4>


<p>你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。</p>


<p>你可以将一个继承来的只读属性重写为一个读写属性，只需要你在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。</p>


<blockquote>
<p>注意：</p>
<p>如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接返回<code>super.someProperty</code>来返回继承来的值。正如下面的<code>SpeedLimitedCar</code>的例子所示。</p>
</blockquote>


<p>以下的例子定义了一个新类，叫<code>SpeedLimitedCar</code>，它是<code>Car</code>的子类。类<code>SpeedLimitedCar</code>表示安装了限速装置的车，它的最高速度只能达到40mph。你可以通过重写继承来的<code>speed</code>属性来实现这个速度限制：</p>


<pre><code>class SpeedLimitedCar: Car {
    override var speed: Double  {
    get {
        return super.speed
    }
    set {
        super.speed = min(newValue, 40.0)
    }
    }
}
</code></pre>


<p>当你设置一个<code>SpeedLimitedCar</code>实例的<code>speed</code>属性时，属性setter的实现会去检查新值与限制值40mph的大小，它会将超类的<code>speed</code>设置为<code>newValue</code>和<code>40.0</code>中较小的那个。这两个值哪个较小由<code>min</code>函数决定，它是Swift标准库中的一个全局函数。<code>min</code>函数接收两个或更多的数，返回其中最小的那个。</p>


<p>如果你尝试将<code>SpeedLimitedCar</code>实例的<code>speed</code>属性设置为一个大于40mph的数，然后打印<code>description</code>函数的输出，你会发现速度被限制在40mph：</p>


<pre><code>let limitedCar = SpeedLimitedCar()
limitedCar.speed = 60.0
println("SpeedLimitedCar: \(limitedCar.description())")
// SpeedLimitedCar: 4 wheels; up to 5 passengers; traveling at 40.0 mph
</code></pre>


<h4 id="-property-observer-">重写属性观察器（Property Observer）</h4>


<p>你可以在属性重写中为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。关于属性观察器的更多内容，请看<a href="../chapter2/_10Properties.html#property_observer">属性观察器</a>。</p>


<blockquote>
<p>注意：</p>
<p>你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供<code>willSet</code>或<code>didSet</code>实现是不恰当。此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>
</blockquote>


<p>下面的例子定义了一个新类叫<code>AutomaticCar</code>，它是<code>Car</code>的子类。<code>AutomaticCar</code>表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位。<code>AutomaticCar</code>也提供了定制的<code>description</code>方法，可以输出当前挡位。</p>


<pre><code>class AutomaticCar: Car {
    var gear = 1
    override var speed: Double {
    didSet {
        gear = Int(speed / 10.0) + 1
    }
    }
    override func description() -&gt; String {
        return super.description() + " in gear \(gear)"
    }
}
</code></pre>


<p>当你设置<code>AutomaticCar</code>的<code>speed</code>属性，属性的<code>didSet</code>观察器就会自动地设置<code>gear</code>属性，为新的速度选择一个合适的挡位。具体来说就是，属性观察器将新的速度值除以10，然后向下取得最接近的整数值，最后加1来得到档位<code>gear</code>的值。例如，速度为10.0时，挡位为1；速度为35.0时，挡位为4：</p>


<pre><code>let automatic = AutomaticCar()
automatic.speed = 35.0
println("AutomaticCar: \(automatic.description())")
// AutomaticCar: 4 wheels; up to 5 passengers; traveling at 35.0 mph in gear 4
</code></pre>


<p><a name="preventing_overrides"></a></p>


<h2 id="-">防止重写</h2>


<p>你可以通过把方法，属性或附属脚本标记为<em><code>final</code></em>来防止它们被重写，只需要在声明关键字前加上<code>@final</code>特性即可。（例如：<code>@final var</code>, <code>@final func</code>, <code>@final class func</code>, 以及 <code>@final subscript</code>）</p>


<p>如果你重写了<code>final</code>方法，属性或附属脚本，在编译时会报错。在扩展中，你添加到类里的方法，属性或附属脚本也可以在扩展的定义里标记为 final。</p>


<p>你可以通过在关键字<code>class</code>前添加<code>@final</code>特性（<code>@final class</code>）来将整个类标记为 final 的，这样的类是不可被继承的，否则会报编译错误。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift类型检查]]></title>
    <link href="http://baxiang123.com//blog/Swift%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift类型检查</id>
    <content type="html"><![CDATA[<p>  <em>类型检查</em>是一种检查类实例的方式，并且或者也是让实例作为它的父类或者子类的一种方式。</p>


<p>  类型检查在 Swift 中使用<code>is</code> 和 <code>as</code>操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p>


<!-- more -->


<p>  你也可以用来检查一个类是否实现了某个协议，就像在 <a href="Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_363">Protocols Checking for Protocol Conformance</a>部分讲述的一样。</p>


<p><a name="defining_a_class_hierarchy_for_type_casting"></a></p>


<h2 id="-">定义一个类层次作为例子</h2>


<p>  你可以将它用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。这下面的三个代码段定义了一个类层次和一个包含了几个这些类实例的数组，作为类型检查的例子。</p>


<p>  第一个代码片段定义了一个新的基础类<code>MediaItem</code>。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 <code>String</code> 类型的 <code>name</code> 属性，和一个<code>init name</code>初始化器。（它假定所有的媒体项都有个名称。）</p>


<pre><code>class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}
</code></pre>


<p>  下一个代码段定义了 <code>MediaItem</code> 的两个子类。第一个子类<code>Movie</code>，在父类（或者说基类）的基础上增加了一个 <code>director</code>（导演） 属性，和相应的初始化器。第二个类在父类的基础上增加了一个 <code>artist</code>（艺术家） 属性，和相应的初始化器：</p>


<pre><code>class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}
</code></pre>


<p>  最后一个代码段创建了一个数组常量 <code>library</code>
  ，包含两个<code>Movie</code>实例和三个<code>Song</code>实例。<code>library</code>的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够演绎出<code>Movie</code> 和 <code>Song</code> 有共同的父类 <code>MediaItem</code> ，所以它推断出 <code>MediaItem[]</code> 类作为 <code>library</code> 的类型。</p>


<pre><code>let library = [
Movie(name: "Casablanca", director: "Michael Curtiz"),
Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
Movie(name: "Citizen Kane", director: "Orson Welles"),
Song(name: "The One And Only", artist: "Chesney Hawkes"),
Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
]
// the type of "library" is inferred to be MediaItem[]
</code></pre>


<p>  在幕后<code>library</code> 里存储的媒体项依然是 <code>Movie</code> 和 <code>Song</code> 类型的，但是，若你迭代它，取出的实例会是 <code>MediaItem</code> 类型的，而不是 <code>Movie</code> 和 <code>Song</code> 类型的。为了让它们作为它们本来的类型工作，你需要检查它们的类型或者向下转换它们的类型到其它类型，就像下面描述的一样。</p>


<p><a name="checking_type"></a></p>


<h2 id="-">检查类型</h2>


<p>  用类型检查操作符(<code>is</code>)来检查一个实例是否属于特定子类型。类型检查操作符返回 <code>true</code> 若实例属于那个子类型，若不属于返回 <code>false</code> 。</p>


<p>  下面的例子定义了两个变量，<code>movieCount</code> 和 <code>songCount</code>，用来计算数组<code>library</code> 中 <code>Movie</code> 和 <code>Song</code> 类型的实例数量。</p>


<pre><code>var movieCount = 0
var songCount = 0

for item in library {
    if item is Movie {
        ++movieCount
    } else if item is Song {
        ++songCount
    }
}

println("Media library contains \(movieCount) movies and \(songCount) songs")
// prints "Media library contains 2 movies and 3 songs"
</code></pre>


<p>  示例迭代了数组 <code>library</code> 中的所有项。每一次， <code>for</code>-<code>in</code> 循环设置
  <code>item</code> 为数组中的下一个 <code>MediaItem</code>。</p>


<p>  若当前 <code>MediaItem</code> 是一个 <code>Movie</code> 类型的实例， <code>item is Movie</code> 返回
  <code>true</code>，相反返回 <code>false</code>。同样的，<code>item is
  Song</code>检查item是否为<code>Song</code>类型的实例。在循环结束后，<code>movieCount</code> 和 <code>songCount</code>的值就是被找到属于各自的类型的实例数量。</p>


<p><a name="downcasting"></a></p>


<h2 id="-downcasting-">向下转型（Downcasting）</h2>


<p>  某类型的一个常量或变量可能在幕后实际上属于一个子类。你可以相信，上面就是这种情况。你可以尝试向下转到它的子类型，用类型检查操作符(<code>as</code>)</p>


<p>  因为向下转型可能会失败，类型检查操作符带有两种不同形式。可选形式（ optional form） <code>as?</code> 返回一个你试图下转成的类型的可选值（optional value）。强制形式 <code>as</code> 把试图向下转型和强制解包（force-unwraps）结果作为一个混合动作。</p>


<p>  当你不确定下转可以成功时，用类型检查的可选形式(<code>as?</code>)。可选形式的类型检查总是返回一个可选值（optional value），并且若下转是不可能的，可选值将是 <code>nil</code> 。这使你能够检查下转是否成功。</p>


<p>  只有你可以确定下转一定会成功时，才使用强制形式。当你试图下转为一个不正确的类型时，强制形式的类型检查会触发一个运行时错误。</p>


<p>  下面的例子，迭代了<code>library</code>里的每一个 <code>MediaItem</code> ，并打印出适当的描述。要这样做，<code>item</code>需要真正作为<code>Movie</code> 或 <code>Song</code>的类型来使用。不仅仅是作为 <code>MediaItem</code>。为了能够使用<code>Movie</code> 或 <code>Song</code>的 <code>director</code> 或 <code>artist</code>属性，这是必要的。</p>


<p>  在这个示例中，数组中的每一个<code>item</code>可能是 <code>Movie</code> 或 <code>Song</code>。   事前你不知道每个<code>item</code>的真实类型，所以这里使用可选形式的类型检查 （<code>as?</code>）去检查循环里的每次下转。</p>


<pre><code>for item in library {
    if let movie = item as? Movie {
        println("Movie: '\(movie.name)', dir. \(movie.director)")
    } else if let song = item as? Song {
        println("Song: '\(song.name)', by \(song.artist)")
    }
}

// Movie: 'Casablanca', dir. Michael Curtiz
// Song: 'Blue Suede Shoes', by Elvis Presley
// Movie: 'Citizen Kane', dir. Orson Welles
// Song: 'The One And Only', by Chesney Hawkes
// Song: 'Never Gonna Give You Up', by Rick Astley
</code></pre>


<p>  示例首先试图将 <code>item</code> 下转为 <code>Movie</code>。因为 <code>item</code> 是一个 <code>MediaItem</code>
  类型的实例，它可能是一个<code>Movie</code>；同样，它可能是一个 <code>Song</code>，或者仅仅是基类
  <code>MediaItem</code>。因为不确定，<code>as?</code>形式在试图下转时将返还一个可选值。 <code>item as Movie</code> 的返回值是<code>Movie?</code>类型或 “optional <code>Movie</code>”。</p>


<p>  当下转为 <code>Movie</code> 应用在两个 <code>Song</code>
  实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 <code>Movie</code>真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“<code>if let movie = item as? Movie</code>”，可以这样解读：</p>


<p>  “尝试将 <code>item</code> 转为 <code>Movie</code>类型。若成功，设置一个新的临时常量 <code>movie</code>  来存储返回的可选<code>Movie</code>”</p>


<p>  若下转成功，然后<code>movie</code>的属性将用于打印一个<code>Movie</code>实例的描述，包括它的导演的名字<code>director</code>。当<code>Song</code>被找到时，一个相近的原理被用来检测 <code>Song</code> 实例和打印它的描述。</p>


<blockquote>
<p>注意：</p>
<p>转换没有真的改变实例或它的值。潜在的根本的实例保持不变；只是简单地把它作为它被转换成的类来使用。</p>
</blockquote>


<p><a name="type_casting_for_any_and_anyobject"></a></p>


<h2 id="-any-anyobject-"><code>Any</code>和<code>AnyObject</code>的类型检查</h2>


<p>  Swift为不确定类型提供了两种特殊类型别名：</p>


<ul>
<li><p><code>AnyObject</code>可以代表任何class类型的实例。</p>
</li>
<li><p><code>Any</code>可以表示任何类型，除了方法类型（function types）。</p>
</li>
</ul>


<blockquote>
<p>注意：</p>
<p>只有当你明确的需要它的行为和功能时才使用<code>Any</code>和<code>AnyObject</code>。在你的代码里使用你期望的明确的类型总是更好的。</p>
</blockquote>


<h3 id="-anyobject-"><code>AnyObject</code>类型</h3>


<p>  当需要在工作中使用 Cocoa
  APIs，它一般接收一个<code>AnyObject[]</code>类型的数组，或者说“一个任何对象类型的数组”。这是因为 Objective-C 没有明确的类型化数组。但是，你常常可以确定包含在仅从你知道的 API 信息提供的这样一个数组中的对象的类型。</p>


<p>  在这些情况下，你可以使用强制形式的类型检查(<code>as</code>)来下转在数组中的每一项到比 <code>AnyObject</code> 更明确的类型，不需要可选解析（optional unwrapping）。</p>


<p>  下面的示例定义了一个 <code>AnyObject[]</code> 类型的数组并填入三个<code>Movie</code>类型的实例：</p>


<pre><code>let someObjects: AnyObject[] = [
    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
    Movie(name: "Moon", director: "Duncan Jones"),
    Movie(name: "Alien", director: "Ridley Scott")
]
</code></pre>


<p>  因为知道这个数组只包含 <code>Movie</code> 实例，你可以直接用(<code>as</code>)下转并解包到不可选的<code>Movie</code>类型（ps：其实就是我们常用的正常类型，这里是为了和可选类型相对比）。</p>


<pre><code>for object in someObjects {
    let movie = object as Movie
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</code></pre>


<p>  为了变为一个更短的形式，下转<code>someObjects</code>数组为<code>Movie[]</code>类型来代替下转每一项方式。</p>


<pre><code>for movie in someObjects as Movie[] {
    println("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</code></pre>


<h3 id="-any-"><code>Any</code>类型</h3>


<p>  这里有个示例，使用 <code>Any</code> 类型来和混合的不同类型一起工作，包括非<code>class</code>类型。它创建了一个可以存储<code>Any</code>类型的数组 <code>things</code>。</p>


<pre><code>var things = Any[]()

things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))
</code></pre>


<p>  <code>things</code> 数组包含两个 <code>Int</code> 值，2个 <code>Double</code> 值，1个 <code>String</code> 值，一个元组 <code>(Double, Double)</code> ，Ivan Reitman 导演的电影“Ghostbusters”。</p>


<p>  你可以在 <code>switch</code> <code>cases</code>里用<code>is</code> 和 <code>as</code> 操作符来发觉只知道是 <code>Any</code> 或 <code>AnyObject</code>的常量或变量的类型。 下面的示例迭代 <code>things</code>数组中的每一项的并用<code>switch</code>语句查找每一项的类型。这几种<code>switch</code>语句的情形绑定它们匹配的值到一个规定类型的常量，让它们可以打印它们的值：</p>


<pre><code>for thing in things {
    switch thing {
    case 0 as Int:
        println("zero as an Int")
    case 0 as Double:
        println("zero as a Double")
    case let someInt as Int:
        println("an integer value of \(someInt)")
    case let someDouble as Double where someDouble &gt; 0:
        println("a positive double value of \(someDouble)")
    case is Double:
        println("some other double value that I don't want to print")
    case let someString as String:
        println("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        println("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        println("a movie called '\(movie.name)', dir. \(movie.director)")
    default:
        println("something else")
    }
}

// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of "hello"
// an (x, y) point at 3.0, 5.0
// a movie called 'Ghostbusters', dir. Ivan Reitman
</code></pre>


<p>。</p>


<blockquote>
<p>注意：</p>
<p>在一个switch语句的case中使用强制形式的类型检查操作符（as, 而不是 as?）来检查和转换到一个明确的类型。在 switch case 语句的内容中这种检查总是安全的。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift类型嵌套]]></title>
    <link href="http://baxiang123.com//blog/Swift%E7%B1%BB%E5%9E%8B%E5%B5%8C%E5%A5%97.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift类型嵌套</id>
    <content type="html"><![CDATA[<p>枚举类型常被用于实现特定类或结构体的功能。也能够在有多种变量类型的环境中，方便地定义通用类或结构体来使用，为了实现这种功能，Swift允许你定义类型嵌套，可以在枚举类型、类和结构体中定义支持嵌套的类型。</p>


<!-- more -->


<p>要在一个类型中嵌套另一个类型，将需要嵌套的类型的定义写在被嵌套类型的区域{}内，而且可以根据需要定义多级嵌套。</p>


<p><a name="nested_types_in_action"></a></p>


<h2 id="-">类型嵌套实例</h2>


<p>下面这个例子定义了一个结构体<code>BlackjackCard</code>(二十一点)，用来模拟<code>BlackjackCard</code>中的扑克牌点数。<code>BlackjackCard</code>结构体包含2个嵌套定义的枚举类型<code>Suit</code> 和 <code>Rank</code>。</p>


<p>在<code>BlackjackCard</code>规则中，<code>Ace</code>牌可以表示1或者11，<code>Ace</code>牌的这一特征用一个嵌套在枚举型<code>Rank</code>的结构体<code>Values</code>来表示。</p>


<pre><code>struct BlackjackCard {
    // 嵌套定义枚举型Suit
    enum Suit: Character {
       case Spades = "♠", Hearts = "♡", Diamonds = "♢", Clubs = "♣"
   }
    // 嵌套定义枚举型Rank
    enum Rank: Int {
       case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
       case Jack, Queen, King, Ace
       struct Values {
           let first: Int, second: Int?
       }
       var values: Values {
        switch self {
        case .Ace:
            return Values(first: 1, second: 11)
        case .Jack, .Queen, .King:
            return Values(first: 10, second: nil)
        default:
            return Values(first: self.toRaw(), second: nil)
            }
       }
    }
    // BlackjackCard 的属性和方法
    let rank: Rank, suit: Suit
    var description: String {
    var output = "suit is \(suit.toRaw()),"
        output += " value is \(rank.values.first)"
        if let second = rank.values.second {
            output += " or \(second)"
        }
        return output
    }
}
</code></pre>


<p>枚举型的<code>Suit</code>用来描述扑克牌的四种花色，并分别用一个<code>Character</code>类型的值代表花色符号。</p>


<p>枚举型的<code>Rank</code>用来描述扑克牌从<code>Ace</code>~10,<code>J</code>,<code>Q</code>,<code>K</code>,13张牌，并分别用一个<code>Int</code>类型的值表示牌的面值。(这个<code>Int</code>类型的值不适用于<code>Ace</code>,<code>J</code>,<code>Q</code>,<code>K</code>的牌)。</p>


<p>如上文所提到的，枚举型<code>Rank</code>在自己内部定义了一个嵌套结构体<code>Values</code>。这个结构体包含两个变量，只有<code>Ace</code>有两个数值，其余牌都只有一个数值。结构体<code>Values</code>中定义的两个属性：</p>


<p><code>first</code>, 为<code>Int</code>
<code>second</code>, 为 <code>Int?</code>, 或 “optional <code>Int</code>”</p>


<p><code>Rank</code>定义了一个计算属性<code>values</code>，这个计算属性会根据牌的面值，用适当的数值去初始化<code>Values</code>实例，并赋值给<code>values</code>。对于<code>J</code>,<code>Q</code>,<code>K</code>,<code>Ace</code>会使用特殊数值，对于数字面值的牌使用<code>Int</code>类型的值。</p>


<p><code>BlackjackCard</code>结构体自身有两个属性—<code>rank</code>与<code>suit</code>，也同样定义了一个计算属性<code>description</code>，<code>description</code>属性用<code>rank</code>和<code>suit</code>的中内容来构建对这张扑克牌名字和数值的描述，并用可选类型<code>second</code>来检查是否存在第二个值，若存在，则在原有的描述中增加对第二数值的描述。</p>


<p>因为<code>BlackjackCard</code>是一个没有自定义构造函数的结构体，在<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/14Initialization.md" target="_blank">Memberwise Initializers for Structure Types</a>中知道结构体有默认的成员构造函数，所以你可以用默认的<code>initializer</code>去初始化新的常量<code>theAceOfSpades</code>:</p>


<pre><code>let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
println("theAceOfSpades: \(theAceOfSpades.description)")
// 打印出 "theAceOfSpades: suit is ♠, value is 1 or 11"
</code></pre>


<p>尽管<code>Rank</code>和<code>Suit</code>嵌套在<code>BlackjackCard</code>中，但仍可被引用，所以在初始化实例时能够通过枚举类型中的成员名称单独引用。在上面的例子中<code>description</code>属性能正确得输出对<code>Ace</code>牌有1和11两个值。</p>


<p><a name="referring_to_nested_types"></a></p>


<h2 id="-">类型嵌套的引用</h2>


<p>在外部对嵌套类型的引用，以被嵌套类型的名字为前缀，加上所要引用的属性名：</p>


<pre><code>let heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()
// 红心的符号 为 "♡"
</code></pre>


<p>对于上面这个例子，这样可以使<code>Suit</code>, <code>Rank</code>, 和 <code>Values</code>的名字尽可能的短，因为它们的名字会自然的由被定义的上下文来限定。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift类和结构体]]></title>
    <link href="http://baxiang123.com//blog/Swift%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift类和结构体</id>
    <content type="html"><![CDATA[<p>类和结构体是人们构建代码所用的一种通用且灵活的构造体。为了在类和结构体中实现各种功能，我们必须要严格按照对于常量，变量以及函数所规定的语法规则来定义属性和添加方法。</p>


<p>与其他编程语言所不同的是，Swift 并不要求你为自定义类和结构去创建独立的接口和实现文件。你所要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。</p>


<!-- more -->


<blockquote>
<p> 注意：</p>
<p>通常一个<code>类</code>的实例被称为<code>对象</code>。然而在Swift 中，类和结构体的关系要比在其他语言中更加的密切，本章中所讨论的大部分功能都可以用在类和结构体上。因此，我们会主要使用<code>实例</code>而不是<code>对象</code>。</p>
</blockquote>


<p><a name="comparing_classes_and_structures"></a></p>


<h3 id="-">类和结构体对比</h3>


<p>Swift 中类和结构体有很多共同点。共同处在于：</p>


<ul>
<li>定义属性用于储存值</li>
<li>定义方法用于提供功能</li>
<li>定义下标用于通过下标语法访问值</li>
<li>定义初始化器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>符合协议以对某类提供标准功能</li>
</ul>


<p>更多信息请参见 <a href="10_Properties.html">属性</a>，<a href="11_Methods.html">方法</a>，<a href="12_Subscripts.html">下标</a>，<a href="14_Initialization.html">初始过程</a>，<a href="20_Extensions.html">扩展</a>，和<a href="21_Protocols.html">协议</a>。</p>


<p>与结构体相比，类还有如下的附加功能：</p>


<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>取消初始化器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>


<p>更多信息请参见<a href="http://" target="_blank">继承</a>，<a href="http://" target="_blank">类型转换</a>，<a href="http://" target="_blank">初始化</a>，和<a href="http://" target="_blank">自动引用计数</a>。</p>


<blockquote>
<p>注意：</p>
<p>结构体总是通过被复制的方式在代码中传递，因此请不要使用引用计数。</p>
</blockquote>


<h3 id="-">定义</h3>


<p>类和结构体有着类似的定义方式。我们通过关键字<code>class</code>和<code>struct</code>来分别表示类和结构体，并在一对大括号中定义它们的具体内容：</p>


<pre><code>class SomeClass {
    // class definition goes here
}
struct SomeStructure {
    // structure definition goes here
}
</code></pre>


<blockquote>
<p> 注意：</p>
<p>在你每次定义一个新类或者结构体的时候，实际上你是有效地定义了一个新的 Swift 类型。因此请使用 <code>UpperCamelCase</code> 这种方式来命名（如 <code>SomeClass</code> 和<code>SomeStructure</code>等），以便符合标准Swift 类型的大写命名风格（如<code>String</code>，<code>Int</code>和<code>Bool</code>）。相反的，请使用<code>lowerCamelCase</code>这种方式为属性和方法命名（如<code>framerate</code>和<code>incrementCount</code>），以便和类区分。</p>
</blockquote>


<p>以下是定义结构体和定义类的示例：</p>


<pre><code>struct Resolution {
    var width = 0
    var heigth = 0
}
class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}
</code></pre>


<p>在上面的示例中我们定义了一个名为<code>Resolution</code>的结构体，用来描述一个显示器的像素分辨率。这个结构体包含了两个名为<code>width</code>和<code>height</code>的储存属性。储存属性是捆绑和储存在类或结构体中的常量或变量。当这两个属性被初始化为整数<code>0</code>的时候，它们会被推断为<code>Int</code>类型。</p>


<p>在上面的示例中我们还定义了一个名为<code>VideoMode</code>的类，用来描述一个视频显示器的特定模式。这个类包含了四个储存属性变量。第一个是<code>分辨率</code>，它被初始化为一个新的<code>Resolution</code>结构体的实例，具有<code>Resolution</code>的属性类型。新<code>VideoMode</code>实例同时还会初始化其它三个属性，它们分别是，初始值为<code>false</code>(意为“non-interlaced video”)的<code>inteflaced</code>，回放帧率初始值为<code>0.0</code>的<code>frameRate</code>和值为可选<code>String</code>的<code>name</code>。<code>name</code>属性会被自动赋予一个默认值<code>nil</code>，意为“没有<code>name</code>值”，因它是一个可选类型。</p>


<h3 id="-">类和结构体实例</h3>


<p><code>Resolution</code>结构体和<code>VideoMode</code>类的定义仅描述了什么是<code>Resolution</code>和<code>VideoMode</code>。它们并没有描述一个特定的分辨率（resolution）或者视频模式（video mode）。为了描述一个特定的分辨率或者视频模式，我们需要生成一个它们的实例。</p>


<p>生成结构体和类实例的语法非常相似：</p>


<pre><code>let someResolution = Resolution()
let someVideoMode = VideoMode()
</code></pre>


<p>结构体和类都使用初始化器语法来生成新的实例。初始化器语法的最简单形式是在结构体或者类的类型名称后跟随一个空括弧，如<code>Resolution()</code>或<code>VideoMode()</code>。通过这种方式所创建的类或者结构体实例，其属均会被初始化为默认值。<a href="14_Initialization.html">构造过程</a>章节会对类和结构体的初始化进行更详细的讨论。</p>


<h3 id="-">属性访问</h3>


<p>通过使用<em>点语法</em>（<em>dot syntax</em>）,你可以访问实例中所含有的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接：</p>


<pre><code>println("The width of someResolution is \(someResolution.width)")
// 输出 "The width of someResolution is 0"
</code></pre>


<p>在上面的例子中，<code>someResolution.width</code>引用<code>someResolution</code>的<code>width</code>属性，返回<code>width</code>的初始值<code>0</code>。</p>


<p>你也可以访问子属性，如何<code>VideoMode</code>中<code>Resolution</code>属性的<code>width</code>属性：</p>


<pre><code>println("The width of someVideoMode is \(someVideoMode.resolution.width)")
// 输出 "The width of someVideoMode is 0"
</code></pre>


<p>你也可以使用点语法为属性变量赋值：</p>


<pre><code>someVideoMode.resolution.width = 12880
println("The width of someVideoMode is now \(someVideoMode.resolution.width)")
// 输出 "The width of someVideoMode is now 1280"
</code></pre>


<blockquote>
<p> 注意：</p>
<p>与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了<code>someVideoMode</code>中<code>resolution</code>属性的<code>width</code>这个子属性，以上操作并不需要从新设置<code>resolution</code>属性。</p>
</blockquote>


<h3 id="-">结构体类型的成员逐一初始化器</h3>


<p>//Memberwise Initializers for structure Types</p>


<p>所有结构体都有一个自动生成的成员逐一初始化器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一初始化器之中：</p>


<pre><code>let vga = resolution（width:640, heigth: 480）
</code></pre>


<p>与结构体不同，类实例没有默认的成员逐一初始化器。<a href="14_Initialization.html">构造过程</a>章节会对初始化器进行更详细的讨论。</p>


<p><a name="structures_and_enumerations_are_value_types"></a></p>


<h2 id="-">结构体和枚举是值类型</h2>


<p>值类型被赋予给一个变量，常数或者本身被传递给一个函数的时候，实际上操作的是其的拷贝。</p>


<p>在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型：整数(Integer)、浮点数(floating-point)、布尔值(Booleans)、字符串(string)、数组(array)和字典(dictionaries)，都是值类型，并且都是以结构体的形式在后台所实现。</p>


<p>在 Swift 中，所有的结构体和枚举都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。</p>


<p>请看下面这个示例，其使用了前一个示例中<code>Resolution</code>结构体：</p>


<pre><code>let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
</code></pre>


<p>在以上示例中，声明了一个名为<code>hd</code>的常量，其值为一个初始化为全高清视频分辨率(1920 像素宽，1080 像素高)的<code>Resolution</code>实例。</p>


<p>然后示例中又声明了一个名为<code>cinema</code>的变量，其值为之前声明的<code>hd</code>。因为<code>Resolution</code>是一个结构体，所以<code>cinema</code>的值其实是<code>hd</code>的一个拷贝副本，而不是<code>hd</code>本身。尽管<code>hd</code>和<code>cinema</code>有着相同的宽(width)和高(height)属性，但是在后台中，它们是两个完全不同的实例。</p>


<p>下面，为了符合数码影院放映的需求(2048 像素宽，1080 像素高)，<code>cinema</code>的<code>width</code>属性需要作如下修改：</p>


<pre><code>cinema.width = 2048
</code></pre>


<p>这里，将会显示<code>cinema</code>的<code>width</code>属性确已改为了<code>2048</code>：</p>


<pre><code>println("cinema is now  \(cinema.width) pixels wide")
// 输出 "cinema is now 2048 pixels wide"
</code></pre>


<p>然而，初始的<code>hd</code>实例中<code>width</code>属性还是<code>1920</code>：</p>


<pre><code>println("hd is still \(hd.width    ) pixels wide")
// 输出 "hd is still 1920 pixels wide"
</code></pre>


<p>在将<code>hd</code>赋予给<code>cinema</code>的时候，实际上是将<code>hd</code>中所储存的<code>值(values)</code>进行拷贝，然后将拷贝的数据储存到新的<code>cinema</code>实例中。结果就是两个完全独立的实例碰巧包含有相同的数值。由于两者相互独立，因此将<code>cinema</code>的<code>width</code>修改为<code>2048</code>并不会影响<code>hd</code>中的宽(width)。</p>


<p>枚举也遵循相同的行为准则：</p>


<pre><code>enum CompassPoint {
    case North, South, East, West
}
var currentDirection = CompassPoint.West
let rememberedDirection = currentDirection
currentDirection = .East
if rememberDirection == .West {
    println("The remembered direction is still .West")
}
// 输出 "The remembered direction is still .West"
</code></pre>


<p>上例中<code>rememberedDirection</code>被赋予了<code>currentDirection</code>的值(value)，实际上它被赋予的是值(value)的一个拷贝。赋值过程结束后再修改<code>currentDirection</code>的值并不影响<code>rememberedDirection</code>所储存的原始值(value)的拷贝。</p>


<p><a name="classes_are_reference_types"></a></p>


<h2 id="-">类是引用类型</h2>


<p>与值类型不同，引用类型在被赋予到一个变量，常量或者被传递到一个函数时，操作的并不是其拷贝。因此，引用的是已存在的实例本身而不是其拷贝。</p>


<p>请看下面这个示例，其使用了之前定义的<code>VideoMode</code>类：</p>


<pre><code>let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0
</code></pre>


<p>以上示例中，声明了一个名为<code>tenEighty</code>的常量，其引用了一个<code>VideoMode</code>类的新实例。在之前的示例中，这个视频模式(video mode)被赋予了HD分辨率(1920*1080)的一个拷贝(<code>hd</code>)。同时设置为交错(interlaced),命名为<code>“1080i”</code>。最后，其帧率是<code>25.0</code>帧每秒。</p>


<p>然后，<code>tenEighty</code> 被赋予名为<code>alsoTenEighty</code>的新常量，同时对<code>alsoTenEighty</code>的帧率进行修改：</p>


<pre><code>let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0
</code></pre>


<p>因为类是引用类型，所以<code>tenEight</code>和<code>alsoTenEight</code>实际上引用的是相同的<code>VideoMode</code>实例。换句话说，它们只是同一个实例的两种叫法。</p>


<p>下面，通过查看<code>tenEighty</code>的<code>frameRate</code>属性，我们会发现它正确的显示了基本<code>VideoMode</code>实例的新帧率，其值为<code>30.0</code>：</p>


<pre><code>println("The frameRate property of tenEighty is now \(tenEighty.frameRate)")
// 输出 "The frameRate property of theEighty is now 30.0"
</code></pre>


<p>需要注意的是<code>tenEighty</code>和<code>alsoTenEighty</code>被声明为<em>常量(constants)</em>而不是变量。然而你依然可以改变<code>tenEighty.frameRate</code>和<code>alsoTenEighty.frameRate</code>,因为这两个常量本身不会改变。它们并不<code>储存</code>这个<code>VideoMode</code>实例，在后台仅仅是对<code>VideoMode</code>实例的引用。所以，改变的是被引用的基础<code>VideoMode</code>的<code>frameRate</code>参数，而不改变常量的值。</p>


<h3 id="-">恒等运算符</h3>


<p>因为类是引用类型，有可能有多个常量和变量在后台同时引用某一个类实例。(对于结构体和枚举来说，这并不成立。因为它们作值类型，在被赋予到常量，变量或者传递到函数时，总是会被拷贝。)</p>


<p>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p>


<ul>
<li>等价于 ( === )</li>
<li>不等价于 ( !== )</li>
</ul>


<p>以下是运用这两个运算符检测两个常量或者变量是否引用同一个实例：</p>


<pre><code>if tenEighty === alsoTenTighty {
    println("tenTighty and alsoTenEighty refer to the same Resolution instance.")
}
//输出 "tenEighty and alsoTenEighty refer to the same Resolution instance."
</code></pre>


<p>请注意“等价于”(用三个等号表示，===) 与“等于”(用两个等号表示，==)的不同：</p>


<ul>
<li>“等价于”表示两个类类型(class type)的常量或者变量引用同一个类实例。</li>
<li>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照类设计者定义定义的评判标准，因此相比于“相等”，这是一种更加合适的叫法。</li>
</ul>


<p>当你在定义你的自定义类和结构体的时候，你有义务来决定判定两个实例“相等”的标准。在章节<a href="23_Advanced_Operators.html#operator_functions">运算符函数(Operator Functions)</a>中将会详细介绍实现自定义“等于”和“不等于”运算符的流程。</p>


<h3 id="-">指针</h3>


<p>如果你有 C，C++ 或者 Objective-C 语言的经验，那么你也许会知道这些语言使用指针来引用内存中的地址。一个 Swift 常量或者变量引用一个引用类型的实例与C语言中的指针类似，不同的是并不直接指向内存中的某个地址，而且也不要求你使用星号(*)来表明你在创建一个引用。Swift 中这些引用与其它的常量或变量的定义方式相同。</p>


<p><a name="choosing_between_classes_and_structures"></a></p>


<h2 id="-">类和结构体的选择</h2>


<p>在你的代码中，你可以使用类和结构体来定义你的自定义数据类型。</p>


<p>然而，结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你的在考虑一个工程项目的数据构造和功能的时候，你需要决定每个数据构造是定义成类还是结构体。</p>


<p>按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：</p>


<ul>
<li>结构体的主要目的是用来封装少量相关简单数据值。</li>
<li>有理由预计一个结构体实例在赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
<li>任何在结构体中储存的值类型属性，也将会被拷贝，而不是被引用。</li>
<li>结构体不需要去继承另一个已存在类型的属性或者行为。</li>
</ul>


<p>合适的结构体候选者包括：</p>


<ul>
<li>几何形状的大小，封装一个<code>width</code>属性和<code>height</code>属性，两者均为<code>Double</code>类型。</li>
<li>一定范围内的路径，封装一个<code>start</code>属性和<code>length</code>属性，两者均为<code>Int</code>类型。</li>
<li>三维坐标系内一点，封装<code>x</code>，<code>y</code>和<code>z</code>属性，三者均为<code>Double</code>类型。</li>
</ul>


<p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p>


<p><a name="assignment_and_copy_behavior_for_collection_types"></a></p>


<h2 id="-collection-">集合(Collection)类型的赋值和拷贝行为</h2>


<p>Swift 中<code>数组(Array)</code>和<code>字典(Dictionary)</code>类型均以结构体的形式实现。然而当数组被赋予一个常量或变量，或被传递给一个函数或方法时，其拷贝行为与字典和其它结构体有些许不同。</p>


<p>以下对<code>数组</code>和<code>结构体</code>的行为描述与对<code>NSArray</code>和<code>NSDictionary</code>的行为描述在本质上不同，后者是以类的形式实现，前者是以结构体的形式实现。<code>NSArray</code>和<code>NSDictionary</code>实例总是以对已有实例引用,而不是拷贝的方式被赋值和传递。</p>


<blockquote>
<p>注意：</p>
<p>以下是对于数组，字典，字符串和其它值的<code>拷贝</code>的描述。
在你的代码中，拷贝好像是确实是在有拷贝行为的地方产生过。然而，在Swift 的后台中，只有确有必要，<code>实际(actual)</code>拷贝才会被执行。Swift 管理所有的值拷贝以确保性能最优化的性能，所以你也没有必要去避免赋值以保证最优性能。(实际赋值由系统管理优化)</p>
</blockquote>


<h3 id="-">字典类型的赋值和拷贝行为</h3>


<p>无论何时将一个<code>字典</code>实例赋给一个常量或变量，或者传递给一个函数或方法，这个字典会即会在赋值或调用发生时被拷贝。在章节<a href="#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a>中将会对此过程进行详细介绍。</p>


<p>如果<code>字典</code>实例中所储存的键(keys)和/或值(values)是值类型(结构体或枚举)，当赋值或调用发生时，它们都会被拷贝。相反，如果键(keys)和/或值(values)是引用类型，被拷贝的将会是引用，而不是被它们引用的类实例或函数。<code>字典</code>的键和值的拷贝行为与结构体所储存的属性的拷贝行为相同。</p>


<p>下面的示例定义了一个名为<code>ages</code>的字典，其中储存了四个人的名字和年龄。<code>ages</code>字典被赋予了一个名为<code>copiedAges</code>的新变量，同时<code>ages</code>在赋值的过程中被拷贝。赋值结束后，<code>ages</code>和<code>copiedAges</code>成为两个相互独立的字典。</p>


<pre><code>var ages = ["Peter": 23, "Wei": 35, "Anish": 65, "Katya": 19]
var copiedAges = ages
</code></pre>


<p>这个字典的键(keys)是<code>字符串(String)</code>类型，值(values)是<code>整(Int)</code>类型。这两种类型在Swift 中都是值类型(value types)，所以当字典被拷贝时，两者都会被拷贝。</p>


<p>我们可以通过改变一个字典中的年龄值(age value)，检查另一个字典中所对应的值，来证明<code>ages</code>字典确实是被拷贝了。如果在<code>copiedAges</code>字典中将<code>Peter</code>的值设为<code>24</code>，那么<code>ages</code>字典仍然会返回修改前的值<code>23</code>：</p>


<pre><code>copiedAges["Peter"] = 24
println(ages["Peter"])
// 输出 "23"
</code></pre>


<h3 id="-">数组的赋值和拷贝行为</h3>


<p>在Swift 中，<code>数组(Arrays)</code>类型的赋值和拷贝行为要比<code>字典(Dictionary)</code>类型的复杂的多。当操作数组内容时，<code>数组(Array)</code>能提供接近C语言的的性能，并且拷贝行为只有在必要时才会发生。</p>


<p>如果你将一个<code>数组(Array)</code>实例赋给一个变量或常量，或者将其作为参数传递给函数或方法调用，在事件发生时数组的内容<code>不</code>会被拷贝。相反，数组公用相同的元素序列。当你在一个数组内修改某一元素，修改结果也会在另一数组显示。</p>


<p>对数组来说，拷贝行为仅仅当操作有可能修改数组<code>长度</code>时才会发生。这种行为包括了附加(appending),插入(inserting),删除(removing)或者使用范围下标(ranged subscript)去替换这一范围内的元素。只有当数组拷贝确要发生时，数组内容的行为规则与字典中键值的相同，参见章节[集合（collection）类型的赋值与复制行为](#assignment_and_copy_behavior_for_collection_types。</p>


<p>下面的示例将一个<code>整数(Int)</code>数组赋给了一个名为<code>a</code>的变量，继而又被赋给了变量<code>b</code>和<code>c</code>：</p>


<pre><code>var a = [1, 2, 3]
var b = a
var c = a
</code></pre>


<p>我们可以在<code>a</code>,<code>b</code>,<code>c</code>上使用下标语法以得到数组的第一个元素：</p>


<pre><code>println(a[0])
// 1
println(b[0])
// 1
println(c[0])
// 1
</code></pre>


<p>如果通过下标语法修改数组中某一元素的值，那么<code>a</code>,<code>b</code>,<code>c</code>中的相应值都会发生改变。请注意当你用下标语法修改某一值时，并没有拷贝行为伴随发生，因为下表语法修改值时没有改变数组长度的可能：</p>


<pre><code>a[0] = 42
println(a[0])
// 42
println(b[0])
// 42
println(c[0])
// 42
</code></pre>


<p>然而，当你给<code>a</code>附加新元素时，数组的长度<code>会</code>改变。
当附加元素这一事件发生时，Swift 会创建这个数组的一个拷贝。从此以后，<code>a</code>将会是原数组的一个独立拷贝。</p>


<p>拷贝发生后，如果再修改<code>a</code>中元素值的话，<code>a</code>将会返回与<code>b</code>，<code>c</code>不同的结果，因为后两者引用的是原来的数组：</p>


<pre><code>a.append(4)
a[0] = 777
println(a[0])
// 777
println(b[0])
// 42
println(c[0])
// 42
</code></pre>


<h3 id="-">确保数组的唯一性</h3>


<p>在操作一个数组，或将其传递给函数以及方法调用之前是很有必要先确定这个数组是有一个唯一拷贝的。通过在数组变量上调用<code>unshare</code>方法来确定数组引用的唯一性。(当数组赋给常量时，不能调用<code>unshare</code>方法)</p>


<p>如果一个数组被多个变量引用，在其中的一个变量上调用<code>unshare</code>方法，则会拷贝此数组，此时这个变量将会有属于它自己的独立数组拷贝。当数组仅被一个变量引用时，则不会有拷贝发生。</p>


<p>在上一个示例的最后，<code>b</code>和<code>c</code>都引用了同一个数组。此时在<code>b</code>上调用<code>unshare</code>方法则会将<code>b</code>变成一个唯一个拷贝：</p>


<pre><code>b.unshare()
</code></pre>


<p>在<code>unshare</code>方法调用后再修改<code>b</code>中第一个元素的值，这三个数组(<code>a</code>,<code>b</code>,<code>c</code>)会返回不同的三个值：</p>


<pre><code>b[0] = -105
println(a[0])
// 77
println(b[0])
// -105
println(c[0])
// 42
</code></pre>


<h3 id="-">判定两个数组是否共用相同元素</h3>


<p>我们通过使用恒等运算符(identity operators)( === and !==)来判定两个数组或子数组共用相同的储存空间或元素。</p>


<p>下面这个示例使用了“恒等于(identical to)” 运算符(===) 来判定<code>b</code>和<code>c</code>是否共用相同的数组元素：</p>


<pre><code>if b === c {
    println("b and c still share the same array elements.")
} else {
    println("b and c now refer to two independent sets of array elements.")
}

// 输出 "b and c now refer totwo independent sets of array elements."
</code></pre>


<p>此外，我们还可以使用恒等运算符来判定两个子数组是否共用相同的元素。下面这个示例中，比较了<code>b</code>的两个相等的子数组，并且确定了这两个子数组都引用相同的元素：</p>


<pre><code>if b[0...1] === b[0...1] {
    println("These two subarrays share the same elements.")
} else {
    println("These two subarrays do not share the same elements.")
}
// 输出 "These two subarrays share the same elements."
</code></pre>


<h3 id="-">强制复制数组</h3>


<p>我们通过调用数组的<code>copy</code>方法进行强制显性复制。这个方法对数组进行了浅拷贝(shallow copy),并且返回一个包含此拷贝的新数组。</p>


<p>下面这个示例中定义了一个<code>names</code>数组，其包含了七个人名。还定义了一个<code>copiedNames</code>变量，用以储存在<code>names</code>上调用<code>copy</code>方法所返回的结果：</p>


<pre><code>var names = ["Mohsen", "Hilary", "Justyn", "Amy", "Rich", "Graham", "Vic"]
var copiedNames = names.copy
</code></pre>


<p>我们可以通过修改一个数组中某元素，并且检查另一个数组中对应元素的方法来判定<code>names</code>数组确已被复制。如果你将<code>copiedNames</code>中第一个元素从&#8221;<code>Mohsen</code>&#8220;修改为&#8221;<code>Mo</code>&#8220;,则<code>names</code>数组返回的仍是拷贝发生前的&#8221;<code>Mohsen</code>&#8220;：</p>


<pre><code>copiedName[0] = "Mo"
println(name[0])
// 输出 "Mohsen"
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果你仅需要确保你对数组的引用是唯一引用，请调用<code>unshare</code>方法，而不是<code>copy</code>方法。<code>unshare</code>方法仅会在确有必要时才会创建数组拷贝。<code>copy</code>方法会在任何时候都创建一个新的拷贝，即使引用已经是唯一引用。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift枚举]]></title>
    <link href="http://baxiang123.com//blog/Swift%E6%9E%9A%E4%B8%BE.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift枚举</id>
    <content type="html"><![CDATA[<p>枚举定义了一个通用类型的一组相关的值，使你可以在你的代码中以一个安全的方式来使用这些值。</p>


<p>如果你熟悉 C 语言，你就会知道，在 C 语言中枚举指定相关名称为一组整型值。Swift 中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果一个值（被认为是“原始”值）被提供给每个枚举成员，则该值可以是一个字符串，一个字符，或是一个整型值或浮点值。</p>


<!-- more -->


<p>此外，枚举成员可以指定任何类型的实例值存储到枚举成员值中，就像其他语言中的联合体（unions）和变体（variants）。你可以定义一组通用的相关成员作为枚举的一部分，每一组都有不同的一组与它相关的适当类型的数值。</p>


<p>在 Swift 中，枚举类型是一等（first-class）类型。它们采用了很多传统上只被类（class)所支持的特征，例如计算型属性（computed properties)，用于提供关于枚举当前值的附加信息， 实例方法（instance methods），用于提供和枚举所代表的值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始成员值；可以在原始的实现基础上扩展它们的功能；可以遵守协议（protocols）来提供标准的功能。</p>


<p>欲了解更多相关功能，请参见<a href="10_Properties.html">属性（Properties）</a>，<a href="11_Methods.html">方法（Methods）</a>，<a href="14_Initialization.html">构造过程（Initialization）</a>，<a href="20_Extensions.html">扩展（Extensions）</a>和<a href="21_Protocols.html">协议（Protocols）</a>。</p>


<p><a name="enumeration_syntax"></a></p>


<h2 id="-">枚举语法</h2>


<p>使用<code>enum</code>关键词并且把它们的整个定义放在一对大括号内：</p>


<pre><code>enum SomeEumeration {
    // enumeration definition goes here
}
</code></pre>


<p>以下是指南针四个方向的一个例子：</p>


<pre><code>enum CompassPoint {
    case North
    case South
    case East
    case West
}
</code></pre>


<p>一个枚举中被定义的值（例如 <code>North</code>，<code>South</code>，<code>East</code>和<code>West</code>）是枚举的<strong><em>成员值</em></strong>（或者<strong><em>成员</em></strong>）。<code>case</code>关键词表明新的一行成员值将被定义。</p>


<blockquote>
<p>注意：</p>
<p>不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值。在上面的<code>CompassPoints</code>例子中，<code>North</code>，<code>South</code>，<code>East</code>和<code>West</code>不是隐式的等于<code>0</code>，<code>1</code>，<code>2</code>和<code>3</code>。相反的，这些不同的枚举成员在<code>CompassPoint</code>的一种显示定义中拥有各自不同的值。</p>
</blockquote>


<p>多个成员值可以出现在同一行上，用逗号隔开：</p>


<pre><code>enum Planet {
    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Nepturn
}
</code></pre>


<p>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如<code>CompassPoint</code>和<code>Planet</code>）必须以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：</p>


<pre><code>var directionToHead = CompassPoint.West
</code></pre>


<p><code>directionToHead</code>的类型被推断当它被<code>CompassPoint</code>的一个可能值初始化。一旦<code>directionToHead</code>被声明为一个<code>CompassPoint</code>，你可以使用更短的点（.）语法将其设置为另一个<code>CompassPoint</code>的值：</p>


<pre><code>directionToHead = .East
</code></pre>


<p><code>directionToHead</code>的类型已知时，当设定它的值时，你可以不再写类型名。使用显示类型的枚举值可以让代码具有更好的可读性。</p>


<p><a name="matching_enumeration_values_with_a_switch_statement"></a></p>


<h2 id="-switch-">匹配枚举值和<code>Switch</code>语句</h2>


<p>你可以匹配单个枚举值和<code>switch</code>语句：</p>


<pre><code>directionToHead = .South
switch directionToHead {
case .North:
    println("Lots of planets have a north")
case .South:
    println("Watch out for penguins")
case .East:
    println("Where the sun rises")
case .West:
    println("Where the skies are blue")
}
// 输出 "Watch out for penguins”
</code></pre>


<p>你可以如此理解这段代码：</p>


<p>“考虑<code>directionToHead</code>的值。当它等于<code>.North</code>，打印<code>“Lots of planets have a north”</code>。当它等于<code>.South</code>，打印<code>“Watch out for penguins”</code>。”</p>


<p>等等依次类推。</p>


<p>正如在<a href="05_Control_Flow.html">控制流（Control Flow）</a>中介绍，当考虑一个枚举的成员们时，一个<code>switch</code>语句必须全面。如果忽略了<code>.West</code>这种情况，上面那段代码将无法通过编译，因为它没有考虑到<code>CompassPoint</code>的全部成员。全面性的要求确保了枚举成员不会被意外遗漏。</p>


<p>当不需要匹配每个枚举成员的时候，你可以提供一个默认<code>default</code>分支来涵盖所有未明确被提出的任何成员：</p>


<pre><code>let somePlanet = Planet.Earth
switch somePlanet {
case .Earth:
    println("Mostly harmless")
default:
    println("Not a safe place for humans")
}
// 输出 "Mostly harmless”
</code></pre>


<p><a name="associated_values"></a></p>


<h2 id="-associated-values-">实例值（Associated Values）</h2>


<p>上一小节的例子演示了一个枚举的成员是如何被定义（分类）的。你可以为<code>Planet.Earth</code>设置一个常量或则变量，并且在之后查看这个值。然而，有时候会很有用如果能够把其他类型的实例值和成员值一起存储起来。这能让你随着成员值存储额外的自定义信息，并且当每次你在代码中利用该成员时允许这个信息产生变化。</p>


<p>你可以定义 Swift 的枚举存储任何类型的实例值，如果需要的话，每个成员的数据类型可以是各不相同的。枚举的这种特性跟其他语言中的可辨识联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。</p>


<p>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有 UPC-A 格式的一维码，它使用数字 0 到 9。每一个条形码都有一个代表“数字系统”的数字，该数字后接 10 个代表“标识符”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：</p>


<p><img width="252" height="120" alt="" src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png"></p>


<p>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO8859-1 字符，并且可以编码一个最多拥有 2,953 字符的字符串:</p>


<p><img width="169" height="169" alt="" src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png"></p>


<p>对于库存跟踪系统来说，能够把 UPC-A 码作为三个整型值的元组，和把 QR 码作为一个任何长度的字符串存储起来是方便的。</p>


<p>在 Swift 中，用来定义两种商品条码的枚举是这样子的：</p>


<pre><code>enum Barcode {
    case UPCA(Int, Int, Int)
    case QRCode(String)
}
</code></pre>


<p>以上代码可以这么理解：</p>


<p>“定义一个名为<code>Barcode</code>的枚举类型，它可以是<code>UPCA</code>的一个实例值（<code>Int</code>，<code>Int</code>，<code>Int</code>），或者<code>QRCode</code>的一个字符串类型（<code>String</code>）实例值。”</p>


<p>这个定义不提供任何<code>Int</code>或<code>String</code>的实际值，它只是定义了，当<code>Barcode</code>常量和变量等于<code>Barcode.UPCA</code>或<code>Barcode.QRCode</code>时，实例值的类型。</p>


<p>然后可以使用任何一种条码类型创建新的条码，如：</p>


<pre><code>var productBarcode = Barcode.UPCA(8, 85909_51226, 3)
</code></pre>


<p>以上例子创建了一个名为<code>productBarcode</code>的新变量，并且赋给它一个<code>Barcode.UPCA</code>的实例元组值<code>(8, 8590951226, 3)</code>。提供的“标识符”值在整数字中有一个下划线，使其便于阅读条形码。</p>


<p>同一个商品可以被分配给一个不同类型的条形码，如：</p>


<pre><code>productBarcode = .QRCode("ABCDEFGHIJKLMNOP")
</code></pre>


<p>这时，原始的<code>Barcode.UPCA</code>和其整数值被新的<code>Barcode.QRCode</code>和其字符串值所替代。条形码的常量和变量可以存储一个<code>.UPCA</code>或者一个<code>.QRCode</code>（连同它的实例值），但是在任何指定时间只能存储其中之一。</p>


<p>像以前那样，不同的条形码类型可以使用一个 switch 语句来检查，然而这次实例值可以被提取作为 switch 语句的一部分。你可以在<code>switch</code>的 case 分支代码中提取每个实例值作为一个常量（用<code>let</code>前缀）或者作为一个变量（用<code>var</code>前缀）来使用：</p>


<pre><code>switch productBarcode {
case .UPCA(let numberSystem, let identifier, let check):
    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
case .QRCode(let productCode):
    println("QR code with value of \(productCode).")
}
// 输出 "QR code with value of ABCDEFGHIJKLMNOP.”
</code></pre>


<p>如果一个枚举成员的所有实例值被提取为常量，或者它们全部被提取为变量，为了简洁，你可以只放置一个<code>var</code>或者<code>let</code>标注在成员名称前：</p>


<pre><code>switch productBarcode {
case let .UPCA(numberSystem, identifier, check):
    println("UPC-A with value of \(numberSystem), \(identifier), \(check).")
case let .QRCode(productCode):
    println("QR code with value of \(productCode).")
}
// 输出 "QR code with value of ABCDEFGHIJKLMNOP."
</code></pre>


<p><a name="raw_values"></a></p>


<h2 id="-raw-values-">原始值（Raw Values）</h2>


<p>在实例值小节的条形码例子中演示了一个枚举的成员如何声明它们存储不同类型的实例值。作为实例值的替代，枚举成员可以被默认值（称为原始值）预先填充，其中这些原始值具有相同的类型。</p>


<p>这里是一个枚举成员存储原始 ASCII 值的例子：</p>


<pre><code>enum ASCIIControlCharacter: Character {
    case Tab = "\t"
    case LineFeed = "\n"
    case CarriageReturn = "\r"
}
</code></pre>


<p>在这里，称为<code>ASCIIControlCharacter</code>的枚举的原始值类型被定义为字符型<code>Character</code>，并被设置了一些比较常见的 ASCII 控制字符。字符值的描述请详见字符串和字符<code>Strings and Characters</code>部分。</p>


<p>注意，原始值和实例值是不相同的。当你开始在你的代码中定义枚举的时候原始值是被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终是相同的。实例值是当你在创建一个基于枚举成员的新常量或变量时才会被设置，并且每次当你这么做得时候，它的值可以是不同的。</p>


<p>原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的。当整型值被用于原始值，如果其他枚举成员没有值时，它们会自动递增。</p>


<p>下面的枚举是对之前<code>Planet</code>这个枚举的一个细化，利用原始整型值来表示每个 planet 在太阳系中的顺序：</p>


<pre><code>enum Planet: Int {
    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
</code></pre>


<p>自动递增意味着<code>Planet.Venus</code>的原始值是<code>2</code>，依次类推。</p>


<p>使用枚举成员的<code>toRaw</code>方法可以访问该枚举成员的原始值：</p>


<pre><code>let earthsOrder = Planet.Earth.toRaw()
// earthsOrder is 3
</code></pre>


<p>使用枚举的<code>fromRaw</code>方法来试图找到具有特定原始值的枚举成员。这个例子通过原始值<code>7</code>识别<code>Uranus</code>：</p>


<pre><code>let possiblePlanet = Planet.fromRaw(7)
// possiblePlanet is of type Planet? and equals Planet.Uranus
</code></pre>


<p>然而，并非所有可能的<code>Int</code>值都可以找到一个匹配的行星。正因为如此，<code>fromRaw</code>方法可以返回一个<strong><em>可选</em></strong>的枚举成员。在上面的例子中，<code>possiblePlanet</code>是<code>Planet?</code>类型，或“可选的<code>Planet</code>”。</p>


<p>如果你试图寻找一个位置为9的行星，通过<code>fromRaw</code>返回的可选<code>Planet</code>值将是<code>nil</code>：</p>


<pre><code>let positionToFind = 9
if let somePlanet = Planet.fromRaw(positionToFind) {
    switch somePlanet {
    case .Earth:
        println("Mostly harmless")
    default:
        println("Not a safe place for humans")
    }
} else {
    println("There isn't a planet at position \(positionToFind)")
}
// 输出 "There isn't a planet at position 9
</code></pre>


<p>这个范例使用可选绑定（optional binding），通过原始值<code>9</code>试图访问一个行星。<code>if let somePlanet = Planet.fromRaw(9)</code>语句获得一个可选<code>Planet</code>，如果可选<code>Planet</code>可以被获得，把<code>somePlanet</code>设置成该可选<code>Planet</code>的内容。在这个范例中，无法检索到位置为<code>9</code>的行星，所以<code>else</code>分支被执行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swif析构过程]]></title>
    <link href="http://baxiang123.com//blog/Swift%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift析构过程</id>
    <content type="html"><![CDATA[<p>在一个类的实例被释放之前，析构函数被立即调用。用关键字<code>deinit</code>来标示析构函数，类似于初始化函数用<code>init</code>来标示。析构函数只适用于类类型。</p>


<!-- more -->


<p><a name="how_deinitialization_works"></a></p>


<h2 id="-">析构过程原理</h2>


<p>Swift 会自动释放不再需要的实例以释放资源。如<a href="16_Automatic_Reference_Counting.html">自动引用计数</a>那一章描述，Swift 通过<em>自动引用计数</em>（ARC）处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前关闭该文件。</p>


<p>在类的定义中，每个类最多只能有一个析构函数。析构函数不带任何参数，在写法上不带括号：</p>


<pre><code>deinit {
    // 执行析构过程
}
</code></pre>


<p>析构函数是在实例释放发生前一步被自动调用。不允许主动调用自己的析构函数。子类继承了父类的析构函数，并且在子类析构函数实现的最后，父类的析构函数被自动调用。即使子类没有提供自己的析构函数，父类的析构函数也总是被调用。</p>


<p>因为直到实例的析构函数被调用时，实例才会被释放，所以析构函数可以访问所有请求实例的属性，并且根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件的名称）。</p>


<p><a name="deinitializers_in_action"></a></p>


<h2 id="-">析构函数操作</h2>


<p>这里是一个析构函数操作的例子。这个例子是一个简单的游戏，定义了两种新类型，<code>Bank</code>和<code>Player</code>。<code>Bank</code>结构体管理一个虚拟货币的流通，在这个流通中<code>Bank</code>永远不可能拥有超过 10,000 的硬币。在这个游戏中有且只能有一个<code>Bank</code>存在，因此<code>Bank</code>由带有静态属性和静态方法的结构体实现，从而存储和管理其当前的状态。</p>


<pre><code>struct Bank {
    static var coinsInBank = 10_000
    static func vendCoins(var numberOfCoinsToVend: Int) -&gt; Int {
          numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)
          coinsInBank -= numberOfCoinsToVend
         return numberOfCoinsToVend
    }
    static func receiveCoins(coins: Int) {
    coinsInBank += coins
    }
}
</code></pre>


<p><code>Bank</code>根据它的<code>coinsInBank</code>属性来跟踪当前它拥有的硬币数量。银行还提供两个方法——<code>vendCoins</code>和<code>receiveCoins</code>——用来处理硬币的分发和收集。</p>


<p><code>vendCoins</code>方法在 bank 分发硬币之前检查是否有足够的硬币。如果没有足够多的硬币，<code>Bank</code>返回一个比请求时小的数字(如果没有硬币留在 bank 中就返回 0)。<code>vendCoins</code>方法声明<code>numberOfCoinsToVend</code>为一个变量参数，这样就可以在方法体的内部修改数字，而不需要定义一个新的变量。<code>vendCoins</code>方法返回一个整型值，表明了提供的硬币的实际数目。</p>


<p><code>receiveCoins</code>方法只是将 bank 的硬币存储和接收到的硬币数目相加，再保存回 bank。</p>


<p><code>Player</code>类描述了游戏中的一个玩家。每一个 player 在任何时刻都有一定数量的硬币存储在他们的钱包中。这通过 player 的<code>coinsInPurse</code>属性来体现：</p>


<pre><code>    class Player {
      var coinsInPurse: Int
      init(coins: Int) {
          coinsInPurse = Bank.vendCoins(coins)
    }
    func winCoins(coins: Int) {
          coinsInPurse += Bank.vendCoins(coins)
    }
    deinit {
          Bank.receiveCoins(coinsInPurse)
    }
    }
</code></pre>


<p>每个<code>Player</code>实例都由一个指定数目硬币组成的启动额度初始化，这些硬币在 bank 初始化的过程中得到。如果没有足够的硬币可用，<code>Player</code>实例可能收到比指定数目少的硬币。</p>


<p><code>Player</code>类定义了一个<code>winCoins</code>方法，该方法从银行获取一定数量的硬币，并把它们添加到玩家的钱包。<code>Player</code>类还实现了一个析构函数，这个析构函数在<code>Player</code>实例释放前一步被调用。这里析构函数只是将玩家的所有硬币都返回给银行：</p>


<pre><code>var playerOne: Player? = Player(coins: 100)
println("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
// 输出 "A new player has joined the game with 100     coins"
println("There are now \(Bank.coinsInBank) coins left     in the bank")
// 输出 "There are now 9900 coins left in the bank"
</code></pre>


<p>一个新的<code>Player</code>实例随着一个 100 个硬币（如果有）的请求而被创建。这<code>个Player</code>实例存储在一个名为<code>playerOne</code>的可选<code>Player</code>变量中。这里使用一个可选变量，是因为玩家可以随时离开游戏。设置为可选使得你可以跟踪当前是否有玩家在游戏中。</p>


<p>因为<code>playerOne</code>是可选的，所以由一个感叹号（<code>!</code>）来修饰，每当其<code>winCoins</code>方法被调用时，<code>coinsInPurse</code>属性被访问并打印出它的默认硬币数目。</p>


<pre><code>playerOne!.winCoins(2_000)
println("PlayerOne won 2000 coins &amp; now has \    (playerOne!.coinsInPurse) coins")
// 输出 "PlayerOne won 2000 coins &amp; now has 2100 coins"
println("The bank now only has \(Bank.coinsInBank) coins left")
// 输出 "The bank now only has 7900 coins left"
</code></pre>


<p>这里，player 已经赢得了 2,000 硬币。player 的钱包现在有 2,100 硬币，bank 只剩余 7,900 硬币。</p>


<pre><code>playerOne = nil
println("PlayerOne has left the game")
// 输出 "PlayerOne has left the game"
println("The bank now has \(Bank.coinsInBank) coins")
// 输出 "The bank now has 10000 coins"
</code></pre>


<p>玩家现在已经离开了游戏。这表明是要将可选的<code>playerOne</code>变量设置为<code>nil</code>，意思是“没有<code>Player</code>实例”。当这种情况发生的时候，<code>playerOne</code>变量对<code>Player</code>实例的引用被破坏了。没有其它属性或者变量引用<code>Player</code>实例，因此为了清空它占用的内存从而释放它。在这发生前一步，其析构函数被自动调用，其硬币被返回到银行。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift构造过程]]></title>
    <link href="http://baxiang123.com//blog/Swift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift构造过程</id>
    <content type="html"><![CDATA[<p>构造过程是为了使用某个类、结构体或枚举类型的实例而进行的准备过程。这个过程包含了为实例中的每个属性设置初始值和为其执行必要的准备和初始化任务。</p>


<p>构造过程是通过定义构造器（<code>Initializers</code>）来实现的，这些构造器可以看做是用来创建特定类型实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。</p>


<!-- more -->


<p>类实例也可以通过定义析构器（<code>deinitializer</code>）在类实例释放之前执行特定的清除工作。想了解更多关于析构器的内容，请参考<a href="../chapter2/15_Deinitialization.html">析构过程</a>。</p>


<p><a name="setting_initial_values_for_stored_properties"></a></p>


<h2 id="-">存储型属性的初始赋值</h2>


<p>类和结构体在实例创建时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>


<p>你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。以下章节将详细介绍这两种方法。</p>


<blockquote>
<p>注意：</p>
<p>当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观测器（<code>property observers</code>）。</p>
</blockquote>


<h3 id="-">构造器</h3>


<p>构造器在创建某特定类型的新实例时调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字<code>init</code>命名。</p>


<p>下面例子中定义了一个用来保存华氏温度的结构体<code>Fahrenheit</code>，它拥有一个<code>Double</code>类型的存储型属性<code>temperature</code>：</p>


<pre><code>struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}

var f = Fahrenheit()
println("The default temperature is \(f.temperature)° Fahrenheit")
// 输出 "The default temperature is 32.0° Fahrenheit”
</code></pre>


<p>这个结构体定义了一个不带参数的构造器<code>init</code>，并在里面将存储型属性<code>temperature</code>的值初始化为<code>32.0</code>（华摄氏度下水的冰点）。</p>


<h3 id="-">默认属性值</h3>


<p>如前所述，你可以在构造器中为存储型属性设置初始值；同样，你也可以在属性声明时为其设置默认值。</p>


<blockquote>
<p>注意：</p>
<p>如果一个属性总是使用同一个初始值，可以为其设置一个默认值。无论定义默认值还是在构造器中赋值，最终它们实现的效果是一样的，只不过默认值跟属性构造过程结合的更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承（后续章节将讲到）等特性。</p>
</blockquote>


<p>你可以使用更简单的方式在定义结构体<code>Fahrenheit</code>时为属性<code>temperature</code>设置默认值：</p>


<pre><code>struct Fahrenheit {
    var temperature = 32.0
}
</code></pre>


<p><a name="customizing_initialization"></a></p>


<h2 id="-">定制化构造过程</h2>


<p>你可以通过输入参数和可选属性类型来定制构造过程，也可以在构造过程中修改常量属性。这些都将在后面章节中提到。</p>


<h3 id="-">构造参数</h3>


<p>你可以在定义构造器时提供构造参数，为其提供定制化构造所需值的类型和名字。构造器参数的功能和语法跟函数和方法参数相同。</p>


<p>下面例子中定义了一个包含摄氏度温度的结构体<code>Celsius</code>。它定义了两个不同的构造器：<code>init(fromFahrenheit:)</code>和<code>init(fromKelvin:)</code>，二者分别通过接受不同刻度表示的温度值来创建新的实例：</p>


<pre><code>struct Celsius {
    var temperatureInCelsius: Double = 0.0
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}

let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius 是 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius 是 0.0”
</code></pre>


<p>第一个构造器拥有一个构造参数，其外部名字为<code>fromFahrenheit</code>，内部名字为<code>fahrenheit</code>；第二个构造器也拥有一个构造参数，其外部名字为<code>fromKelvin</code>，内部名字为<code>kelvin</code>。这两个构造器都将唯一的参数值转换成摄氏温度值，并保存在属性<code>temperatureInCelsius</code>中。</p>


<h3 id="-">内部和外部参数名</h3>


<p>跟函数和方法参数相同，构造参数也存在一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>


<p>然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。所以在调用构造器时，主要通过构造器中的参数名和类型来确定需要调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为每个构造器的参数自动生成一个跟内部名字相同的外部名，就相当于在每个构造参数之前加了一个哈希符号。</p>


<blockquote>
<p>注意：</p>
<p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线<code>_</code>来显示描述它的外部名，以此覆盖上面所说的默认行为。</p>
</blockquote>


<p>以下例子中定义了一个结构体<code>Color</code>，它包含了三个常量：<code>red</code>、<code>green</code>和<code>blue</code>。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。</p>


<p><code>Color</code>提供了一个构造器，其中包含三个<code>Double</code>类型的构造参数：</p>


<pre><code>struct Color {
    let red = 0.0, green = 0.0, blue = 0.0
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
}
</code></pre>


<p>每当你创建一个新的<code>Color</code>实例，你都需要通过三种颜色的外部参数名来传值，并调用构造器。</p>


<pre><code>let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
</code></pre>


<p>注意，如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：</p>


<pre><code>let veryGreen = Color(0.0, 1.0, 0.0)
// 报编译时错误，需要外部名称
</code></pre>


<h3 id="-">可选属性类型</h3>


<p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性&#8211;不管是因为它无法在初始化时赋值，还是因为它可以在之后某个时间点可以赋值为空&#8211;你都需要将它定义为可选类型<code>optional type</code>。可选类型的属性将自动初始化为空<code>nil</code>，表示这个属性是故意在初始化时设置为空的。</p>


<p>下面例子中定义了类<code>SurveyQuestion</code>，它包含一个可选字符串属性<code>response</code>：</p>


<pre><code>class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        println(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// 输出 "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese.
</code></pre>


<p>调查问题在问题提出之后，我们才能得到回答。所以我们将属性回答<code>response</code>声明为<code>String?</code>类型，或者说是可选字符串类型<code>optional String</code>。当<code>SurveyQuestion</code>实例化时，它将自动赋值为空<code>nil</code>，表明暂时还不存在此字符串。</p>


<h3 id="-">构造过程中常量属性的修改</h3>


<p>只要在构造过程结束前常量的值能确定，你可以在构造过程中的任意时间点修改常量属性的值。</p>


<blockquote>
<p>注意：</p>
<p>对某个类实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>
</blockquote>


<p>你可以修改上面的<code>SurveyQuestion</code>示例，用常量属性替代变量属性<code>text</code>，指明问题内容<code>text</code>在其创建之后不会再被修改。尽管<code>text</code>属性现在是常量，我们仍然可以在其类的构造器中修改它的值：</p>


<pre><code>class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        println(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// 输出 "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)
</code></pre>


<p><a name="default_initializers"></a></p>


<h2 id="-">默认构造器</h2>


<p>Swift 将为所有属性已提供默认值的且自身没有定义任何构造器的结构体或基类，提供一个默认的构造器。这个默认构造器将简单的创建一个所有属性值都设置为默认值的实例。</p>


<p>下面例子中创建了一个类<code>ShoppingListItem</code>，它封装了购物清单中的某一项的属性：名字（<code>name</code>）、数量（<code>quantity</code>）和购买状态 <code>purchase state</code>。</p>


<pre><code>class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
</code></pre>


<p>由于<code>ShoppingListItem</code>类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器（尽管代码中没有显式为<code>name</code>属性设置默认值，但由于<code>name</code>是可选字符串类型，它将默认设置为<code>nil</code>）。上面例子中使用默认构造器创造了一个<code>ShoppingListItem</code>类的实例（使用<code>ShoppingListItem()</code>形式的构造器语法），并将其赋值给变量<code>item</code>。</p>


<h3 id="-">结构体的逐一成员构造器</h3>


<p>除上面提到的默认构造器，如果结构体对所有存储型属性提供了默认值且自身没有提供定制的构造器，它们能自动获得一个逐一成员构造器。</p>


<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>


<p>下面例子中定义了一个结构体<code>Size</code>，它包含两个属性<code>width</code>和<code>height</code>。Swift 可以根据这两个属性的初始赋值<code>0.0</code>自动推导出它们的类型<code>Double</code>。</p>


<p>由于这两个存储型属性都有默认值，结构体<code>Size</code>自动获得了一个逐一成员构造器 <code>init(width:height:)</code>。 你可以用它来为<code>Size</code>创建新的实例：</p>


<pre><code>struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</code></pre>


<p><a name="initializer_delegation_for_value_types"></a></p>


<h2 id="-">值类型的构造器代理</h2>


<p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。</p>


<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理任务给本身提供的其它构造器。类则不同，它可以继承自其它类（请参考<a href="../chapter2/13_Inheritance.html">继承</a>），这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。这些责任将在后续章节<a href="#class_inheritance_and_initialization">类的继承和构造过程</a>中介绍。</p>


<p>对于值类型，你可以使用<code>self.init</code>在自定义的构造器中引用其它的属于相同值类型的构造器。并且你只能在构造器内部调用<code>self.init</code>。</p>


<p>注意，如果你为某个值类型定义了一个定制的构造器，你将无法访问到默认构造器（如果是结构体，则无法访问逐一对象构造器）。这个限制可以防止你在为值类型定义了一个更复杂的，完成了重要准备构造器之后，别人还是错误的使用了那个自动生成的构造器。</p>


<blockquote>
<p>注意：</p>
<p>假如你想通过默认构造器、逐一对象构造器以及你自己定制的构造器为值类型创建实例，我们建议你将自己定制的构造器写到扩展（<code>extension</code>）中，而不是跟值类型定义混在一起。想查看更多内容，请查看<a href="../chapter2/20_Extensions.html">扩展</a>章节。</p>
</blockquote>


<p>下面例子将定义一个结构体<code>Rect</code>，用来展现几何矩形。这个例子需要两个辅助的结构体<code>Size</code>和<code>Point</code>，它们各自为其所有的属性提供了初始值<code>0.0</code>。</p>


<pre><code>struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
</code></pre>


<p>你可以通过以下三种方式为<code>Rect</code>创建实例&#8211;使用默认的0值来初始化<code>origin</code>和<code>size</code>属性；使用特定的<code>origin</code>和<code>size</code>实例来初始化；使用特定的<code>center</code>和<code>size</code>来初始化。在下面<code>Rect</code>结构体定义中，我们为着三种方式提供了三个自定义的构造器：</p>


<pre><code>struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>


<p>第一个<code>Rect</code>构造器<code>init()</code>，在功能上跟没有自定义构造器时自动获得的默认构造器是一样的。这个构造器是一个空函数，使用一对大括号<code>{}</code>来描述，它没有执行任何定制的构造过程。调用这个构造器将返回一个<code>Rect</code>实例，它的<code>origin</code>和<code>size</code>属性都使用定义时的默认值<code>Point(x: 0.0, y: 0.0)</code>和<code>Size(width: 0.0, height: 0.0)</code>：</p>


<pre><code>let basicRect = Rect()
// basicRect 的原点是 (0.0, 0.0)，尺寸是 (0.0, 0.0)
</code></pre>


<p>第二个<code>Rect</code>构造器<code>init(origin:size:)</code>，在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的。这个构造器只是简单的将<code>origin</code>和<code>size</code>的参数值赋给对应的存储型属性：</p>


<pre><code>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
// originRect 的原点是 (2.0, 2.0)，尺寸是 (5.0, 5.0)
</code></pre>


<p>第三个<code>Rect</code>构造器<code>init(center:size:)</code>稍微复杂一点。它先通过<code>center</code>和<code>size</code>的值计算出<code>origin</code>的坐标。然后再调用（或代理给）<code>init(origin:size:)</code>构造器来将新的<code>origin</code>和<code>size</code>值赋值到对应的属性中：</p>


<p>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect 的原点是 (2.5, 2.5)，尺寸是 (3.0, 3.0)</p>


<p>构造器<code>init(center:size:)</code>可以自己将<code>origin</code>和<code>size</code>的新值赋值到对应的属性中。然而尽量利用现有的构造器和它所提供的功能来实现<code>init(center:size:)</code>的功能，是更方便、更清晰和更直观的方法。</p>


<blockquote>
<p>注意：</p>
<p>如果你想用另外一种不需要自己定义<code>init()</code>和<code>init(origin:size:)</code>的方式来实现这个例子，请参考<a href="../chapter2/20_Extensions.html">扩展</a>。</p>
</blockquote>


<p><a name="class_inheritance_and_initialization"></a></p>


<h2 id="-">类的继承和构造过程</h2>


<p>类里面的所有存储型属性&#8211;包括所有继承自父类的属性&#8211;都必须在构造过程中设置初始值。</p>


<p>Swift 提供了两种类型的类构造器来确保所有类实例中存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。</p>


<h3 id="-">指定构造器和便利构造器</h3>


<p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。</p>


<p>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。具体内容请参考后续章节<a href="#automatic_initializer_inheritance">自动构造器的继承</a>。</p>


<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入的实例。</p>


<p>你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清、晰明。</p>


<p><a name="initialization_chain"></a></p>


<h3 id="-">构造器链</h3>


<p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>


<h4 id="-1">规则 1</h4>


<p>指定构造器必须调用其直接父类的的指定构造器。</p>


<h4 id="-2">规则 2</h4>


<p>便利构造器必须调用同一类中定义的其它构造器。</p>


<h4 id="-3">规则 3</h4>


<p>便利构造器必须最终以调用一个指定构造器结束。</p>


<p>一个更方便记忆的方法是：</p>


<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>


<p>这些规则可以通过下面图例来说明：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializerDelegation01_2x.png" alt="构造器代理图"></p>


<p>如图所示，父类中包含一个指定构造器和两个便利构造器。其中一个便利构造器调用了另外一个便利构造器，而后者又调用了唯一的指定构造器。这满足了上面提到的规则2和3。这个父类没有自己的父类，所以规则1没有用到。</p>


<p>子类中包含两个指定构造器和一个便利构造器。便利构造器必须调用两个指定构造器中的任意一个，因为它只能调用同一个类里的其他构造器。这满足了上面提到的规则2和3。而两个指定构造器必须调用父类中唯一的指定构造器，这满足了规则1。</p>


<blockquote>
<p>注意：</p>
<p>这些规则不会影响使用时，如何用类去创建实例。任何上图中展示的构造器都可以用来完整创建对应类的实例。这些规则只在实现类的定义时有影响。</p>
</blockquote>


<p>下面图例中展示了一种更复杂的类层级结构。它演示了指定构造器是如果在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的内部关系。</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializerDelegation02_2x.png" alt="复杂构造器代理图"></p>


<p><a name="two_phase_initialization"></a></p>


<h3 id="-">两段式构造过程</h3>


<p>Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性通过引入它们的类的构造器来设置初始值。当每一个存储型属性值被确定后，第二阶段开始，它给每个类一次机会在新实例准备使用之前进一步定制它们的存储型属性。</p>


<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问；也可以防止属性被另外一个构造器意外地赋予不同的值。</p>


<blockquote>
<p>注意：</p>
<p>Swift的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值<code>0</code>或空值（比如说<code>0</code>或<code>nil</code>）。Swift  的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以<code>0</code>或<code>nil</code>作为合法默认值的情况。</p>
</blockquote>


<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能顺利完成：</p>


<h4 id="-1">安全检查 1</h4>


<p>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</p>


<p>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</p>


<h4 id="-2">安全检查 2</h4>


<p>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>


<h4 id="-3">安全检查 3</h4>


<p>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</p>


<h4 id="-4">安全检查 4</h4>


<p>构造器在第一阶段构造完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用<code>self</code>的值。</p>


<p>以下是两段式构造过程中基于上述安全检查的构造流程展示：</p>


<h4 id="-1">阶段 1</h4>


<ul>
<li>某个指定构造器或便利构造器被调用；</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化；</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化；</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化；</li>
<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部；</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段1完成。</li>
</ul>


<h4 id="-2">阶段 2</h4>


<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问<code>self</code>、修改它的属性并调用实例方法等等。</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用<code>self</code>。</li>
</ul>


<p>下图展示了在假定的子类和父类之间构造的阶段1：
·
<img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/twoPhaseInitialization01_2x.png" alt="构造过程阶段1"></p>


<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。</p>


<p>如安全检查1所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着造器链一直往上完成父类的构建过程。</p>


<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要构建，也就无需继续向上做构建代理。</p>


<p>一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，而阶段1也已完成。</p>


<p>以下展示了相同构造过程的阶段2：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/twoPhaseInitialization02_2x.png" alt="构建过程阶段2"></p>


<p>父类中的指定构造器现在有机会进一步来定制实例（尽管它没有这种必要）。</p>


<p>一旦父类中的指定构造器完成调用，子类的构指定构造器可以执行更多的定制操作（同样，它也没有这种必要）。</p>


<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>


<h3 id="-">构造器的继承和重载</h3>


<p>跟 Objective-C 中的子类不同，Swift 中的子类不会默认继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更专业的子类继承，并被错误的用来创建子类的实例。</p>


<p>假如你希望自定义的子类中能实现一个或多个跟父类相同的构造器&#8211;也许是为了完成一些定制的构造过程&#8211;你可以在你定制的子类中提供和重载与父类相同的构造器。</p>


<p>如果你重载的构造器是一个指定构造器，你可以在子类里重载它的实现，并在自定义版本的构造器中调用父类版本的构造器。</p>


<p>如果你重载的构造器是一个便利构造器，你的重载过程必须通过调用同一类中提供的其它指定构造器来实现。这一规则的详细内容请参考<a href="#initialization_chain">构造器链</a>。</p>


<blockquote>
<p>注意：</p>
<p>与方法、属性和下标不同，在重载构造器时你没有必要使用关键字<code>override</code>。</p>
</blockquote>


<p><a name="automatic_initializer_inheritance"></a></p>


<h3 id="-">自动构造器的继承</h3>


<p>如上所述，子类不会默认继承父类的构造器。但是如果特定条件可以满足，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重载父类的构造器，并且在尽可能安全的情况下以最小的代价来继承父类的构造器。</p>


<p>假设要为子类中引入的任意新属性提供默认值，请遵守以下2个规则：</p>


<h4 id="-1">规则 1</h4>


<p>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</p>


<h4 id="-2">规则 2</h4>


<p>如果子类提供了所有父类指定构造器的实现&#8211;不管是通过规则1继承过来的，还是通过自定义实现的&#8211;它将自动继承所有父类的便利构造器。</p>


<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>


<blockquote>
<p>注意：</p>
<p>子类可以通过部分满足规则2的方式，使用子类便利构造器来实现父类的指定构造器。</p>
</blockquote>


<h3 id="-">指定构造器和便利构造器的语法</h3>


<p>类的指定构造器的写法跟值类型简单构造器一样：</p>


<pre><code>init(parameters) {
    statements
}
</code></pre>


<p>便利构造器也采用相同样式的写法，但需要在<code>init</code>关键字之前放置<code>convenience</code>关键字，并使用空格将它们俩分开：</p>


<pre><code>convenience init(parameters) {
    statements
}
</code></pre>


<h3 id="-">指定构造器和便利构造器实战</h3>


<p>接下来的例子将在实战中展示指定构造器、便利构造器和自动构造器的继承。它定义了包含三个类<code>Food</code>、<code>RecipeIngredient</code>以及<code>ShoppingListItem</code>的类层次结构，并将演示它们的构造器是如何相互作用的。</p>


<p>类层次中的基类是<code>Food</code>，它是一个简单的用来封装食物名字的类。<code>Food</code>类引入了一个叫做<code>name</code>的<code>String</code>类型属性，并且提供了两个构造器来创建<code>Food</code>实例：</p>


<pre><code>class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}
</code></pre>


<p>下图中展示了<code>Food</code>的构造器链：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample01_2x.png" alt="Food构造器链"></p>


<p>类没有提供一个默认的逐一成员构造器，所以<code>Food</code>类提供了一个接受单一参数<code>name</code>的指定构造器。这个构造器可以使用一个特定的名字来创建新的<code>Food</code>实例：</p>


<pre><code>let namedMeat = Food(name: "Bacon")
// namedMeat 的名字是 "Bacon”
</code></pre>


<p><code>Food</code>类中的构造器<code>init(name: String)</code>被定义为一个指定构造器，因为它能确保所有新<code>Food</code>实例的中存储型属性都被初始化。<code>Food</code>类没有父类，所以<code>init(name: String)</code>构造器不需要调用<code>super.init()</code>来完成构造。</p>


<p><code>Food</code>类同样提供了一个没有参数的便利构造器 <code>init()</code>。这个<code>init()</code>构造器为新食物提供了一个默认的占位名字，通过代理调用同一类中定义的指定构造器<code>init(name: String)</code>并给参数<code>name</code>传值<code>[Unnamed]</code>来实现：</p>


<pre><code>let mysteryMeat = Food()
// mysteryMeat 的名字是 [Unnamed]
</code></pre>


<p>类层级中的第二个类是<code>Food</code>的子类<code>RecipeIngredient</code>。<code>RecipeIngredient</code>类构建了食谱中的一味调味剂。它引入了<code>Int</code>类型的数量属性<code>quantity</code>（以及从<code>Food</code>继承过来的<code>name</code>属性），并且定义了两个构造器来创建<code>RecipeIngredient</code>实例：</p>


<pre><code>class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
</code></pre>


<p>下图中展示了<code>RecipeIngredient</code>类的构造器链：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample02_2x.png" alt="RecipeIngredient构造器"></p>


<p><code>RecipeIngredient</code>类拥有一个指定构造器<code>init(name: String, quantity: Int)</code>，它可以用来产生新<code>RecipeIngredient</code>实例的所有属性值。这个构造器一开始先将传入的<code>quantity</code>参数赋值给<code>quantity</code>属性，这个属性也是唯一在<code>RecipeIngredient</code>中新引入的属性。随后，构造器将任务向上代理给父类<code>Food</code>的<code>init(name: String)</code>。这个过程满足<a href="#two_phase_initialization">两段式构造过程</a>中的安全检查1。</p>


<p><code>RecipeIngredient</code>也定义了一个便利构造器<code>init(name: String)</code>，它只通过<code>name</code>来创建<code>RecipeIngredient</code>的实例。这个便利构造器假设任意<code>RecipeIngredient</code>实例的<code>quantity</code>为1，所以不需要显示指明数量即可创建出实例。这个便利构造器的定义可以让创建实例更加方便和快捷，并且避免了使用重复的代码来创建多个<code>quantity</code>为 1 的<code>RecipeIngredient</code>实例。这个便利构造器只是简单的将任务代理给了同一类里提供的指定构造器。</p>


<p>注意，<code>RecipeIngredient</code>的便利构造器<code>init(name: String)</code>使用了跟<code>Food</code>中指定构造器<code>init(name: String)</code>相同的参数。尽管<code>RecipeIngredient</code>这个构造器是便利构造器，<code>RecipeIngredient</code>依然提供了对所有父类指定构造器的实现。因此，<code>RecipeIngredient</code>也能自动继承了所有父类的便利构造器。</p>


<p>在这个例子中，<code>RecipeIngredient</code>的父类是<code>Food</code>，它有一个便利构造器<code>init()</code>。这个构造器因此也被<code>RecipeIngredient</code>继承。这个继承的<code>init()</code>函数版本跟<code>Food</code>提供的版本是一样的，除了它是将任务代理给<code>RecipeIngredient</code>版本的<code>init(name: String)</code>而不是<code>Food</code>提供的版本。</p>


<p>所有的这三种构造器都可以用来创建新的<code>RecipeIngredient</code>实例：</p>


<pre><code>let oneMysteryItem = RecipeIngredient()
let oneBacon = RecipeIngredient(name: "Bacon")
let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)
</code></pre>


<p>类层级中第三个也是最后一个类是<code>RecipeIngredient</code>的子类，叫做<code>ShoppingListItem</code>。这个类构建了购物单中出现的某一种调味料。</p>


<p>购物单中的每一项总是从<code>unpurchased</code>未购买状态开始的。为了展现这一事实，<code>ShoppingListItem</code>引入了一个布尔类型的属性<code>purchased</code>，它的默认值是<code>false</code>。<code>ShoppingListItem</code>还添加了一个计算型属性<code>description</code>，它提供了关于<code>ShoppingListItem</code>实例的一些文字描述：</p>


<pre><code>class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
    var output = "\(quantity) x \(name.lowercaseString)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}
</code></pre>


<blockquote>
<p>注意：</p>
<p><code>ShoppingListItem</code>没有定义构造器来为<code>purchased</code>提供初始化值，这是因为任何添加到购物单的项的初始状态总是未购买。</p>
</blockquote>


<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code>将自动继承所有父类中的指定构造器和便利构造器。</p>


<p>下图种展示了所有三个类的构造器链：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample03_2x.png" alt="三类构造器图"></p>


<p>你可以使用全部三个继承来的构造器来创建<code>ShoppingListItem</code>的新实例：</p>


<pre><code>var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Bacon"),
    ShoppingListItem(name: "Eggs", quantity: 6),
]
breakfastList[0].name = "Orange juice"
breakfastList[0].purchased = true
for item in breakfastList {
    println(item.description)
}
// 1 x orange juice ✔
// 1 x bacon ✘
// 6 x eggs ✘
</code></pre>


<p>如上所述，例子中通过字面量方式创建了一个新数组<code>breakfastList</code>，它包含了三个新的<code>ShoppingListItem</code>实例，因此数组的类型也能自动推导为<code>ShoppingListItem[]</code>。在数组创建完之后，数组中第一个<code>ShoppingListItem</code>实例的名字从<code>[Unnamed]</code>修改为<code>Orange juice</code>，并标记为已购买。接下来通过遍历数组每个元素并打印它们的描述值，展示了所有项当前的默认状态都已按照预期完成了赋值。</p>


<p><a name="setting_a_default_property_value_with_a_closure_or_function"></a></p>


<h2 id="-">通过闭包和函数来设置属性的默认值</h2>


<p>如果某个存储型属性的默认值需要特别的定制或准备，你就可以使用闭包或全局函数来为其属性提供定制的默认值。每当某个属性所属的新类型实例创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>


<p>这种类型的闭包或函数一般会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后将这个临时变量的值作为属性的默认值进行返回。</p>


<p>下面列举了闭包如何提供默认值的代码概要：</p>


<pre><code>class SomeClass {
    let someProperty: SomeType = {
        // 在这个闭包中给 someProperty 创建一个默认值
        // someValue 必须和 SomeType 类型相同
        return someValue
        }()
}
</code></pre>


<p>注意闭包结尾的大括号后面接了一对空的小括号。这是用来告诉 Swift 需要立刻执行此闭包。如果你忽略了这对括号，相当于是将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>


<blockquote>
<p>注意：</p>
<p>如果你使用闭包来初始化属性的值，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能够在闭包里访问其它的属性，就算这个属性有默认值也不允许。同样，你也不能使用隐式的<code>self</code>属性，或者调用其它的实例方法。</p>
</blockquote>


<p>下面例子中定义了一个结构体<code>Checkerboard</code>，它构建了西洋跳棋游戏的棋盘：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/checkersBoard_2x.png" alt="西洋跳棋棋盘"></p>


<p>西洋跳棋游戏在一副黑白格交替的 10x10 的棋盘中进行。为了呈现这副游戏棋盘，<code>Checkerboard</code>结构体定义了一个属性<code>boardColors</code>，它是一个包含 100 个布尔值的数组。数组中的某元素布尔值为<code>true</code>表示对应的是一个黑格，布尔值为<code>false</code>表示对应的是一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。</p>


<p><code>boardColor</code>数组是通过一个闭包来初始化和组装颜色值的：</p>


<pre><code>struct Checkerboard {
    let boardColors: Bool[] = {
        var temporaryBoard = Bool[]()
        var isBlack = false
        for i in 1...10 {
            for j in 1...10 {
                temporaryBoard.append(isBlack)
                isBlack = !isBlack
            }
            isBlack = !isBlack
        }
        return temporaryBoard
        }()
    func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
        return boardColors[(row * 10) + column]
    }
}
</code></pre>


<p>每当一个新的<code>Checkerboard</code>实例创建时，对应的赋值闭包会执行，一系列颜色值会被计算出来作为默认值赋值给<code>boardColors</code>。上面例子中描述的闭包将计算出棋盘中每个格子合适的颜色，将这些颜色值保存到一个临时数组<code>temporaryBoard</code>中，并在构建完成时将此数组作为闭包返回值返回。这个返回的值将保存到<code>boardColors</code>中，并可以通<code>squareIsBlackAtRow</code>这个工具函数来查询。</p>


<pre><code>let board = Checkerboard()
println(board.squareIsBlackAtRow(0, column: 1))
// 输出 "true"
println(board.squareIsBlackAtRow(9, column: 9))
// 输出 "false"
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift方法]]></title>
    <link href="http://baxiang123.com//blog/Swift%E6%96%B9%E6%B3%95.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift方法</id>
    <content type="html"><![CDATA[<p><strong>方法</strong>是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。</p>


<p>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活的在你创建的类型（类/结构体/枚举）上定义方法。</p>


<!-- more -->


<p><a name="instance_methods"></a></p>


<h2 id="-instance-methods-">实例方法(Instance Methods)</h2>


<p><strong>实例方法</strong>是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致，详情参见<a href="../charpter2/06_Functions.html">函数</a>。</p>


<p>实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法不能脱离于现存的实例而被调用。</p>


<p>下面的例子，定义一个很简单的类<code>Counter</code>，<code>Counter</code>能被用来对一个动作发生的次数进行计数：</p>


<pre><code>class Counter {
  var count = 0
  func increment() {
    count++
  }
  func incrementBy(amount: Int) {
    count += amount
  }
  func reset() {
    count = 0
  }
}
</code></pre>


<p><code>Counter</code>类定义了三个实例方法：</p>


<ul>
<li><code>increment</code>让计数器按一递增；</li>
<li><code>incrementBy(amount: Int)</code>让计数器按一个指定的整数值递增；</li>
<li><code>reset</code>将计数器重置为0。</li>
</ul>


<p><code>Counter</code>这个类还声明了一个可变属性<code>count</code>，用它来保持对当前计数器值的追踪。</p>


<p>和调用属性一样，用点语法（dot syntax）调用实例方法：</p>


<pre><code> let counter = Counter()
 // 初始计数值是0
 counter.increment()
 // 计数值现在是1
 counter.incrementBy(5)
 // 计数值现在是6
 counter.reset()
 // 计数值现在是0
</code></pre>


<p><a name="local_and_external_parameter"></a></p>


<h3 id="-local-and-external-parameter-names-for-methods-">方法的局部参数名称和外部参数名称(Local and External Parameter Names for Methods)</h3>


<p>函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用），详情参见<a href="06_Functions.html">函数的外部参数名</a>。方法参数也一样（因为方法就是函数，只是这个函数与某个类型相关联了）。但是，方法和函数的局部名称和外部名称的默认行为是不一样的。</p>


<p>Swift 中的方法和 Objective-C 中的方法极其相似。像在 Objective-C 中一样，Swift 中方法的名称通常用一个介词指向方法的第一个参数，比如：<code>with</code>，<code>for</code>，<code>by</code>等等。前面的<code>Counter</code>类的例子中<code>incrementBy</code>方法就是这样的。介词的使用让方法在被调用时能像一个句子一样被解读。和函数参数不同，对于方法的参数，Swift 使用不同的默认处理方式，这可以让方法命名规范更容易写。</p>


<p>具体来说，Swift  默认仅给方法的第一个参数名称一个局部参数名称;默认同时给第二个和后续的参数名称局部参数名称和外部参数名称。这个约定与典型的命名和调用约定相适应，与你在写 Objective-C 的方法时很相似。这个约定还让表达式方法在调用时不需要再限定参数名称。</p>


<p>看看下面这个<code>Counter</code>的另一个版本（它定义了一个更复杂的<code>incrementBy</code>方法）：</p>


<pre><code>class Counter {
  var count: Int = 0
  func incrementBy(amount: Int, numberOfTimes: Int) {
    count += amount * numberOfTimes
  }
}
</code></pre>


<p><code>incrementBy</code>方法有两个参数： <code>amount</code>和<code>numberOfTimes</code>。默认情况下，Swift 只把<code>amount</code>当作一个局部名称，但是把<code>numberOfTimes</code>即看作局部名称又看作外部名称。下面调用这个方法：</p>


<pre><code>let counter = Counter()
counter.incrementBy(5, numberOfTimes: 3)
// counter value is now 15
</code></pre>


<p>你不必为第一个参数值再定义一个外部变量名：因为从函数名<code>incrementBy</code>已经能很清楚地看出它的作用。但是第二个参数，就要被一个外部参数名称所限定，以便在方法被调用时明确它的作用。</p>


<p>这种默认的行为能够有效的处理方法（method）,类似于在参数<code>numberOfTimes</code>前写一个井号（<code>#</code>）：</p>


<pre><code>func incrementBy(amount: Int, #numberOfTimes: Int) {
 count += amount * numberOfTimes
}
</code></pre>


<p>这种默认行为使上面代码意味着：在 Swift 中定义方法使用了与 Objective-C 同样的语法风格，并且方法将以自然表达式的方式被调用。</p>


<p><a name="modifying_external_parameter"></a></p>


<h3 id="-modifying-external-parameter-name-behavior-for-methods-">修改方法的外部参数名称(Modifying External Parameter Name Behavior for Methods)</h3>


<p>有时为方法的第一个参数提供一个外部参数名称是非常有用的，尽管这不是默认的行为。你可以自己添加一个显式的外部名称或者用一个井号（<code>#</code>）作为第一个参数的前缀来把这个局部名称当作外部名称使用。</p>


<p>相反，如果你不想为方法的第二个及后续的参数提供一个外部名称，可以通过使用下划线（<code>_</code>）作为该参数的显式外部名称，这样做将覆盖默认行为。</p>


<p><a name="self_property"></a></p>


<h2 id="-self-the-self-property-"><code>self</code>属性(The self Property)</h2>


<p>类型的每一个实例都有一个隐含属性叫做<code>self</code>，<code>self</code>完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的<code>self</code>属性来引用当前实例。</p>


<p>上面例子中的<code>increment</code>方法还可以这样写：</p>


<pre><code>func increment() {
  self.count++
}
</code></pre>


<p>实际上，你不必在你的代码里面经常写<code>self</code>。不论何时，只要在一个方法中使用一个已知的属性或者方法名称，如果你没有明确的写<code>self</code>，Swift 假定你是指当前实例的属性或者方法。这种假定在上面的<code>Counter</code>中已经示范了：<code>Counter</code>中的三个实例方法中都使用的是<code>count</code>（而不是<code>self.count</code>）。</p>


<p>使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用<code>self</code>属性来区分参数名称和属性名称。</p>


<p>下面的例子中，<code>self</code>消除方法参数<code>x</code>和实例属性<code>x</code>之间的歧义：</p>


<pre><code>struct Point {
  var x = 0.0, y = 0.0
  func isToTheRightOfX(x: Double) -&gt; Bool {
    return self.x &gt; x
  }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOfX(1.0) {
  println("This point is to the right of the line where x == 1.0")
}
// 输出 "This point is to the right of the line where x == 1.0"（这个点在x等于1.0这条线的右边）
</code></pre>


<p>如果不使用<code>self</code>前缀，Swift 就认为两次使用的<code>x</code>都指的是名称为<code>x</code>的函数参数。</p>


<p><a name="modifying_value_types"></a></p>


<h3 id="-modifying-value-types-from-within-instance-methods-">在实例方法中修改值类型(Modifying Value Types from Within Instance Methods)</h3>


<p>结构体和枚举是<strong>值类型</strong>。一般情况下，值类型的属性不能在它的实例方法中被修改。</p>


<p>但是，如果你确实需要在某个具体的方法中修改结构体或者枚举的属性，你可以选择<code>变异(mutating)</code>这个方法，然后方法就可以从方法内部改变它的属性；并且它做的任何改变在方法结束时还会保留在原始结构中。方法还可以给它隐含的<code>self</code>属性赋值一个全新的实例，这个新实例在方法结束后将替换原来的实例。</p>


<p>要使用<code>变异</code>方法， 将关键字<code>mutating</code> 放到方法的<code>func</code>关键字之前就可以了：</p>


<pre><code>struct Point {
  var x = 0.0, y = 0.0
  mutating func moveByX(deltaX: Double, y deltaY: Double) {
    x += deltaX
    y += deltaY
  }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveByX(2.0, y: 3.0)
println("The point is now at (\(somePoint.x), \(somePoint.y))")
// 输出 "The point is now at (3.0, 4.0)"
</code></pre>


<p>上面的<code>Point</code>结构体定义了一个变异方法（mutating method）<code>moveByX</code>，<code>moveByX</code>用来移动点。<code>moveByX</code>方法在被调用时修改了这个点，而不是返回一个新的点。方法定义时加上<code>mutating</code>关键字,这才让方法可以修改值类型的属性。</p>


<p>注意：不能在结构体类型常量上调用变异方法，因为常量的属性不能被改变，即使想改变的是常量的变量属性也不行，详情参见<a href="&quot;10_Properties.html&quot;">存储属性和实例变量</a></p>


<pre><code>let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveByX(2.0, y: 3.0)
// this will report an error
</code></pre>


<p><a name="mutating_method_self"></a></p>


<h3 id="-self-assigning-to-self-within-a-mutating-method-">在变异方法中给self赋值(Assigning to self Within a Mutating Method)</h3>


<p>变异方法能够赋给隐含属性<code>self</code>一个全新的实例。上面<code>Point</code>的例子可以用下面的方式改写：</p>


<pre><code>struct Point {
  var x = 0.0, y = 0.0
  mutating func moveByX(deltaX: Double, y deltaY: Double) {
    self = Point(x: x + deltaX, y: y + deltaY)
  }
}
</code></pre>


<p>新版的变异方法<code>moveByX</code>创建了一个新的结构（它的 x 和 y 的值都被设定为目标值）。调用这个版本的方法和调用上个版本的最终结果是一样的。</p>


<p>枚举的变异方法可以把<code>self</code>设置为相同的枚举类型中不同的成员：</p>


<pre><code>enum TriStateSwitch {
  case Off, Low, High
  mutating func next() {
    switch self {
    case Off:
      self = Low
    case Low:
      self = High
    case High:
      self = Off
    }
  }
}
var ovenLight = TriStateSwitch.Low
ovenLight.next()
// ovenLight 现在等于 .High
ovenLight.next()
// ovenLight 现在等于 .Off
</code></pre>


<p>上面的例子中定义了一个三态开关的枚举。每次调用<code>next</code>方法时，开关在不同的电源状态（<code>Off</code>，<code>Low</code>，<code>High</code>）之前循环切换。</p>


<p><a name="type_methods"></a></p>


<h2 id="-type-methods-">类型方法(Type Methods)</h2>


<p>实例方法是被类型的某个实例调用的方法。你也可以定义类型本身调用的方法，这种方法就叫做<strong>类型方法</strong>。声明类的类型方法，在方法的<code>func</code>关键字之前加上关键字<code>class</code>；声明结构体和枚举的类型方法，在方法的<code>func</code>关键字之前加上关键字<code>static</code>。</p>


<blockquote>
<p>注意：</p>
<p>在 Objective-C 里面，你只能为 Objective-C 的类定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法：每一个类型方法都被它所支持的类型显式包含。</p>
</blockquote>


<p>类型方法和实例方法一样用点语法调用。但是，你是在类型层面上调用这个方法，而不是在实例层面上调用。下面是如何在<code>SomeClass</code>类上调用类型方法的例子：</p>


<pre><code>class SomeClass {
  class func someTypeMethod() {
    // type method implementation goes here
  }
}
SomeClass.someTypeMethod()
</code></pre>


<p>在类型方法的方法体（body）中，<code>self</code>指向这个类型本身，而不是类型的某个实例。对于结构体和枚举来说，这意味着你可以用<code>self</code>来消除静态属性和静态方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。</p>


<p>一般来说，任何未限定的方法和属性名称，将会来自于本类中另外的类型级别的方法和属性。一个类型方法可以调用本类中另一个类型方法的名称，而无需在方法名称前面加上类型名称的前缀。同样，结构体和枚举的类型方法也能够直接通过静态属性的名称访问静态属性，而不需要类型名称前缀。</p>


<p>下面的例子定义了一个名为<code>LevelTracker</code>结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p>


<p>游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。<code>LevelTracker</code>结构体用静态属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</p>


<pre><code>struct LevelTracker {
  static var highestUnlockedLevel = 1
  static func unlockLevel(level: Int) {
    if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
  }
  static func levelIsUnlocked(level: Int) -&gt; Bool {
    return level &lt;= highestUnlockedLevel
  }
  var currentLevel = 1
  mutating func advanceToLevel(level: Int) -&gt; Bool {
    if LevelTracker.levelIsUnlocked(level) {
      currentLevel = level
      return true
    } else {
      return false
    }
  }
}
</code></pre>


<p><code>LevelTracker</code>监测玩家的已解锁的最高等级。这个值被存储在静态属性<code>highestUnlockedLevel</code>中。</p>


<p><code>LevelTracker</code>还定义了两个类型方法与<code>highestUnlockedLevel</code>配合工作。第一个类型方法是<code>unlockLevel</code>：一旦新等级被解锁，它会更新<code>highestUnlockedLevel</code>的值。第二个类型方法是<code>levelIsUnlocked</code>：如果某个给定的等级已经被解锁，它将返回<code>true</code>。（注意：尽管我们没有使用类似<code>LevelTracker.highestUnlockedLevel</code>的写法，这个类型方法还是能够访问静态属性<code>highestUnlockedLevel</code>）</p>


<p>除了静态属性和类型方法，<code>LevelTracker</code>还监测每个玩家的进度。它用实例属性<code>currentLevel</code>来监测玩家当前的等级。</p>


<p>为了便于管理<code>currentLevel</code>属性，<code>LevelTracker</code>定义了实例方法<code>advanceToLevel</code>。这个方法会在更新<code>currentLevel</code>之前检查所请求的新等级是否已经解锁。<code>advanceToLevel</code>方法返回布尔值以指示是否能够设置<code>currentLevel</code>。</p>


<p>下面，<code>Player</code>类使用<code>LevelTracker</code>来监测和更新每个玩家的发展进度：</p>


<pre><code>class Player {
  var tracker = LevelTracker()
  let playerName: String
  func completedLevel(level: Int) {
    LevelTracker.unlockLevel(level + 1)
    tracker.advanceToLevel(level + 1)
  }
  init(name: String) {
    playerName = name
  }
}
</code></pre>


<p><code>Player</code>类创建一个新的<code>LevelTracker</code>实例来监测这个用户的发展进度。他提供了<code>completedLevel</code>方法：一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了<code>advanceToLevel</code>返回的布尔值，因为之前调用<code>LevelTracker.unlockLevel</code>时就知道了这个等级已经被解锁了）。</p>


<p>你还可以为一个新的玩家创建一个<code>Player</code>的实例，然后看这个玩家完成等级一时发生了什么：</p>


<pre><code>var player = Player(name: "Argyrios")
player.completedLevel(1)
println("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")
// 输出 "highest unlocked level is now 2"（最高等级现在是2
）
</code></pre>


<p>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么这次设置玩家当前等级的尝试将会失败：</p>


<pre><code>player = Player(name: "Beto")
if player.tracker.advanceToLevel(6) {
println("player is now on level 6")
} else {
println("level 6 has not yet been unlocked")
}
// 输出 "level 6 has not yet been unlocked"（等级6还没被解锁）
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift控制流]]></title>
    <link href="http://baxiang123.com//blog/Swift%E6%8E%A7%E5%88%B6%E6%B5%81.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift控制流</id>
    <content type="html"><![CDATA[<p>Swift提供了类似 C 语言的流程控制结构，包括可以多次执行任务的<code>for</code>和<code>while</code>循环，基于特定条件选择执行不同代码分支的<code>if</code>和<code>switch</code>语句，还有控制流程跳转到其他代码的<code>break</code>和<code>continue</code>语句。</p>


<!-- more -->


<p>除了 C 语言里面传统的for条件递增（<code>for-condition-increment</code>）循环，Swift 还增加了<code>for-in</code>循环，用来更简单地遍历数组（array），字典（dictionary），区间（range），字符串（string）和其他序列类型。</p>


<p>Swift 的<code>switch</code>语句比 C 语言中更加强大。在 C 语言中，如果某个 case 不小心漏写了<code>break</code>，这个 case 就会贯穿（fallthrough）至下一个 case，Swift 无需写<code>break</code>，所以不会发生这种贯穿（fallthrough）的情况。case 还可以匹配更多的类型模式，包括区间匹配（range matching），元组（tuple）和特定类型的描述。<code>switch</code>的 case 语句中匹配的值可以是由 case 体内部临时的常量或者变量决定，也可以由<code>where</code>分句描述更复杂的匹配条件。</p>


<p><a name="for_loops"></a></p>


<h2 id="for-">For 循环</h2>


<p><code>for</code>循环用来按照指定的次数多次执行一系列语句。Swift 提供两种<code>for</code>循环形式：</p>


<ul>
<li><p><code>for-in</code>用来遍历一个区间（range），序列（sequence），集合（collection），系列（progression）里面所有的元素执行一系列语句。</p>
</li>
<li><p>for条件递增（<code>for-condition-increment</code>）语句，用来重复执行一系列语句直到达成特定条件达成，一般通过在每次循环完成后增加计数器的值来实现。</p>
</li>
</ul>


<p><a name="for_in"></a></p>


<h3 id="for-in">For-In</h3>


<p>你可以使用<code>for-in</code>循环来遍历一个集合里面的所有元素，例如由数字表示的区间、数组中的元素、字符串中的字符。</p>


<p>下面的例子用来输出乘 5 乘法表前面一部分内容：</p>


<pre><code class="lang-swift">for index in 1...5 {
    println("\(index) times 5 is \(index * 5)")
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25
</code></pre>


<p>例子中用来进行遍历的元素是一组使用闭区间操作符（<code>...</code>）表示的从<code>1</code>到<code>5</code>的数字。<code>index</code>被赋值为闭区间中的第一个数字（<code>1</code>），然后循环中的语句被执行一次。在本例中，这个循环只包含一个语句，用来输出当前<code>index</code>值所对应的乘 5 乘法表结果。该语句执行后，<code>index</code>的值被更新为闭区间中的第二个数字（<code>2</code>），之后<code>println</code>方法会再执行一次。整个过程会进行到闭区间结尾为止。</p>


<p>上面的例子中，<code>index</code>是一个每次循环遍历开始时被自动赋值的常量。这种情况下，<code>index</code>在使用前不需要声明，只需要将它包含在循环的声明中，就可以对其进行隐式声明，而无需使用<code>let</code>关键字声明。</p>


<blockquote>
<p>注意：</p>
<p><code>index</code>常量只存在于循环的生命周期里。如果你想在循环完成后访问<code>index</code>的值，又或者想让<code>index</code>成为一个变量而不是常量，你必须在循环之前自己进行声明。</p>
</blockquote>


<p>如果你不需要知道区间内每一项的值，你可以使用下划线（<code>_</code>）替代变量名来忽略对值的访问：</p>


<pre><code class="lang-swift">let base = 3
let power = 10
var answer = 1
for _ in 1...power {
    answer *= base
}
println("\(base) to the power of \(power) is \(answer)")
// 输出 "3 to the power of 10 is 59049"
</code></pre>


<p>这个例子计算 base 这个数的 power 次幂（本例中，是<code>3</code>的<code>10</code>次幂），从<code>1</code>（<code>3</code>的<code>0</code>次幂）开始做<code>3</code>的乘法， 进行<code>10</code>次，使用<code>0</code>到<code>9</code>的半闭区间循环。这个计算并不需要知道每一次循环中计数器具体的值，只需要执行了正确的循环次数即可。下划线符号<code>_</code>（替代循环中的变量）能够忽略具体的值，并且不提供循环遍历时对值的访问。</p>


<p>使用<code>for-in</code>遍历一个数组所有元素：</p>


<pre><code class="lang-swift">let names = ["Anna", "Alex", "Brian", "Jack"]
for name in names {
    println("Hello, \(name)!")
}
// Hello, Anna!
// Hello, Alex!
// Hello, Brian!
// Hello, Jack!
</code></pre>


<p>你也可以通过遍历一个字典来访问它的键值对（key-value pairs）。遍历字典时，字典的每项元素会以<code>(key, value)</code>元组的形式返回，你可以在<code>for-in</code>循环中使用显式的常量名称来解读<code>(key, value)</code>元组。下面的例子中，字典的键（key）解读为常量<code>animalName</code>，字典的值会被解读为常量<code>legCount</code>：</p>


<pre><code class="lang-swift">let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
for (animalName, legCount) in numberOfLegs {
    println("\(animalName)s have \(legCount) legs")
}
// spiders have 8 legs
// ants have 6 legs
// cats have 4 legs
</code></pre>


<p>字典元素的遍历顺序和插入顺序可能不同，字典的内容在内部是无序的，所以遍历元素时不能保证顺序。关于数组和字典，详情参见<a href="../chapter2/04_Collection_Types.html">集合类型</a>。</p>


<p>除了数组和字典，你也可以使用<code>for-in</code>循环来遍历字符串中的字符（<code>Character</code>）：</p>


<pre><code class="lang-swift">for character in "Hello" {
    println(character)
}
// H
// e
// l
// l
// o
</code></pre>


<p><a name="for_condition_increment"></a></p>


<h3 id="for-for-condition-increment-">For条件递增（for-condition-increment）</h3>


<p>除了<code>for-in</code>循环，Swift 提供使用条件判断和递增方法的标准 C 样式<code>for</code>循环:</p>


<pre><code class="lang-swift">for var index = 0; index &lt; 3; ++index {
    println("index is \(index)")
}
// index is 0
// index is 1
// index is 2
</code></pre>


<p>下面是一般情况下这种循环方式的格式：</p>


<pre><code class="lang-swift">for `initialization`; `condition`; `increment` {
    `statements`
}
</code></pre>


<p>和 C 语言中一样，分号将循环的定义分为 3 个部分，不同的是，Swift 不需要使用圆括号将“initialization; condition; increment”包括起来。</p>


<p>这个循环执行流程如下：</p>


<ol>
<li>循环首次启动时，初始化表达式（<em>initialization expression</em>）被调用一次，用来初始化循环所需的所有常量和变量。</li>
<li>条件表达式（<em>condition expression</em>）被调用，如果表达式调用结果为<code>false</code>，循环结束，继续执行<code>for</code>循环关闭大括号
（<code>}</code>）之后的代码。如果表达式调用结果为<code>true</code>，则会执行大括号内部的代码（<em>statements</em>）。</li>
<li>执行所有语句（<em>statements</em>）之后，执行递增表达式（<em>increment expression</em>）。通常会增加或减少计数器的值，或者根据语句（<em>statements</em>）输出来修改某一个初始化的变量。当递增表达式运行完成后，重复执行第 2 步，条件表达式会再次执行。</li>
</ol>


<p>上述描述和循环格式等同于：</p>


<pre><code class="lang-swift">`initialization`
while `condition` {
    `statements`
    `increment`
}
</code></pre>


<p>在初始化表达式中声明的常量和变量（比如<code>var index = 0</code>）只在<code>for</code>循环的生命周期里有效。如果想在循环结束后访问<code>index</code>的值，你必须要在循环生命周期开始前声明<code>index</code>。</p>


<pre><code class="lang-swift">var index: Int
for index = 0; index &lt; 3; ++index {
    println("index is \(index)")
}
// index is 0
// index is 1
// index is 2
println("The loop statements were executed \(index) times")
// 输出 "The loop statements were executed 3 times
</code></pre>


<p>注意<code>index</code>在循环结束后最终的值是<code>3</code>而不是<code>2</code>。最后一次调用递增表达式<code>++index</code>会将<code>index</code>设置为<code>3</code>，从而导致<code>index &lt; 3</code>条件为<code>false</code>，并终止循环。</p>


<p><a name="while_loops"></a></p>


<h2 id="while-">While 循环</h2>


<p><code>while</code>循环运行一系列语句直到条件变成<code>false</code>。这类循环适合使用在第一次迭代前迭代次数未知的情况下。Swift 提供两种<code>while</code>循环形式：</p>


<ul>
<li><p><code>while</code>循环，每次在循环开始时计算条件是否符合；</p>
</li>
<li><p><code>do-while</code>循环，每次在循环结束时计算条件是否符合。</p>
</li>
</ul>


<p><a name="while"></a></p>


<h3 id="while">While</h3>


<p><code>while</code>循环从计算单一条件开始。如果条件为<code>true</code>，会重复运行一系列语句，直到条件变为<code>false</code>。</p>


<p>下面是一般情况下 <code>while</code> 循环格式：</p>


<pre><code class="lang-swift">while `condition` {
    `statements`
}
</code></pre>


<p>下面的例子来玩一个叫做<em>蛇和梯子（Snakes and Ladders）</em>的小游戏，也叫做<em>滑道和梯子（Chutes and Ladders）</em>：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png" alt="image"></p>


<p>游戏的规则如下：</p>


<ul>
<li>游戏盘面包括 25 个方格，游戏目标是达到或者超过第 25 个方格；</li>
<li>每一轮，你通过掷一个 6 边的骰子来确定你移动方块的步数，移动的路线由上图中横向的虚线所示；</li>
<li>如果在某轮结束，你移动到了梯子的底部，可以顺着梯子爬上去；</li>
<li>如果在某轮结束，你移动到了蛇的头部，你会顺着蛇的身体滑下去。</li>
</ul>


<p>游戏盘面可以使用一个<code>Int</code>数组来表达。数组的长度由一个<code>finalSquare</code>常量储存，用来初始化数组和检测最终胜利条件。游戏盘面由 26 个 <code>Int</code> 0 值初始化，而不是 25 个（由<code>0</code>到<code>25</code>，一共 26 个）：</p>


<pre><code class="lang-swift">let finalSquare = 25
var board = Int[](count: finalSquare + 1, repeatedValue: 0)
</code></pre>


<p>一些方块被设置成有蛇或者梯子的指定值。梯子底部的方块是一个正值，使你可以向上移动，蛇头处的方块是一个负值，会让你向下移动：</p>


<pre><code class="lang-swift">board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
</code></pre>


<p>3 号方块是梯子的底部，会让你向上移动到 11 号方格，我们使用<code>board[03]</code>等于<code>+08</code>（来表示<code>11</code>和<code>3</code>之间的差值）。使用一元加运算符（<code>+i</code>）是为了和一元减运算符（<code>-i</code>）对称，为了让盘面代码整齐，小于 10 的数字都使用 0 补齐（这些风格上的调整都不是必须的，只是为了让代码看起来更加整洁）。</p>


<p>玩家由左下角编号为 0 的方格开始游戏。一般来说玩家第一次掷骰子后才会进入游戏盘面：</p>


<pre><code class="lang-swift">var square = 0
var diceRoll = 0
while square &lt; finalSquare {
    // 掷骰子
    if ++diceRoll == 7 { diceRoll = 1 }
    // 根据点数移动
    square += diceRoll
    if square &lt; board.count {
        // 如果玩家还在棋盘上，顺着梯子爬上去或者顺着蛇滑下去
        square += board[square]
    }
}
println("Game over!")
</code></pre>


<p>本例中使用了最简单的方法来模拟掷骰子。 <code>diceRoll</code>的值并不是一个随机数，而是以<code>0</code>为初始值，之后每一次<code>while</code>循环，<code>diceRoll</code>的值使用前置自增操作符(<code>++i</code>)来自增 1 ，然后检测是否超出了最大值。<code>++diceRoll</code>调用完成<em>后</em>，返回值等于<code>diceRoll</code>自增后的值。任何时候如果<code>diceRoll</code>的值等于7时，就超过了骰子的最大值，会被重置为<code>1</code>。所以<code>diceRoll</code>的取值顺序会一直是<code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>，<code>5</code>，<code>6</code>，<code>1</code>，<code>2</code>。</p>


<p>掷完骰子后，玩家向前移动<code>diceRoll</code>个方格，如果玩家移动超过了第 25 个方格，这个时候游戏结束，相应地，代码会在<code>square</code>增加<code>board[square]</code>的值向前或向后移动（遇到了梯子或者蛇）之前，检测<code>square</code>的值是否小于<code>board</code>的<code>count</code>属性。</p>


<p>如果没有这个检测（<code>square &lt; board.count</code>），<code>board[square]</code>可能会越界访问<code>board</code>数组，导致错误。例如如果<code>square</code>等于<code>26</code>， 代码会去尝试访问<code>board[26]</code>，超过数组的长度。</p>


<p>当本轮<code>while</code>循环运行完毕，会再检测循环条件是否需要再运行一次循环。如果玩家移动到或者超过第 25 个方格，循环条件结果为<code>false</code>，此时游戏结束。</p>


<p><code>while</code> 循环比较适合本例中的这种情况，因为在 <code>while</code> 循环开始时，我们并不知道游戏的长度或者循环的次数，只有在达成指定条件时循环才会结束。</p>


<p><a name="do_while"></a></p>


<h3 id="do-while">Do-While</h3>


<p><code>while</code>循环的另外一种形式是<code>do-while</code>，它和<code>while</code>的区别是在判断循环条件之前，先执行一次循环的代码块，然后重复循环直到条件为<code>false</code>。</p>


<p>下面是一般情况下 <code>do-while</code>循环的格式：</p>


<pre><code class="lang-swift">do {
    `statements`
} while `condition`
</code></pre>


<p>还是蛇和梯子的游戏，使用<code>do-while</code>循环来替代<code>while</code>循环。<code>finalSquare</code>、<code>board</code>、<code>square</code>和<code>diceRoll</code>的值初始化同<code>while</code>循环一样：</p>


<pre><code class="lang-swift">let finalSquare = 25
var board = Int[](count: finalSquare + 1, repeatedValue: 0)
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
var square = 0
var diceRoll = 0
</code></pre>


<p><code>do-while</code>的循环版本，循环中<em>第一步</em>就需要去检测是否在梯子或者蛇的方块上。没有梯子会让玩家直接上到第 25 个方格，所以玩家不会通过梯子直接赢得游戏。这样在循环开始时先检测是否踩在梯子或者蛇上是安全的。</p>


<p>游戏开始时，玩家在第 0 个方格上，<code>board[0]</code>一直等于 0， 不会有什么影响：</p>


<pre><code class="lang-swift">do {
    // 顺着梯子爬上去或者顺着蛇滑下去
    square += board[square]
    // 掷骰子
    if ++diceRoll == 7 { diceRoll = 1 }
    // 根据点数移动
    square += diceRoll
} while square &lt; finalSquare
println("Game over!")
</code></pre>


<p>检测完玩家是否踩在梯子或者蛇上之后，开始掷骰子，然后玩家向前移动<code>diceRoll</code>个方格，本轮循环结束。</p>


<p>循环条件（<code>while square &lt; finalSquare</code>）和<code>while</code>方式相同，但是只会在循环结束后进行计算。在这个游戏中，<code>do-while</code>表现得比<code>while</code>循环更好。<code>do-while</code>方式会在条件判断<code>square</code>没有超出后直接运行<code>square += board[square]</code>，这种方式可以去掉<code>while</code>版本中的数组越界判断。</p>


<p><a name="conditional_statement"></a></p>


<h2 id="-">条件语句</h2>


<p>根据特定的条件执行特定的代码通常是十分有用的，例如：当错误发生时，你可能想运行额外的代码；或者，当输入的值太大或太小时，向用户显示一条消息等。要实现这些功能，你就需要使用<em>条件语句</em>。</p>


<p>Swift 提供两种类型的条件语句：<code>if</code>语句和<code>switch</code>语句。通常，当条件较为简单且可能的情况很少时，使用<code>if</code>语句。而<code>switch</code>语句更适用于条件较复杂、可能情况较多且需要用到模式匹配（pattern-matching）的情境。</p>


<p><a name="if"></a></p>


<h3 id="if">If</h3>


<p><code>if</code>语句最简单的形式就是只包含一个条件，当且仅当该条件为<code>true</code>时，才执行相关代码：</p>


<pre><code class="lang-swift">var temperatureInFahrenheit = 30
if temperatureInFahrenheit &lt;= 32 {
    println("It's very cold. Consider wearing a scarf.")
}
// 输出 "It's very cold. Consider wearing a scarf."
</code></pre>


<p>上面的例子会判断温度是否小于等于 32 华氏度（水的冰点）。如果是，则打印一条消息；否则，不打印任何消息，继续执行<code>if</code>块后面的代码。</p>


<p>当然，<code>if</code>语句允许二选一，也就是当条件为<code>false</code>时，执行 <em>else 语句</em>：</p>


<pre><code class="lang-swift">temperatureInFahrenheit = 40
if temperatureInFahrenheit &lt;= 32 {
    println("It's very cold. Consider wearing a scarf.")
} else {
    println("It's not that cold. Wear a t-shirt.")
}
// 输出 "It's not that cold. Wear a t-shirt."
</code></pre>


<p>显然，这两条分支中总有一条会被执行。由于温度已升至 40 华氏度，不算太冷，没必要再围围巾——因此，<code>else</code>分支就被触发了。</p>


<p>你可以把多个<code>if</code>语句链接在一起，像下面这样：</p>


<pre><code class="lang-swift">temperatureInFahrenheit = 90
if temperatureInFahrenheit &lt;= 32 {
    println("It's very cold. Consider wearing a scarf.")
} else if temperatureInFahrenheit &gt;= 86 {
    println("It's really warm. Don't forget to wear sunscreen.")
} else {
    println("It's not that cold. Wear a t-shirt.")
}
// 输出 "It's really warm. Don't forget to wear sunscreen."
</code></pre>


<p>在上面的例子中，额外的<code>if</code>语句用于判断是不是特别热。而最后的<code>else</code>语句被保留了下来，用于打印既不冷也不热时的消息。</p>


<p>实际上，最后的<code>else</code>语句是可选的：</p>


<pre><code class="lang-swift">temperatureInFahrenheit = 72
if temperatureInFahrenheit &lt;= 32 {
    println("It's very cold. Consider wearing a scarf.")
} else if temperatureInFahrenheit &gt;= 86 {
    println("It's really warm. Don't forget to wear sunscreen.")
}
</code></pre>


<p>在这个例子中，由于既不冷也不热，所以不会触发<code>if</code>或<code>else if</code>分支，也就不会打印任何消息。</p>


<p><a name="switch"></a></p>


<h3 id="switch">Switch</h3>


<p><code>switch</code>语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，<code>switch</code>语句会执行对应的代码。当有可能的情况较多时，通常用<code>switch</code>语句替换<code>if</code>语句。</p>


<p><code>switch</code>语句最简单的形式就是把某个值与一个或若干个相同类型的值作比较：</p>


<pre><code class="lang-swift">switch `some value to consider` {
case `value 1`:
    `respond to value 1`
case `value 2`,
`value 3`:
    `respond to value 2 or 3`
default:
    `otherwise, do something else`
}
</code></pre>


<p><code>switch</code>语句都由<em>多个 case</em> 构成。为了匹配某些更特定的值，Swift 提供了几种更复杂的匹配模式，这些模式将在本节的稍后部分提到。</p>


<p>每一个 case 都是代码执行的一条分支，这与<code>if</code>语句类似。与之不同的是，<code>switch</code>语句会决定哪一条分支应该被执行。</p>


<p><code>switch</code>语句必须是<em>完备的</em>。这就是说，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值的情况下，你可以使用默认（<code>default</code>）分支满足该要求，这个默认分支必须在<code>switch</code>语句的最后面。</p>


<p>下面的例子使用<code>switch</code>语句来匹配一个名为<code>someCharacter</code>的小写字符：</p>


<pre><code class="lang-swift">let someCharacter: Character = "e"
switch someCharacter {
case "a", "e", "i", "o", "u":
    println("\(someCharacter) is a vowel")
case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
"n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
    println("\(someCharacter) is a consonant")
default:
    println("\(someCharacter) is not a vowel or a consonant")
}
// 输出 "e is a vowel"
</code></pre>


<p>在这个例子中，第一个 case 分支用于匹配五个元音，第二个 case 分支用于匹配所有的辅音。</p>


<p>由于为其它可能的字符写 case 分支没有实际的意义，因此在这个例子中使用了默认分支来处理剩下的既不是元音也不是辅音的字符——这就保证了<code>switch</code>语句的完备性。</p>


<p><a name="no_implicit_fallthrough"></a></p>


<h4 id="-no-implicit-fallthrough-">不存在隐式的贯穿（No Implicit Fallthrough）</h4>


<p>与 C 语言和 Objective-C 中的<code>switch</code>语句不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止<code>switch</code>语句，而不会继续执行下一个 case 分支。这也就是说，不需要在 case 分支中显式地使用<code>break</code>语句。这使得<code>switch</code>语句更安全、更易用，也避免了因忘记写<code>break</code>语句而产生的错误。</p>


<blockquote>
<p>注意：</p>
<p>你依然可以在 case 分支中的代码执行完毕前跳出，详情请参考<a href="#break_in_a_switch_statement">Switch 语句中的 break</a>。</p>
</blockquote>


<p>每一个 case 分支都<em>必须</em>包含至少一条语句。像下面这样书写代码是无效的，因为第一个 case 分支是空的：</p>


<pre><code class="lang-swift">let anotherCharacter: Character = "a"
switch anotherCharacter {
case "a":
case "A":
    println("The letter A")
default:
    println("Not the letter A")
}
// this will report a compile-time error
</code></pre>


<p>不像 C 语言里的<code>switch</code>语句，在 Swift 中，<code>switch</code>语句不会同时匹配<code>"a"</code>和<code>"A"</code>。相反的，上面的代码会引起编译期错误：<code>case "a": does not contain any executable statements</code>——这就避免了意外地从一个 case 分支贯穿到另外一个，使得代码更安全、也更直观。</p>


<p>一个 case 也可以包含多个模式，用逗号把它们分开（如果太长了也可以分行写）：</p>


<pre><code class="lang-swift">switch `some value to consider` {
case `value 1`,
`value 2`:
    `statements`
}
</code></pre>


<blockquote>
<p>注意：
如果想要贯穿至特定的 case 分支中，请使用<code>fallthrough</code>语句，详情请参考<a href="#fallthrough">贯穿（Fallthrough）</a>。</p>
</blockquote>


<p><a name="range_matching"></a></p>


<h4 id="-range-matching-">区间匹配（Range Matching）</h4>


<p>case 分支的模式也可以是一个值的区间。下面的例子展示了如何使用区间匹配来输出任意数字对应的自然语言格式：</p>


<pre><code class="lang-swift">let count = 3_000_000_000_000
let countedThings = "stars in the Milky Way"
var naturalCount: String
switch count {
case 0:
    naturalCount = "no"
case 1...3:
    naturalCount = "a few"
case 4...9:
    naturalCount = "several"
case 10...99:
    naturalCount = "tens of"
case 100...999:
    naturalCount = "hundreds of"
case 1000...999_999:
    naturalCount = "thousands of"
default:
    naturalCount = "millions and millions of"
}
println("There are \(naturalCount) \(countedThings).")
// 输出 "There are millions and millions of stars in the Milky Way."
</code></pre>


<p><a name="tuples"></a></p>


<h4 id="-tuple-">元组（Tuple）</h4>


<p>你可以使用元组在同一个<code>switch</code>语句中测试多个值。元组中的元素可以是值，也可以是区间。另外，使用下划线（<code>_</code>）来匹配所有可能的值。</p>


<p>下面的例子展示了如何使用一个<code>(Int, Int)</code>类型的元组来分类下图中的点(x, y)：</p>


<pre><code class="lang-swift">let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    println("(0, 0) is at the origin")
case (_, 0):
    println("(\(somePoint.0), 0) is on the x-axis")
case (0, _):
    println("(0, \(somePoint.1)) is on the y-axis")
case (-2...2, -2...2):
    println("(\(somePoint.0), \(somePoint.1)) is inside the box")
default:
    println("(\(somePoint.0), \(somePoint.1)) is outside of the box")
}
// 输出 "(1, 1) is inside the box"
</code></pre>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png" alt="image"></p>


<p>在上面的例子中，<code>switch</code>语句会判断某个点是否是原点(0, 0)，是否在红色的x轴上，是否在黄色y轴上，是否在一个以原点为中心的4x4的矩形里，或者在这个矩形外面。</p>


<p>不像 C 语言，Swift 允许多个 case 匹配同一个值。实际上，在这个例子中，点(0, 0)可以匹配所有<em>四个 case</em>。但是，如果存在多个匹配，那么只会执行第一个被匹配到的 case 分支。考虑点(0, 0)会首先匹配<code>case (0, 0)</code>，因此剩下的能够匹配(0, 0)的 case 分支都会被忽视掉。</p>


<p><a name="value_bindings"></a></p>


<h4 id="-value-bindings-">值绑定（Value Bindings）</h4>


<p>case 分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了——这种行为被称为<em>值绑定</em>（value binding）。</p>


<p>下面的例子展示了如何在一个<code>(Int, Int)</code>类型的元组中使用值绑定来分类下图中的点(x, y)：</p>


<pre><code class="lang-swift">let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    println("on the x-axis with an x value of \(x)")
case (0, let y):
    println("on the y-axis with a y value of \(y)")
case let (x, y):
    println("somewhere else at (\(x), \(y))")
}
// 输出 "on the x-axis with an x value of 2"
</code></pre>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png" alt="image"></p>


<p>在上面的例子中，<code>switch</code>语句会判断某个点是否在红色的x轴上，是否在黄色y轴上，或者不在坐标轴上。</p>


<p>这三个 case 都声明了常量<code>x</code>和<code>y</code>的占位符，用于临时获取元组<code>anotherPoint</code>的一个或两个值。第一个 case ——<code>case (let x, 0)</code>将匹配一个纵坐标为<code>0</code>的点，并把这个点的横坐标赋给临时的常量<code>x</code>。类似的，第二个 case ——<code>case (0, let y)</code>将匹配一个横坐标为<code>0</code>的点，并把这个点的纵坐标赋给临时的常量<code>y</code>。</p>


<p>一旦声明了这些临时的常量，它们就可以在其对应的 case 分支里引用。在这个例子中，它们用于简化<code>println</code>的书写。</p>


<p>请注意，这个<code>switch</code>语句不包含默认分支。这是因为最后一个 case ——<code>case let(x, y)</code>声明了一个可以匹配余下所有值的元组。这使得<code>switch</code>语句已经完备了，因此不需要再书写默认分支。</p>


<p>在上面的例子中，<code>x</code>和<code>y</code>是常量，这是因为没有必要在其对应的 case 分支中修改它们的值。然而，它们也可以是变量——程序将会创建临时变量，并用相应的值初始化它。修改这些变量只会影响其对应的 case 分支。</p>


<p><a name="where"></a></p>


<h4 id="where">Where</h4>


<p>case 分支的模式可以使用<code>where</code>语句来判断额外的条件。</p>


<p>下面的例子把下图中的点(x, y)进行了分类：</p>


<pre><code class="lang-swift">let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    println("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    println("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    println("(\(x), \(y)) is just some arbitrary point")
}
// 输出 "(1, -1) is on the line x == -y"
</code></pre>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png" alt="image"></p>


<p>在上面的例子中，<code>switch</code>语句会判断某个点是否在绿色的对角线<code>x == y</code>上，是否在紫色的对角线<code>x == -y</code>上，或者不在对角线上。</p>


<p>这三个 case 都声明了常量<code>x</code>和<code>y</code>的占位符，用于临时获取元组<code>yetAnotherPoint</code>的两个值。这些常量被用作<code>where</code>语句的一部分，从而创建一个动态的过滤器(filter)。当且仅当<code>where</code>语句的条件为<code>true</code>时，匹配到的 case 分支才会被执行。</p>


<p>就像是值绑定中的例子，由于最后一个 case 分支匹配了余下所有可能的值，<code>switch</code>语句就已经完备了，因此不需要再书写默认分支。</p>


<p><a name="control_transfer_statements"></a></p>


<h2 id="-control-transfer-statements-">控制传递语句（Control Transfer Statements）</h2>


<p>控制转移语句改变你代码的执行顺序，通过它你可以实现代码的跳转。Swift有四种控制转移语句。</p>


<ul>
<li>continue</li>
<li>break</li>
<li>fallthrough</li>
<li>return</li>
</ul>


<p>我们将会在下面讨论<code>continue</code>、<code>break</code>和<code>fallthrough</code>语句。<code>return</code>语句将会在<a href="../chapter2/06_Functions.html">函数</a>章节讨论。</p>


<p><a name="continue"></a></p>


<h3 id="continue">Continue</h3>


<p><code>continue</code>语句告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。就好像在说“本次循环迭代我已经执行完了”，但是并不会离开整个循环体。</p>


<blockquote>
<p>注意：</p>
<p>在一个for条件递增（<code>for-condition-increment</code>）循环体中，在调用<code>continue</code>语句后，迭代增量仍然会被计算求值。循环体继续像往常一样工作，仅仅只是循环体中的执行代码会被跳过。</p>
</blockquote>


<p>下面的例子把一个小写字符串中的元音字母和空格字符移除，生成了一个含义模糊的短句：</p>


<pre><code class="lang-swift">let puzzleInput = "great minds think alike"
var puzzleOutput = ""
for character in puzzleInput {
    switch character {
    case "a", "e", "i", "o", "u", " ":
        continue
    default:
        puzzleOutput += character
    }
}
println(puzzleOutput)
    // 输出 "grtmndsthnklk"
</code></pre>


<p>在上面的代码中，只要匹配到元音字母或者空格字符，就调用<code>continue</code>语句，使本次循环迭代结束，从新开始下次循环迭代。这种行为使<code>switch</code>匹配到元音字母和空格字符时不做处理，而不是让每一个匹配到的字符都被打印。</p>


<p><a name="break"></a></p>


<h3 id="break">Break</h3>


<p><code>break</code>语句会立刻结束整个控制流的执行。当你想要更早的结束一个<code>switch</code>代码块或者一个循环体时，你都可以使用<code>break</code>语句。</p>


<p><a name="break_in_a_loop_statement"></a></p>


<h4 id="-break">循环语句中的 break</h4>


<p>当在一个循环体中使用<code>break</code>时，会立刻中断该循环体的执行，然后跳转到表示循环体结束的大括号(<code>}</code>)后的第一行代码。不会再有本次循环迭代的代码被执行，也不会再有下次的循环迭代产生。</p>


<p><a name="break_in_a_switch_statement"></a></p>


<h4 id="switch-break">Switch 语句中的 break</h4>


<p>当在一个<code>switch</code>代码块中使用<code>break</code>时，会立即中断该<code>switch</code>代码块的执行，并且跳转到表示<code>switch</code>代码块结束的大括号(<code>}</code>)后的第一行代码。</p>


<p>这种特性可以被用来匹配或者忽略一个或多个分支。因为 Swift 的<code>switch</code>需要包含所有的分支而且不允许有为空的分支，有时为了使你的意图更明显，需要特意匹配或者忽略某个分支。那么当你想忽略某个分支时，可以在该分支内写上<code>break</code>语句。当那个分支被匹配到时，分支内的<code>break</code>语句立即结束<code>switch</code>代码块。</p>


<blockquote>
<p>注意：</p>
<p>当一个<code>switch</code>分支仅仅包含注释时，会被报编译时错误。注释不是代码语句而且也不能让<code>switch</code>分支达到被忽略的效果。你总是可以使用<code>break</code>来忽略某个分支。</p>
</blockquote>


<p>下面的例子通过<code>switch</code>来判断一个<code>Character</code>值是否代表下面四种语言之一。为了简洁，多个值被包含在了同一个分支情况中。</p>


<pre><code class="lang-swift">let numberSymbol: Character = "三"  // 简体中文里的数字 3
var possibleIntegerValue: Int?
switch numberSymbol {
case "1", "١", "一", "๑":
    possibleIntegerValue = 1
case "2", "٢", "二", "๒":
    possibleIntegerValue = 2
case "3", "٣", "三", "๓":
    possibleIntegerValue = 3
case "4", "٤", "四", "๔":
    possibleIntegerValue = 4
default:
    break
}
if let integerValue = possibleIntegerValue {
    println("The integer value of \(numberSymbol) is \(integerValue).")
} else {
    println("An integer value could not be found for \(numberSymbol).")
}
// 输出 "The integer value of 三 is 3."
</code></pre>


<p>这个例子检查<code>numberSymbol</code>是否是拉丁，阿拉伯，中文或者泰语中的<code>1</code>到<code>4</code>之一。如果被匹配到，该<code>switch</code>分支语句给<code>Int?</code>类型变量<code>possibleIntegerValue</code>设置一个整数值。</p>


<p>当<code>switch</code>代码块执行完后，接下来的代码通过使用可选绑定来判断<code>possibleIntegerValue</code>是否曾经被设置过值。因为是可选类型的缘故，<code>possibleIntegerValue</code>有一个隐式的初始值<code>nil</code>，所以仅仅当<code>possibleIntegerValue</code>曾被<code>switch</code>代码块的前四个分支中的某个设置过一个值时，可选的绑定将会被判定为成功。</p>


<p>在上面的例子中，想要把<code>Character</code>所有的的可能性都枚举出来是不现实的，所以使用<code>default</code>分支来包含所有上面没有匹配到字符的情况。由于这个<code>default</code>分支不需要执行任何动作，所以它只写了一条<code>break</code>语句。一旦落入到<code>default</code>分支中后，<code>break</code>语句就完成了该分支的所有代码操作，代码继续向下，开始执行<code>if let</code>语句。</p>


<p><a name="fallthrough"></a></p>


<h3 id="-fallthrough-">贯穿（Fallthrough）</h3>


<p>Swift 中的<code>switch</code>不会从上一个 case 分支落入到下一个 case 分支中。相反，只要第一个匹配到的 case 分支完成了它需要执行的语句，整个<code>switch</code>代码块完成了它的执行。相比之下，C 语言要求你显示的插入<code>break</code>语句到每个<code>switch</code>分支的末尾来阻止自动落入到下一个 case 分支中。Swift 的这种避免默认落入到下一个分支中的特性意味着它的<code>switch</code> 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 case 分支从而引发的错误。</p>


<p>如果你确实需要 C 风格的贯穿（fallthrough）的特性，你可以在每个需要该特性的 case 分支中使用<code>fallthrough</code>关键字。下面的例子使用<code>fallthrough</code>来创建一个数字的描述语句。</p>


<pre><code class="lang-swift">let integerToDescribe = 5
var description = "The number \(integerToDescribe) is"
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime number, and also"
    fallthrough
default:
    description += " an integer."
}
println(description)
// 输出 "The number 5 is a prime number, and also an integer."
</code></pre>


<p>这个例子定义了一个<code>String</code>类型的变量<code>description</code>并且给它设置了一个初始值。函数使用<code>switch</code>逻辑来判断<code>integerToDescribe</code>变量的值。当<code>integerToDescribe</code>的值属于列表中的质数之一时，该函数添加一段文字在<code>description</code>后，来表明这个是数字是一个质数。然后它使用<code>fallthrough</code>关键字来“贯穿”到<code>default</code>分支中。<code>default</code>分支添加一段额外的文字在<code>description</code>的最后，至此<code>switch</code>代码块执行完了。</p>


<p>如果<code>integerToDescribe</code>的值不属于列表中的任何质数，那么它不会匹配到第一个<code>switch</code>分支。而这里没有其他特别的分支情况，所以<code>integerToDescribe</code>匹配到包含所有的<code>default</code>分支中。</p>


<p>当<code>switch</code>代码块执行完后，使用<code>println</code>函数打印该数字的描述。在这个例子中，数字<code>5</code>被准确的识别为了一个质数。</p>


<blockquote>
<p>注意：</p>
<p><code>fallthrough</code>关键字不会检查它下一个将会落入执行的 case 中的匹配条件。<code>fallthrough</code>简单地使代码执行继续连接到下一个 case 中的执行代码，这和 C 语言标准中的<code>switch</code>语句特性是一样的。</p>
</blockquote>


<p><a name="labeled_statements"></a></p>


<h3 id="-labeled-statements-">带标签的语句（Labeled Statements）</h3>


<p>在 Swift 中，你可以在循环体和<code>switch</code>代码块中嵌套循环体和<code>switch</code>代码块来创造复杂的控制流结构。然而，循环体和<code>switch</code>代码块两者都可以使用<code>break</code>语句来提前结束整个方法体。因此，显示地指明<code>break</code>语句想要终止的是哪个循环体或者<code>switch</code>代码块，会很有用。类似地，如果你有许多嵌套的循环体，显示指明<code>continue</code>语句想要影响哪一个循环体也会非常有用。</p>


<p>为了实现这个目的，你可以使用标签来标记一个循环体或者<code>switch</code>代码块，当使用<code>break</code>或者<code>continue</code>时，带上这个标签，可以控制该标签代表对象的中断或者执行。</p>


<p>产生一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，并且该标签后面还需带着一个冒号。下面是一个<code>while</code>循环体的语法，同样的规则适用于所有的循环体和<code>switch</code>代码块。</p>


<pre><code>`label name`: while `condition` {
    `statements`
}
</code></pre>


<p>下面的例子是在一个带有标签的<code>while</code>循环体中调用<code>break</code>和<code>continue</code>语句，该循环体是前面章节中<em>蛇和梯子</em>的改编版本。这次，游戏增加了一条额外的规则：</p>


<ul>
<li>为了获胜，你必须<em>刚好</em>落在第 25 个方块中。</li>
</ul>


<p>如果某次掷骰子使你的移动超出第 25 个方块，你必须重新掷骰子，直到你掷出的骰子数刚好使你能落在第 25 个方块中。</p>


<p>游戏的棋盘和之前一样：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png" alt="image"></p>


<p>值<code>finalSquare</code>、<code>board</code>、<code>square</code>和<code>diceRoll</code>的初始化也和之前一样：</p>


<pre><code class="lang-swift">let finalSquare = 25
var board = Int[](count: finalSquare + 1, repeatedValue: 0)
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
var square = 0
var diceRoll = 0
</code></pre>


<p>这个版本的游戏使用<code>while</code>循环体和<code>switch</code>方法块来实现游戏的逻辑。<code>while</code>循环体有一个标签名<code>gameLoop</code>，来表明它是蛇与梯子的主循环。</p>


<p>该<code>while</code>循环体的条件判断语句是<code>while square !=finalSquare</code>，这表明你必须刚好落在方格25中。</p>


<pre><code class="lang-swift">gameLoop: while square != finalSquare {
    if ++diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // 到达最后一个方块，游戏结束
        break gameLoop
    case let newSquare where newSquare &gt; finalSquare:
        // 超出最后一个方块，再掷一次骰子
        continue gameLoop
    default:
        // 本次移动有效
        square += diceRoll
        square += board[square]
    }
}
println("Game over!")
</code></pre>


<p>每次循环迭代开始时掷骰子。与之前玩家掷完骰子就立即移动不同，这里使用了<code>switch</code>来考虑每次移动可能产生的结果，从而决定玩家本次是否能够移动。</p>


<ul>
<li><p>如果骰子数刚好使玩家移动到最终的方格里，游戏结束。<code>break gameLoop</code>语句跳转控制去执行<code>while</code>循环体后的第一行代码，游戏结束。</p>
</li>
<li><p>如果骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子。<code>continue gameLoop</code>语句结束本次<code>while</code>循环的迭代，开始下一次循环迭代。</p>
</li>
<li><p>在剩余的所有情况中，骰子数产生的都是合法的移动。玩家向前移动骰子数个方格，然后游戏逻辑再处理玩家当前是否处于蛇头或者梯子的底部。本次循环迭代结束，控制跳转到<code>while</code>循环体的条件判断语句处，再决定是否能够继续执行下次循环迭代。</p>
</li>
</ul>


<blockquote>
<p>注意：</p>
<p>如果上述的<code>break</code>语句没有使用<code>gameLoop</code>标签，那么它将会中断<code>switch</code>代码块而不是<code>while</code>循环体。使用<code>gameLoop</code>标签清晰的表明了<code>break</code>想要中断的是哪个代码块。
同时请注意，当调用<code>continue gameLoop</code>去跳转到下一次循环迭代时，这里使用<code>gameLoop</code>标签并不是严格必须的。因为在这个游戏中，只有一个循环体，所以<code>continue</code>语句会影响到哪个循环体是没有歧义的。然而，<code>continue</code>语句使用<code>gameLoop</code>标签也是没有危害的。这样做符合标签的使用规则，同时参照旁边的<code>break gameLoop</code>，能够使游戏的逻辑更加清晰和易于理解。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift扩展]]></title>
    <link href="http://baxiang123.com//blog/Swift%E6%89%A9%E5%B1%95.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift扩展</id>
    <content type="html"><![CDATA[<p><em>扩展</em>就是向一个已有的类、结构体或枚举类型添加新功能（functionality）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即<em>逆向建模</em>）。扩展和 Objective-C 中的分类（categories）类似。（不过与Objective-C不同的是，Swift 的扩展没有名字。）</p>


<!-- more -->


<p>Swift 中的扩展可以：</p>


<ul>
<li>添加计算型属性和计算静态属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个接口</li>
</ul>


<blockquote>
<p>注意：</p>
<p>如果你定义了一个扩展向一个已有类型添加新功能，那么这个新功能对该类型的所有已有实例中都是可用的，即使它们是在你的这个扩展的前面定义的。</p>
</blockquote>


<p><a name="extension_syntax"></a></p>


<h2 id="-extension-syntax-">扩展语法（Extension Syntax）</h2>


<p>声明一个扩展使用关键字<code>extension</code>：</p>


<pre><code>extension SomeType {
    // 加到SomeType的新功能写到这里
}
</code></pre>


<p>一个扩展可以扩展一个已有类型，使其能够适配一个或多个协议（protocol）。当这种情况发生时，接口的名字应该完全按照类或结构体的名字的方式进行书写：</p>


<pre><code>extension SomeType: SomeProtocol, AnotherProctocol {
    // 协议实现写到这里
}
</code></pre>


<p>按照这种方式添加的协议遵循者（protocol conformance）被称之为<a href="21_Protocols.html#adding_protocol_conformance_with_an_extension">在扩展中添加协议遵循者</a></p>


<p><a name="computed_properties"></a></p>


<h2 id="-computed-properties-">计算型属性（Computed Properties）</h2>


<p>扩展可以向已有类型添加计算型实例属性和计算型类型属性。下面的例子向 Swift 的内建<code>Double</code>类型添加了5个计算型实例属性，从而提供与距离单位协作的基本支持。</p>


<pre><code>extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
println("One inch is \(oneInch) meters")
// 打印输出："One inch is 0.0254 meters"
let threeFeet = 3.ft
println("Three feet is \(threeFeet) meters")
// 打印输出："Three feet is 0.914399970739201 meters"
</code></pre>


<p>这些计算属性表达的含义是把一个<code>Double</code>型的值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性仍可以接一个带有dot语法的浮点型字面值，而这恰恰是使用这些浮点型字面量实现距离转换的方式。</p>


<p>在上述例子中，一个<code>Double</code>型的值<code>1.0</code>被用来表示“1米”。这就是为什么<code>m</code>计算型属性返回<code>self</code>——表达式<code>1.m</code>被认为是计算<code>1.0</code>的<code>Double</code>值。</p>


<p>其它单位则需要一些转换来表示在米下测量的值。1千米等于1,000米，所以<code>km</code>计算型属性要把值乘以<code>1_000.00</code>来转化成单位米下的数值。类似地，1米有3.28024英尺，所以<code>ft</code>计算型属性要把对应的<code>Double</code>值除以<code>3.28024</code>来实现英尺到米的单位换算。</p>


<p>这些属性是只读的计算型属性，所有从简考虑它们不用<code>get</code>关键字表示。它们的返回值是<code>Double</code>型，而且可以用于所有接受<code>Double</code>的数学计算中：</p>


<pre><code>let aMarathon = 42.km + 195.m
println("A marathon is \(aMarathon) meters long")
// 打印输出："A marathon is 42495.0 meters long"
</code></pre>


<blockquote>
<p>注意：</p>
<p>扩展可以添加新的计算属性，但是不可以添加存储属性，也不可以向已有属性添加属性观测器(property observers)。</p>
</blockquote>


<p><a name="initializers"></a></p>


<h2 id="-initializers-">构造器（Initializers）</h2>


<p>扩展可以向已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为构造器参数，或者提供该类型的原始实现中没有包含的额外初始化选项。</p>


<blockquote>
<p>注意：</p>
<p>如果你使用扩展向一个值类型添加一个构造器，该构造器向所有的存储属性提供默认值，而且没有定义任何定制构造器（custom initializers），那么对于来自你的扩展构造器中的值类型，你可以调用默认构造器(default initializers)和成员级构造器(memberwise initializers)。
正如在值类型的构造器授权中描述的，如果你已经把构造器写成值类型原始实现的一部分，上述规则不再适用。</p>
</blockquote>


<p>下面的例子定义了一个用于描述几何矩形的定制结构体<code>Rect</code>。这个例子同时定义了两个辅助结构体<code>Size</code>和<code>Point</code>，它们都把<code>0.0</code>作为所有属性的默认值：</p>


<pre><code>struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</code></pre>


<p>因为结构体<code>Rect</code>提供了其所有属性的默认值，所以正如默认构造器中描述的，它可以自动接受一个默认的构造器和一个成员级构造器。这些构造器可以用于构造新的<code>Rect</code>实例：</p>


<pre><code>let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
</code></pre>


<p>你可以提供一个额外的使用特殊中心点和大小的构造器来扩展<code>Rect</code>结构体：</p>


<pre><code>extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
</code></pre>


<p>这个新的构造器首先根据提供的<code>center</code>和<code>size</code>值计算一个合适的原点。然后调用该结构体自动的成员构造器<code>init(origin:size:)</code>，该构造器将新的原点和大小存到了合适的属性中：</p>


<pre><code>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)
</code></pre>


<blockquote>
<p>注意：</p>
<p>如果你使用扩展提供了一个新的构造器，你依旧有责任保证构造过程能够让所有实例完全初始化。</p>
</blockquote>


<p><a name="methods"></a></p>


<h2 id="-methods-">方法（Methods）</h2>


<p>扩展可以向已有类型添加新的实例方法和类型方法。下面的例子向<code>Int</code>类型添加一个名为<code>repetitions</code>的新实例方法：</p>


<pre><code>extension Int {
    func repetitions(task: () -&gt; ()) {
        for i in 0..self {
            task()
        }
    }
}
</code></pre>


<p>这个<code>repetitions</code>方法使用了一个<code>() -&gt; ()</code>类型的单参数（single argument），表明函数没有参数而且没有返回值。</p>


<p>定义该扩展之后，你就可以对任意整数调用<code>repetitions</code>方法,实现的功能则是多次执行某任务：</p>


<pre><code>3.repetitions({
    println("Hello!")
    })
// Hello!
// Hello!
// Hello!
</code></pre>


<p>可以使用 trailing 闭包使调用更加简洁：</p>


<pre><code>3.repetitions{
    println("Goodbye!")
}
// Goodbye!
// Goodbye!
// Goodbye!
</code></pre>


<p><a name="mutating_instance_methods"></a></p>


<h3 id="-mutating-instance-methods-">修改实例方法（Mutating Instance Methods）</h3>


<p>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改<code>self</code>或其属性的方法必须将该实例方法标注为<code>mutating</code>，正如来自原始实现的修改方法一样。</p>


<p>下面的例子向Swift的<code>Int</code>类型添加了一个新的名为<code>square</code>的修改方法，来实现一个原始值的平方计算：</p>


<pre><code>extension Int {
    mutating func square() {
        self = self * self
    }
}
var someInt = 3
someInt.square()
// someInt 现在值是 9
</code></pre>


<p><a name="subscripts"></a></p>


<h2 id="-subscripts-">下标（Subscripts）</h2>


<p>扩展可以向一个已有类型添加新下标。这个例子向Swift内建类型<code>Int</code>添加了一个整型下标。该下标<code>[n]</code>返回十进制数字从右向左数的第n个数字</p>


<ul>
<li>123456789[0]返回9</li>
<li>123456789[1]返回8</li>
</ul>


<p>&#8230;等等</p>


<pre><code>extension Int {
    subscript(digitIndex: Int) -&gt; Int {
        var decimalBase = 1
            for _ in 1...digitIndex {
                decimalBase *= 10
            }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// returns 5
746381295[1]
// returns 9
746381295[2]
// returns 2
746381295[8]
// returns 7
</code></pre>


<p>如果该<code>Int</code>值没有足够的位数，即下标越界，那么上述实现的下标会返回0，因为它会在数字左边自动补0：</p>


<pre><code>746381295[9]
//returns 0, 即等同于：
0746381295[9]
</code></pre>


<p><a name="nested_types"></a></p>


<h2 id="-nested-types-">嵌套类型（Nested Types）</h2>


<p>扩展可以向已有的类、结构体和枚举添加新的嵌套类型：</p>


<pre><code>extension Character {
    enum Kind {
        case Vowel, Consonant, Other
    }
    var kind: Kind {
        switch String(self).lowercaseString {
        case "a", "e", "i", "o", "u":
            return .Vowel
        case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
             "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
            return .Consonant
        default:
            return .Other
        }
    }
}
</code></pre>


<p>该例子向<code>Character</code>添加了新的嵌套枚举。这个名为<code>Kind</code>的枚举表示特定字符的类型。具体来说，就是表示一个标准的拉丁脚本中的字符是元音还是辅音（不考虑口语和地方变种），或者是其它类型。</p>


<p>这个类子还向<code>Character</code>添加了一个新的计算实例属性，即<code>kind</code>，用来返回合适的<code>Kind</code>枚举成员。</p>


<p>现在，这个嵌套枚举可以和一个<code>Character</code>值联合使用了：</p>


<pre><code>func printLetterKinds(word: String) {
    println("'\\(word)' is made up of the following kinds of letters:")
    for character in word {
        switch character.kind {
        case .Vowel:
            print("vowel ")
        case .Consonant:
            print("consonant ")
        case .Other:
            print("other ")
        }
    }
    print("\n")
}
printLetterKinds("Hello")
// 'Hello' is made up of the following kinds of letters:
// consonant vowel consonant consonant vowel
</code></pre>


<p>函数<code>printLetterKinds</code>的输入是一个<code>String</code>值并对其字符进行迭代。在每次迭代过程中，考虑当前字符的<code>kind</code>计算属性，并打印出合适的类别描述。所以<code>printLetterKinds</code>就可以用来打印一个完整单词中所有字母的类型，正如上述单词<code>"hello"</code>所展示的。</p>


<blockquote>
<p>注意：</p>
<p>由于已知<code>character.kind</code>是<code>Character.Kind</code>型，所以<code>Character.Kind</code>中的所有成员值都可以使用<code>switch</code>语句里的形式简写，比如使用 <code>.Vowel</code>代替<code>Character.Kind.Vowel</code></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift属性]]></title>
    <link href="http://baxiang123.com//blog/Swift%E5%B1%9E%E6%80%A7.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift属性</id>
    <content type="html"><![CDATA[<p><strong>属性</strong>将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，计算属性计算（而不是存储）一个值。计算属性可以用于类、结构体和枚举里，存储属性只能用于类和结构体。</p>


<p>存储属性和计算属性通常用于特定类型的实例，但是，属性也可以直接用于类型本身，这种属性称为类型属性。</p>


<!-- more -->


<p>另外，还可以定义属性监视器来监控属性值的变化，以此来触发一个自定义的操作。属性监视器可以添加到自己写的存储属性上，也可以添加到从父类继承的属性上。</p>


<p><a name="stored_properties"></a></p>


<h2 id="-">存储属性</h2>


<p>简单来说，一个存储属性就是存储在特定类或结构体的实例里的一个常量或变量，存储属性可以是<em>变量存储属性</em>（用关键字<code>var</code>定义），也可以是<em>常量存储属性</em>（用关键字<code>let</code>定义）。</p>


<p>可以在定义存储属性的时候指定默认值，请参考<a href="../chapter2/14_Initialization.html">构造过程</a>一章的<a href="../chapter2/14_Initialization.html#default_property_values">默认属性值</a>一节。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值，请参考<a href="../chapter2/14_Initialization.html">构造过程</a>一章的<a href="../chapter2/14_Initialization.html#modifying_constant_properties_during_initialization">在初始化阶段修改常量存储属性</a>一节。</p>


<p>下面的例子定义了一个名为<code>FixedLengthRange</code>的结构体，他描述了一个在创建后无法修改值域宽度的区间：</p>


<pre><code>struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// 该区间表示整数0，1，2
rangeOfThreeItems.firstValue = 6
// 该区间现在表示整数6，7，8
</code></pre>


<p><code>FixedLengthRange</code>的实例包含一个名为<code>firstValue</code>的变量存储属性和一个名为<code>length</code>的常量存储属性。在上面的例子中，<code>length</code>在创建实例的时候被赋值，因为它是一个常量存储属性，所以之后无法修改它的值。</p>


<p><a name="stored_properties_of_constant_structure_instances"></a></p>


<h3 id="-">常量和存储属性</h3>


<p>如果创建了一个结构体的实例并赋值给一个常量，则无法修改实例的任何属性，即使定义了变量存储属性：</p>


<pre><code>let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// 该区间表示整数0，1，2，3
rangeOfFourItems.firstValue = 6
// 尽管firstValue诗歌变量属性，这里还是会报错
</code></pre>


<p>因为<code>rangeOfFourItems</code>声明成了常量（用<code>let</code>关键字），即使<code>firstValue</code>是一个变量属性，也无法再修改它了。</p>


<p>这种行为是由于结构体（struct）属于<em>值类型</em>。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>


<p>属于<em>引用类型</em>的类（class）则不一样，把一个引用类型的实例赋给一个常量后，仍然可以修改实例的变量属性。</p>


<p><a name="lazy_stored_properties"></a></p>


<h3 id="-">延迟存储属性</h3>


<p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>@lazy</code>来标示一个延迟存储属性。</p>


<blockquote>
<p>注意：</p>
<p>必须将延迟存储属性声明成变量（使用<code>var</code>关键字），因为属性的值在实例构造完成之前可能无法得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</p>
</blockquote>


<p>延迟属性很有用，当属性的值依赖于在实例的构造过程结束前无法知道具体值的外部因素时，或者当属性的值需要复杂或大量计算时，可以只在需要的时候来计算它。</p>


<p>下面的例子使用了延迟存储属性来避免复杂类的不必要的初始化。例子中定义了<code>DataImporter</code>和<code>DataManager</code>两个类，下面是部分代码：</p>


<pre><code>class DataImporter {
    /*
    DataImporter 是一个将外部文件中的数据导入的类。
    这个类的初始化会消耗不少时间。
    */
    var fileName = "data.txt"
    // 这是提供数据导入功能
}

class DataManager {
    @lazy var importer = DataImporter()
    var data = String[]()
    // 这是提供数据管理功能
}

let manager = DataManager()
manager.data += "Some data"
manager.data += "Some more data"
// DataImporter 实例的 importer 属性还没有被创建
</code></pre>


<p><code>DataManager</code>类包含一个名为<code>data</code>的存储属性，初始值是一个空的字符串（<code>String</code>）数组。虽然没有写出全部代码，<code>DataManager</code>类的目的是管理和提供对这个字符串数组的访问。</p>


<p><code>DataManager</code>的一个功能是从文件导入数据，该功能由<code>DataImporter</code>类提供，<code>DataImporter</code>需要消耗不少时间完成初始化：因为它的实例在初始化时可能要打开文件，还要读取文件内容到内存。</p>


<p><code>DataManager</code>也可能不从文件中导入数据。所以当<code>DataManager</code>的实例被创建时，没必要创建一个<code>DataImporter</code>的实例，更明智的是当用到<code>DataImporter</code>的时候才去创建它。</p>


<p>由于使用了<code>@lazy</code>，<code>importer</code>属性只有在第一次被访问的时候才被创建。比如访问它的属性<code>fileName</code>时：</p>


<pre><code>println(manager.importer.fileName)
// DataImporter 实例的 importer 属性现在被创建了
// 输出 "data.txt”
</code></pre>


<p><a name="stored_properties_and_instance_variables"></a></p>


<h3 id="-">存储属性和实例变量</h3>


<p>如果您有过 Objective-C 经验，应该知道有两种方式在类实例存储值和引用。对于属性来说，也可以使用实例变量作为属性值的后端存储。</p>


<p>Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的后端存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。
一个类型中属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>


<p><a name="computed_properties"></a></p>


<h2 id="-">计算属性</h2>


<p>除存储属性外，类、结构体和枚举可以定义<em>计算属性</em>，计算属性不直接存储值，而是提供一个 getter 来获取值，一个可选的 setter 来间接设置其他属性或变量的值。</p>


<pre><code>struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set(newCenter) {
        origin.x = newCenter.x - (size.width / 2)
        origin.y = newCenter.y - (size.height / 2)
    }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
println("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// 输出 "square.origin is now at (10.0, 10.0)”
</code></pre>


<p>这个例子定义了 3 个几何形状的结构体：</p>


<ul>
<li><code>Point</code>封装了一个<code>(x, y)</code>的坐标</li>
<li><code>Size</code>封装了一个<code>width</code>和<code>height</code></li>
<li><code>Rect</code>表示一个有原点和尺寸的矩形</li>
</ul>


<p><code>Rect</code>也提供了一个名为<code>center</code>的计算属性。一个矩形的中心点可以从原点和尺寸来算出，所以不需要将它以显式声明的<code>Point</code>来保存。<code>Rect</code>的计算属性<code>center</code>提供了自定义的 getter 和 setter 来获取和设置矩形的中心点，就像它有一个存储属性一样。</p>


<p>例子中接下来创建了一个名为<code>square</code>的<code>Rect</code>实例，初始值原点是<code>(0, 0)</code>，宽度高度都是<code>10</code>。如图所示蓝色正方形。</p>


<p><code>square</code>的<code>center</code>属性可以通过点运算符（<code>square.center</code>）来访问，这会调用 getter 来获取属性的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的<code>Point</code>来表示<code>square</code>的中心点。如代码所示，它正确返回了中心点<code>(5, 5)</code>。</p>


<p><code>center</code>属性之后被设置了一个新的值<code>(15, 15)</code>，表示向右上方移动正方形到如图所示橙色正方形的位置。设置属性<code>center</code>的值会调用 setter 来修改属性<code>origin</code>的<code>x</code>和<code>y</code>的值，从而实现移动正方形到新的位置。</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png" alt="Computed Properties sample" width="388" height="387"></p>


<p><a name="shorthand_setter_declaration"></a></p>


<h3 id="-setter-">便捷 setter 声明</h3>


<p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称<code>newValue</code>。下面是使用了便捷 setter 声明的<code>Rect</code>结构体代码：</p>


<pre><code>struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set {
        origin.x = newValue.x - (size.width / 2)
        origin.y = newValue.y - (size.height / 2)
    }
    }
}
</code></pre>


<p><a name="readonly_computed_properties"></a></p>


<h3 id="-">只读计算属性</h3>


<p>只有 getter 没有 setter 的计算属性就是<em>只读计算属性</em>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>


<blockquote>
<p>注意：</p>
<p>必须使用<code>var</code>关键字定义计算属性，包括只读计算属性，因为他们的值不是固定的。<code>let</code>关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>
</blockquote>


<p>只读计算属性的声明可以去掉<code>get</code>关键字和花括号：</p>


<pre><code>struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
    return width * height * depth
    }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
println("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// 输出 "the volume of fourByFiveByTwo is 40.0"
</code></pre>


<p>这个例子定义了一个名为<code>Cuboid</code>的结构体，表示三维空间的立方体，包含<code>width</code>、<code>height</code>和<code>depth</code>属性，还有一个名为<code>volume</code>的只读计算属性用来返回立方体的体积。设置<code>volume</code>的值毫无意义，因为通过<code>width</code>、<code>height</code>和<code>depth</code>就能算出<code>volume</code>。然而，<code>Cuboid</code>提供一个只读计算属性来让外部用户直接获取体积是很有用的。</p>


<p><a name="property_observers"></a></p>


<h2 id="-">属性监视器</h2>


<p><em>属性监视器</em>监控和响应属性值的变化，每次属性被设置值的时候都会调用属性监视器，甚至新的值和现在的值相同的时候也不例外。</p>


<p>可以为除了延迟存储属性之外的其他存储属性添加属性监视器，也可以通过重载属性的方式为继承的属性（包括存储属性和计算属性）添加属性监视器。属性重载请参考<a href="chapter/13_Inheritance.html">继承</a>一章的<a href="chapter/13_Inheritance.html#overriding">重载</a>。</p>


<blockquote>
<p>注意：</p>
<p>不需要为无法重载的计算属性添加属性监视器，因为可以通过 setter 直接监控和响应值的变化。</p>
</blockquote>


<p>可以为属性添加如下的一个或全部监视器：</p>


<ul>
<li><code>willSet</code>在设置新的值之前调用</li>
<li><code>didSet</code>在新的值被设置之后立即调用</li>
</ul>


<p><code>willSet</code>监视器会将新的属性值作为固定参数传入，在<code>willSet</code>的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称<code>newValue</code>表示。</p>


<p>类似地，<code>didSet</code>监视器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名<code>oldValue</code>。</p>


<blockquote>
<p>注意：</p>
<p><code>willSet</code>和<code>didSet</code>监视器在属性初始化过程中不会被调用，他们只会当属性的值在初始化之外的地方被设置时被调用。</p>
</blockquote>


<p>这里是一个<code>willSet</code>和<code>didSet</code>的实际例子，其中定义了一个名为<code>StepCounter</code>的类，用来统计当人步行时的总步数，可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>


<pre><code>class StepCounter {
    var totalSteps: Int = 0 {
    willSet(newTotalSteps) {
        println("About to set totalSteps to \(newTotalSteps)")
    }
    didSet {
        if totalSteps &gt; oldValue  {
            println("Added \(totalSteps - oldValue) steps")
        }
    }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
</code></pre>


<p><code>StepCounter</code>类定义了一个<code>Int</code>类型的属性<code>totalSteps</code>，它是一个存储属性，包含<code>willSet</code>和<code>didSet</code>监视器。</p>


<p>当<code>totalSteps</code>设置新值的时候，它的<code>willSet</code>和<code>didSet</code>监视器都会被调用，甚至当新的值和现在的值完全相同也会调用。</p>


<p>例子中的<code>willSet</code>监视器将表示新值的参数自定义为<code>newTotalSteps</code>，这个监视器只是简单的将新的值输出。</p>


<p><code>didSet</code>监视器在<code>totalSteps</code>的值改变后被调用，它把新的值和旧的值进行对比，如果总的步数增加了，就输出一个消息表示增加了多少步。<code>didSet</code>没有提供自定义名称，所以默认值<code>oldValue</code>表示旧值的参数名。</p>


<blockquote>
<p>注意：</p>
<p>如果在<code>didSet</code>监视器里为属性赋值，这个值会替换监视器之前设置的值。</p>
</blockquote>


<p><a name="global_and_local_variables"></a></p>


<h2 id="-">全局变量和局部变量</h2>


<p>计算属性和属性监视器所描述的模式也可以用于<em>全局变量</em>和<em>局部变量</em>，全局变量是在函数、方法、闭包或任何类型之外定义的变量，局部变量是在函数、方法或闭包内部定义的变量。</p>


<p>前面章节提到的全局或局部变量都属于存储型变量，跟存储属性类似，它提供特定类型的存储空间，并允许读取和写入。</p>


<p>另外，在全局或局部范围都可以定义计算型变量和为存储型变量定义监视器，计算型变量跟计算属性一样，返回一个计算的值而不是存储值，声明格式也完全一样。</p>


<blockquote>
<p>注意：</p>
<p>全局的常量或变量都是延迟计算的，跟<a href="#lazy_stored_properties">延迟存储属性</a>相似，不同的地方在于，全局的常量或变量不需要标记<code>@lazy</code>特性。</p>
<p>局部范围的常量或变量不会延迟计算。</p>
</blockquote>


<p><a name="type_properties"></a></p>


<h2 id="-">类型属性</h2>


<p>实例的属性属于一个特定类型实例，每次类型实例化后都拥有自己的一套属性值，实例之间的属性相互独立。</p>


<p>也可以为类型本身定义属性，不管类型有多少个实例，这些属性都只有唯一一份。这种属性就是<em>类型属性</em>。</p>


<p>类型属性用于定义特定类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>


<p>对于值类型（指结构体和枚举）可以定义存储型和计算型类型属性，对于类（class）则只能定义计算型类型属性。</p>


<p>值类型的存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算属性一样定义成变量属性。</p>


<blockquote>
<p>注意：</p>
<p>跟实例的存储属性不同，必须给存储型类型属性指定默认值，因为类型本身无法在初始化过程中使用构造器给类型属性赋值。</p>
</blockquote>


<p><a name="type_property_syntax"></a></p>


<h3 id="-">类型属性语法</h3>


<p>在 C 或 Objective-C 中，静态常量和静态变量的定义是通过特定类型加上<code>global</code>关键字。在 Swift 编程语言中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</p>


<p>使用关键字<code>static</code>来定义值类型的类型属性，关键字<code>class</code>来为类（class）定义类型属性。下面的例子演示了存储型和计算型类型属性的语法：</p>


<pre><code>struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
    // 这里返回一个 Int 值
    }
}
enum SomeEnumeration {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
    // 这里返回一个 Int 值
    }
}
class SomeClass {
    class var computedTypeProperty: Int {
    // 这里返回一个 Int 值
    }
}
</code></pre>


<blockquote>
<p>注意：</p>
<p>例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟实例计算属性的语法类似。</p>
</blockquote>


<p><a name="querying_and_setting_type_properties"></a></p>


<h3 id="-">获取和设置类型属性的值</h3>


<p>跟实例的属性一样，类型属性的访问也是通过点运算符来进行，但是，类型属性是通过类型本身来获取和设置，而不是通过实例。比如：</p>


<pre><code>println(SomeClass.computedTypeProperty)
// 输出 "42"

println(SomeStructure.storedTypeProperty)
// 输出 "Some value."
SomeStructure.storedTypeProperty = "Another value."
println(SomeStructure.storedTypeProperty)
// 输出 "Another value.”
</code></pre>


<p>下面的例子定义了一个结构体，使用两个存储型类型属性来表示多个声道的声音电平值，每个声道有一个 0 到 10 之间的整数表示声音电平值。</p>


<p>后面的图表展示了如何联合使用两个声道来表示一个立体声的声音电平值。当声道的电平值是 0，没有一个灯会亮；当声道的电平值是 10，所有灯点亮。本图中，左声道的电平是 9，右声道的电平是 7。</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png" alt="Static Properties VUMeter" width="243" height="357"></p>


<p>上面所描述的声道模型使用<code>AudioChannel</code>结构体来表示：</p>


<pre><code>struct AudioChannel {
    static let thresholdLevel = 10
    static var maxInputLevelForAllChannels = 0
    var currentLevel: Int = 0 {
    didSet {
        if currentLevel &gt; AudioChannel.thresholdLevel {
            // 将新电平值设置为阀值
            currentLevel = AudioChannel.thresholdLevel
        }
        if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {
            // 存储当前电平值作为新的最大输入电平
            AudioChannel.maxInputLevelForAllChannels = currentLevel
        }
    }
    }
}
</code></pre>


<p>结构<code>AudioChannel</code>定义了 2 个存储型类型属性来实现上述功能。第一个是<code>thresholdLevel</code>，表示声音电平的最大上限阈值，它是一个取值为 10 的常量，对所有实例都可见，如果声音电平高于 10，则取最大上限值 10（见后面描述）。</p>


<p>第二个类型属性是变量存储型属性<code>maxInputLevelForAllChannels</code>，它用来表示所有<code>AudioChannel</code>实例的电平值的最大值，初始值是 0。</p>


<p><code>AudioChannel</code>也定义了一个名为<code>currentLevel</code>的实例存储属性，表示当前声道现在的电平值，取值为 0 到 10。</p>


<p>属性<code>currentLevel</code>包含<code>didSet</code>属性监视器来检查每次新设置后的属性值，有如下两个检查：</p>


<ul>
<li>如果<code>currentLevel</code>的新值大于允许的阈值<code>thresholdLevel</code>，属性监视器将<code>currentLevel</code>的值限定为阈值<code>thresholdLevel</code>。</li>
<li>如果修正后的<code>currentLevel</code>值大于任何之前任意<code>AudioChannel</code>实例中的值，属性监视器将新值保存在静态属性<code>maxInputLevelForAllChannels</code>中。</li>
</ul>


<blockquote>
<p>注意：</p>
<p>在第一个检查过程中，<code>didSet</code>属性监视器将<code>currentLevel</code>设置成了不同的值，但这时不会再次调用属性监视器。</p>
</blockquote>


<p>可以使用结构体<code>AudioChannel</code>来创建表示立体声系统的两个声道<code>leftChannel</code>和<code>rightChannel</code>：</p>


<pre><code>var leftChannel = AudioChannel()
var rightChannel = AudioChannel()
</code></pre>


<p>如果将左声道的电平设置成 7，类型属性<code>maxInputLevelForAllChannels</code>也会更新成 7：</p>


<pre><code>leftChannel.currentLevel = 7
println(leftChannel.currentLevel)
// 输出 "7"
println(AudioChannel.maxInputLevelForAllChannels)
// 输出 "7"
</code></pre>


<p>如果试图将右声道的电平设置成 11，则会将右声道的<code>currentLevel</code>修正到最大值 10，同时<code>maxInputLevelForAllChannels</code>的值也会更新到 10：</p>


<pre><code>rightChannel.currentLevel = 11
println(rightChannel.currentLevel)
// 输出 "10"
println(AudioChannel.maxInputLevelForAllChannels)
// 输出 "10"
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift字符串和字符]]></title>
    <link href="http://baxiang123.com//blog/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift字符串和字符</id>
    <content type="html"><![CDATA[<p><code>String</code>是例如“hello, world“”，“海贼王” 这样的有序的<code>Character</code>（字符）类型的值的集合，通过<code>String</code>类型来表示。</p>


<p>Swift 的<code>String</code>和<code>Character</code>类型提供了一个快速的，兼容 Unicode 的方式来处理代码中的文本信息。
创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。
字符串连接操作只需要简单地通过<code>+</code>号将两个字符串相连即可。
与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。</p>


<p>尽管语法简易，但<code>String</code>类型是一种快速、现代化的字符串实现。
每一个字符串都是由独立编码的 Unicode 字符组成，并提供了以不同 Unicode 表示（representations）来访问这些字符的支持。</p>


<!-- more -->


<p>Swift 可以在常量、变量、字面量和表达式中进行字符串插值操作，可以轻松创建用于展示、存储和打印的自定义字符串。</p>


<blockquote>
<p>注意：</p>
<p>Swift 的<code>String</code>类型与 Foundation <code>NSString</code>类进行了无缝桥接。如果您利用 Cocoa 或 Cocoa Touch 中的 Foundation 框架进行工作。所有<code>NSString</code> API 都可以调用您创建的任意<code>String</code>类型的值。除此之外，还可以使用本章介绍的<code>String</code>特性。您也可以在任意要求传入<code>NSString</code>实例作为参数的 API 中使用<code>String</code>类型的值作为替代。</p>
<p>更多关于在 Foundation 和 Cocoa 中使用<code>String</code>的信息请查看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank">Using Swift with Cocoa and Objective-C</a>。</p>
</blockquote>


<p><a name="string_literals"></a></p>


<h2 id="-string-literals-">字符串字面量（String Literals）</h2>


<p>您可以在您的代码中包含一段预定义的字符串值作为字符串字面量。
字符串字面量是由双引号 (&#8220;&#8221;) 包裹着的具有固定顺序的文本字符集。</p>


<p>字符串字面量可以用于为常量和变量提供初始值。</p>


<pre><code>let someString = "Some string literal value"
</code></pre>


<blockquote>
<p>注意：</p>
<p><code>someString</code>变量通过字符串字面量进行初始化，Swift 因此推断该变量为<code>String</code>类型。</p>
</blockquote>


<p>字符串字面量可以包含以下特殊字符：</p>


<ul>
<li>转义字符<code>\0</code>(空字符)、<code>\\</code>(反斜线)、<code>\t</code>(水平制表符)、<code>\n</code>(换行符)、<code>\r</code>(回车符)、<code>\"</code>(双引号)、<code>\'</code>(单引号)。</li>
<li>单字节 Unicode 标量，写成<code>\xnn</code>，其中<code>nn</code>为两位十六进制数。</li>
<li>双字节 Unicode 标量，写成<code>\unnnn</code>，其中<code>nnnn</code>为四位十六进制数。</li>
<li>四字节 Unicode 标量，写成<code>\Unnnnnnnn</code>，其中<code>nnnnnnnn</code>为八位十六进制数。</li>
</ul>


<p>下面的代码为各种特殊字符的使用示例。
<code>wiseWords</code>常量包含了两个转移特殊字符 (双括号)；
<code>dollarSign</code>、<code>blackHeart</code>和<code>sparklingHeart</code>常量演示了三种不同格式的 Unicode 标量：</p>


<pre><code>let wiseWords = "\"我是要成为海贼王的男人\" - 路飞"
// "我是要成为海贼王的男人" - 路飞
let dollarSign = "\x24"                // $,  Unicode 标量 U+0024
let blackHeart = "\u2665"              // ♥,  Unicode 标量 U+2665
let sparklingHeart = "\U0001F496"    // 💖, Unicode 标量 U+1F496
</code></pre>


<p><a name="initializing_an_empty_string"></a></p>


<h2 id="-initializing-an-empty-string-">初始化空字符串 (Initializing an Empty String)</h2>


<p>为了构造一个很长的字符串，可以创建一个空字符串作为初始值。
可以将空的字符串字面量赋值给变量，也可以初始化一个新的<code>String</code>实例：</p>


<pre><code>var emptyString = ""               // 空字符串字面量
var anotherEmptyString = String()  // 初始化 String 实例
// 两个字符串均为空并等价。
</code></pre>


<p>您可以通过检查其<code>Boolean</code>类型的<code>isEmpty</code>属性来判断该字符串是否为空：</p>


<pre><code>if emptyString.isEmpty {
    println("什么都没有")
}
// 打印输出："什么都没有"
</code></pre>


<p><a name="string_mutability"></a></p>


<h2 id="-string-mutability-">字符串可变性 (String Mutability)</h2>


<p>您可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：</p>


<pre><code>var variableString = "Horse"
variableString += " and carriage"
// variableString 现在为 "Horse and carriage"
let constantString = "Highlander"
constantString += " and another Highlander"
// 这会报告一个编译错误 (compile-time error) - 常量不可以被修改。
</code></pre>


<blockquote>
<p>注意：</p>
<p>在 Objective-C 和 Cocoa 中，您通过选择两个不同的类(<code>NSString</code>和<code>NSMutableString</code>)来指定该字符串是否可以被修改，Swift 中的字符串是否可以修改仅通过定义的是变量还是常量来决定，实现了多种类型可变性操作的统一。</p>
</blockquote>


<p><a name="strings_are_value_types"></a></p>


<h2 id="-strings-are-value-types-">字符串是值类型（Strings Are Value Types）</h2>


<p>Swift 的<code>String</code>类型是值类型。
如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作或在函数/方法中传递时，会进行值拷贝。
任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。
值类型在 <a href="09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a> 中进行了说明。</p>


<blockquote>
<p>注意：</p>
<p>与 Cocoa 中的<code>NSString</code>不同，当您在 Cocoa 中创建了一个<code>NSString</code>实例，并将其传递给一个函数/方法，或者赋值给一个变量，您传递或赋值的是该<code>NSString</code>实例的一个引用，除非您特别要求进行值拷贝，否则字符串不会生成新的副本来进行赋值操作。</p>
</blockquote>


<p>Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。
很明显无论该值来自于哪里，都是您独自拥有的。
您可以放心您传递的字符串本身不会被更改。</p>


<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>


<p><a name="working_with_characters"></a></p>


<h2 id="-working-with-characters-">使用字符（Working with Characters）</h2>


<p>Swift 的<code>String</code>类型表示特定序列的<code>Character</code>（字符） 类型值的集合。
每一个字符值代表一个 Unicode 字符。
您可利用<code>for-in</code>循环来遍历字符串中的每一个字符：</p>


<pre><code>for character in "Dog!🐶" {
    println(character)
}
// D
// o
// g
// !
// 🐶
</code></pre>


<p>for-in 循环在 <a href="05_Control_Flow.html#for_loops">For Loops</a> 中进行了详细描述。</p>


<p>另外，通过标明一个<code>Character</code>类型注解并通过字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p>


<pre><code>let yenSign: Character = "¥"
</code></pre>


<p><a name="counting_characters"></a></p>


<h2 id="-counting-characters-">计算字符数量 (Counting Characters)</h2>


<p>通过调用全局<code>countElements</code>函数，并将字符串作为参数进行传递，可以获取该字符串的字符数量。</p>


<pre><code>let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
println("unusualMenagerie has \(countElements(unusualMenagerie)) characters")
// 打印输出："unusualMenagerie has 40 characters"
</code></pre>


<blockquote>
<p>注意：</p>
<p>不同的 Unicode 字符以及相同 Unicode 字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间。因此字符串的长度不得不通过迭代字符串中每一个字符的长度来进行计算。如果您正在处理一个长字符串，需要注意<code>countElements</code>函数必须遍历字符串中的字符以精准计算字符串的长度。</p>
<p>另外需要注意的是通过<code>countElements</code>返回的字符数量并不总是与包含相同字符的<code>NSString</code>的<code>length</code>属性相同。<code>NSString</code>的<code>length</code>属性是基于利用 UTF-16 表示的十六位代码单元数字，而不是基于 Unicode 字符。为了解决这个问题，<code>NSString</code>的<code>length</code>属性在被 Swift 的<code>String</code>访问时会成为<code>utf16count</code>。</p>
</blockquote>


<p><a name="concatenating_strings_and_characters"></a></p>


<h2 id="-concatenating-strings-and-characters-">连接字符串和字符 (Concatenating Strings and Characters)</h2>


<p>字符串和字符的值可以通过加法运算符（<code>+</code>）相加在一起并创建一个新的字符串值：</p>


<pre><code>let string1 = "hello"
let string2 = " there"
let character1: Character = "!"
let character2: Character = "?"

let stringPlusCharacter = string1 + character1        // 等于 "hello!"
let stringPlusString = string1 + string2              // 等于 "hello there"
let characterPlusString = character1 + string1        // 等于 "!hello"
let characterPlusCharacter = character1 + character2  // 等于 "!?"
</code></pre>


<p>您也可以通过加法赋值运算符 (<code>+=</code>) 将一个字符串或者字符添加到一个已经存在字符串变量上：</p>


<pre><code>var instruction = "look over"
instruction += string2
// instruction 现在等于 "look over there"

var welcome = "good morning"
welcome += character1
// welcome 现在等于 "good morning!"
</code></pre>


<blockquote>
<p>注意：</p>
<p>您不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</p>
</blockquote>


<p><a name="string_interpolation"></a></p>


<h2 id="-string-interpolation-">字符串插值 (String Interpolation)</h2>


<p>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。
您插入的字符串字面量的每一项都被包裹在以反斜线为前缀的圆括号中：</p>


<pre><code>let multiplier = 3
let message = "\(multiplier) 乘以 2.5 是 \(Double(multiplier) * 2.5)"
// message 是 "3 乘以 2.5 是 7.5"
</code></pre>


<p>在上面的例子中，<code>multiplier</code>作为<code>\(multiplier)</code>被插入到一个字符串字面量中。
当创建字符串执行插值计算时此占位符会被替换为<code>multiplier</code>实际的值。</p>


<p><code>multiplier</code>的值也作为字符串中后面表达式的一部分。
该表达式计算<code>Double(multiplier) * 2.5</code>的值并将结果 (7.5) 插入到字符串中。
在这个例子中，表达式写为<code>\(Double(multiplier) * 2.5)</code>并包含在字符串字面量中。</p>


<blockquote>
<p>注意：</p>
<p>您插值字符串中写在括号中的表达式不能包含非转义双引号 (<code>"</code>) 和反斜杠 (<code>\</code>)，并且不能包含回车或换行符。</p>
</blockquote>


<p><a name="comparing_strings"></a></p>


<h2 id="-comparing-strings-">比较字符串 (Comparing Strings)</h2>


<p>Swift 提供了三种方式来比较字符串的值：字符串相等、前缀相等和后缀相等。</p>


<p><a name="string_equality"></a></p>


<h3 id="-string-equality-">字符串相等 (String Equality)</h3>


<p>如果两个字符串以同一顺序包含完全相同的字符，则认为两者字符串相等：</p>


<pre><code>let quotation = "我们是一样一样滴."
let sameQuotation = "我们是一样一样滴."
if quotation == sameQuotation {
    println("这两个字符串被认为是相同的")
}
// 打印输出："这两个字符串被认为是相同的"
</code></pre>


<p><a name="prefix_and_suffix_equality"></a></p>


<h3 id="-prefix-and-suffix-equality-">前缀/后缀相等 (Prefix and Suffix Equality)</h3>


<p>通过调用字符串的<code>hasPrefix</code>/<code>hasSuffix</code>方法来检查字符串是否拥有特定前缀/后缀。
两个方法均需要以字符串作为参数传入并传出<code>Boolean</code>值。
两个方法均执行基本字符串和前缀/后缀字符串之间逐个字符的比较操作。</p>


<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：</p>


<pre><code>let romeoAndJuliet = [
    "Act 1 Scene 1: Verona, A public place",
    "Act 1 Scene 2: Capulet's mansion",
    "Act 1 Scene 3: A room in Capulet's mansion",
    "Act 1 Scene 4: A street outside Capulet's mansion",
    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
    "Act 2 Scene 1: Outside Capulet's mansion",
    "Act 2 Scene 2: Capulet's orchard",
    "Act 2 Scene 3: Outside Friar Lawrence's cell",
    "Act 2 Scene 4: A street in Verona",
    "Act 2 Scene 5: Capulet's mansion",
    "Act 2 Scene 6: Friar Lawrence's cell"
]
</code></pre>


<p>您可以利用<code>hasPrefix</code>方法来计算话剧中第一幕的场景数：</p>


<pre><code>var act1SceneCount = 0
for scene in romeoAndJuliet {
    if scene.hasPrefix("Act 1 ") {
        ++act1SceneCount
    }
}
println("There are \(act1SceneCount) scenes in Act 1")
// 打印输出："There are 5 scenes in Act 1"
</code></pre>


<p>相似地，您可以用<code>hasSuffix</code>方法来计算发生在不同地方的场景数：</p>


<pre><code>“var mansionCount = 0
var cellCount = 0
for scene in romeoAndJuliet {
    if scene.hasSuffix("Capulet's mansion") {
        ++mansionCount
    } else if scene.hasSuffix("Friar Lawrence's cell") {
        ++cellCount
    }
}
println("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
// 打印输出："6 mansion scenes; 2 cell scenes”
</code></pre>


<p><a name="uppercase_and_lowercase_strings"></a></p>


<h3 id="-uppercase-and-lowercase-strings-">大写和小写字符串（Uppercase and Lowercase Strings）</h3>


<p>您可以通过字符串的<code>uppercaseString</code>和<code>lowercaseString</code>属性来访问大写/小写版本的字符串。</p>


<pre><code>let normal = "Could you help me, please?"
let shouty = normal.uppercaseString
// shouty 值为 "COULD YOU HELP ME, PLEASE?"
let whispered = normal.lowercaseString
// whispered 值为 "could you help me, please?"
</code></pre>


<p><a name="unicode"></a></p>


<h2 id="unicode">Unicode</h2>


<p>Unicode 是一个国际标准，用于文本的编码和表示。
它使您可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。</p>


<p>Swift 的字符串和字符类型是完全兼容 Unicode 标准的，它支持如下所述的一系列不同的 Unicode 编码。</p>


<p><a name="unicode_terminology"></a></p>


<h3 id="unicode-unicode-terminology-">Unicode 术语（Unicode Terminology）</h3>


<p>Unicode 中每一个字符都可以被解释为一个或多个 unicode 标量。
字符的 unicode 标量是一个唯一的21位数字(和名称)，例如<code>U+0061</code>表示小写的拉丁字母A (&#8220;a&#8221;)，<code>U+1F425</code>表示小鸡表情 (&#8220;🐥&#8221;)</p>


<p>当 Unicode 字符串被写进文本文件或其他存储结构当中，这些 unicode 标量将会按照 Unicode 定义的集中格式之一进行编码。其包括<code>UTF-8</code>（以8位代码单元进行编码） 和<code>UTF-16</code>（以16位代码单元进行编码）。</p>


<p><a name="unicode_representations_of_strings"></a></p>


<h3 id="-unicode-unicode-representations-of-strings-">字符串的 Unicode 表示（Unicode Representations of Strings）</h3>


<p>Swift 提供了几种不同的方式来访问字符串的 Unicode 表示。</p>


<p>您可以利用<code>for-in</code>来对字符串进行遍历，从而以 Unicode 字符的方式访问每一个字符值。
该过程在 <a href="#working_with_characters">使用字符</a> 中进行了描述。</p>


<p>另外，能够以其他三种 Unicode 兼容的方式访问字符串的值：</p>


<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的 Unicode 标量值集合 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>


<p>下面由<code>D``o``g``!</code>和<code>🐶</code>(<code>DOG FACE</code>，Unicode 标量为<code>U+1F436</code>)组成的字符串中的每一个字符代表着一种不同的表示：</p>


<pre><code>let dogString = "Dog!🐶"
</code></pre>


<p><a name="UTF-8"></a></p>


<h3 id="utf-8">UTF-8</h3>


<p>您可以通过遍历字符串的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示。
其为<code>UTF8View</code>类型的属性，<code>UTF8View</code>是无符号8位 (<code>UInt8</code>) 值的集合，每一个<code>UInt8</code>值都是一个字符的 UTF-8 表示：</p>


<pre><code>for codeUnit in dogString.utf8 {
    print("\(codeUnit) ")
}
print("\n")
// 68 111 103 33 240 159 144 182
</code></pre>


<p>上面的例子中，前四个10进制代码单元值 (68, 111, 103, 33) 代表了字符<code>D</code> <code>o</code> <code>g</code>和<code>!</code>，他们的 UTF-8 表示与 ASCII 表示相同。
后四个代码单元值 (240, 159, 144, 182) 是<code>DOG FACE</code>的4字节 UTF-8 表示。</p>


<p><a name="UTF-16"></a></p>


<h3 id="utf-16">UTF-16</h3>


<p>您可以通过遍历字符串的<code>utf16</code>属性来访问它的<code>UTF-16</code>表示。
其为<code>UTF16View</code>类型的属性，<code>UTF16View</code>是无符号16位 (<code>UInt16</code>) 值的集合，每一个<code>UInt16</code>都是一个字符的 UTF-16 表示：</p>


<pre><code>for codeUnit in dogString.utf16 {
    print("\(codeUnit) ")
}
print("\n")
// 68 111 103 33 55357 56374
</code></pre>


<p>同样，前四个代码单元值 (68, 111, 103, 33) 代表了字符<code>D</code> <code>o</code> <code>g</code>和<code>!</code>，他们的 UTF-16 代码单元和 UTF-8 完全相同。</p>


<p>第五和第六个代码单元值 (55357 和 56374) 是<code>DOG FACE</code>字符的UTF-16 表示。
第一个值为<code>U+D83D</code>(十进制值为 55357)，第二个值为<code>U+DC36</code>(十进制值为 56374)。</p>


<p><a name="unicode_scalars"></a></p>


<h3 id="unicode-unicode-scalars-">Unicode 标量 (Unicode Scalars)</h3>


<p>您可以通过遍历字符串的<code>unicodeScalars</code>属性来访问它的 Unicode 标量表示。
其为<code>UnicodeScalarView</code>类型的属性， <code>UnicodeScalarView</code>是<code>UnicodeScalar</code>的集合。
<code>UnicodeScalar</code>是21位的 Unicode 代码点。</p>


<p>每一个<code>UnicodeScalar</code>拥有一个值属性，可以返回对应的21位数值，用<code>UInt32</code>来表示。</p>


<pre><code>for scalar in dogString.unicodeScalars {
    print("\(scalar.value) ")
}
print("\n")
// 68 111 103 33 128054
</code></pre>


<p>同样，前四个代码单元值 (68, 111, 103, 33) 代表了字符<code>D</code> <code>o</code> <code>g</code>和<code>!</code>。
第五位数值，128054，是一个十六进制1F436的十进制表示。
其等同于<code>DOG FACE</code>的Unicode 标量 U+1F436。</p>


<p>作为查询字符值属性的一种替代方法，每个<code>UnicodeScalar</code>值也可以用来构建一个新的字符串值，比如在字符串插值中使用：</p>


<pre><code>for scalar in dogString.unicodeScalars {
    println("\(scalar) ")
}
// D
// o
// g
// !
// 🐶
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift基本运算符]]></title>
    <link href="http://baxiang123.com//blog/Swift%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift基本运算符</id>
    <content type="html"><![CDATA[<p>运算符是检查，改变，合并值的特殊符号或短语。例如，加号<code>+</code>将两个数相加（如<code>let i = 1 + 2</code>）。复杂些的运行算例如逻辑与运算符<code>&amp;&amp;</code>（如<code>if enteredDoorCode &amp;&amp; passedRetinaScan</code>），又或让 i 值加1的便捷运算符自增运算符<code>++i</code>等。</p>


<!-- more -->


<p>Swift 支持大部分标准 C 语言的运算符，且改进许多特性来减少常规编码错误。如，赋值符（<code>=</code>）不返回值，以防止把想要判断相等运算符（<code>==</code>）的地方写成赋值符导致的错误。数值运算符（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>等）会检测并不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。当然允许你使用 Swift 的溢出运算符来实现溢出。详情参见<a href="23_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>


<p>区别于 C 语言，在 Swift 中你可以对浮点数进行取余运算（<code>%</code>），Swift 还提供了 C 语言没有的表达两数之间的值的区间运算符，（<code>a..b</code>和<code>a...b</code>），这方便我们表达一个区间内的数值。</p>


<p>本章节只描述了 Swift 中的基本运算符，<a href="23_Advanced_Operators.html">高级运算符</a>包含了高级运算符，及如何自定义运算符，及如何进行自定义类型的运算符重载。</p>


<p><a name="terminology"></a></p>


<h2 id="-">术语</h2>


<p>运算符有一元，二元和三元运算符。</p>


<ul>
<li>一元运算符对单一操作对象操作（如<code>-a</code>）。一元运算符分前置符和后置运算符，前置运算符需紧排操作对象之前（如<code>!b</code>），后置运算符需紧跟操作对象之后（如<code>i++</code>）。</li>
<li>二元运算符操作两个操作对象（如<code>2 + 3</code>），是中置的，因为它们出现在两个操作对象之间。</li>
<li>三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三元条件运算符（<code>a ? b : c</code>）。</li>
</ul>


<p>受运算符影响的值叫操作数，在表达式<code>1 + 2</code>中，加号<code>+</code>是二元运算符，它的两个操作数是值<code>1</code>和<code>2</code>。</p>


<p><a name="assignment_operator"></a></p>


<h2 id="-">赋值运算符</h2>


<p>赋值运算（<code>a = b</code>），表示用<code>b</code>的值来初始化或更新<code>a</code>的值：</p>


<pre><code class="lang-swift">let b = 10
var a = 5
a = b
// a 现在等于 10
</code></pre>


<p>如果赋值的右边是一个多元组，它的元素可以马上被分解多个变量或变量：</p>


<pre><code>let (x, y) = (1, 2)
// 现在 x 等于 1, y 等于 2
</code></pre>


<p>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的：</p>


<pre><code class="lang-swift">if x = y {
    // 此句错误, 因为 x = y 并不返回任何值
}
</code></pre>


<p>这个特性使得你无法把（<code>==</code>）错写成（<code>=</code>）了，由于<code>if x = y</code>是错误代码，Swift 从底层帮你避免了这些代码错误。</p>


<p><a name="arithmetic_operators"></a></p>


<h2 id="-">数值运算</h2>


<p>Swift 让所有数值类型都支持了基本的四则运算：</p>


<ul>
<li>加法（<code>+</code>）</li>
<li>减法（<code>-</code>）</li>
<li>乘法（<code>*</code>）</li>
<li>除法（<code>/</code>）</li>
</ul>


<pre><code class="lang-swift">1 + 2       // 等于 3
5 - 3       // 等于 2
2 * 3       // 等于 6
10.0 / 2.5  // 等于 4.0
</code></pre>


<p>与 C 语言和 Objective-C 不同的是，Swift 默认不允许在数值运算中出现溢出情况。但你可以使用 Swift 的溢出运算符来达到你有目的的溢出（如<code>a &amp;+ b</code>）。详情参见<a href="23_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>


<p>加法运算符也用于<code>String</code>的拼接：</p>


<pre><code class="lang-swift">"hello, " + "world"  // 等于 "hello, world"
</code></pre>


<p>两个<code>Character</code>值或一个<code>String</code>和一个<code>Character</code>值，相加会生成一个新的<code>String</code>值：</p>


<pre><code class="lang-swift">let dog: Character = "d"
let cow: Character = "c"
let dogCow = dog + cow
// 译者注: 原来的引号内是很可爱的小狗和小牛, 但win os下不支持表情字符, 所以改成了普通字符
// dogCow 现在是 "dc"
</code></pre>


<p>详情参见<a href="03_Strings_and_Characters.html#concatenating_strings_and_characters">字符，字符串的拼接</a>。</p>


<h3 id="-">求余运算</h3>


<p>求余运算（<code>a % b</code>）是计算<code>b</code>的多少倍刚刚好可以容入<code>a</code>，返回多出来的那部分（余数）。</p>


<blockquote>
<p>注意：</p>
<p>求余运算（<code>%</code>）在其他语言也叫取模运算。然而严格说来，我们看该运算符对负数的操作结果，&#8221;求余&#8221;比&#8221;取模&#8221;更合适些。</p>
</blockquote>


<p>我们来谈谈取余是怎么回事，计算<code>9 % 4</code>，你先计算出<code>4</code>的多少倍会刚好可以容入<code>9</code>中：</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png" alt="Art/remainderInteger_2x.png" title="Art/remainderInteger_2x.png"></p>


<p>2倍，非常好，那余数是1（用橙色标出）</p>


<p>在 Swift 中这么来表达：</p>


<pre><code class="lang-swift">9 % 4    // 等于 1
</code></pre>


<p>为了得到<code>a % b</code>的结果，<code>%</code>计算了以下等式，并输出<code>余数</code>作为结果：</p>


<p><em>a = (b × 倍数) + 余数</em></p>


<p>当<code>倍数</code>取最大值的时候，就会刚好可以容入<code>a</code>中。</p>


<p>把<code>9</code>和<code>4</code>代入等式中，我们得<code>1</code>：</p>


<pre><code class="lang-swift">9 = (4 × 2) + 1
</code></pre>


<p>同样的方法，我来们计算 <code>-9 % 4</code>：</p>


<pre><code class="lang-swift">-9 % 4   // 等于 -1
</code></pre>


<p>把<code>-9</code>和<code>4</code>代入等式，<code>-2</code>是取到的最大整数：</p>


<pre><code class="lang-swift">-9 = (4 × -2) + -1
</code></pre>


<p>余数是<code>-1</code>。</p>


<p>在对负数<code>b</code>求余时，<code>b</code>的符号会被忽略。这意味着 <code>a % b</code> 和 <code>a % -b</code>的结果是相同的。</p>


<h3 id="-">浮点数求余计算</h3>


<p>不同于 C 语言和 Objective-C，Swift 中是可以对浮点数进行求余的。</p>


<pre><code class="lang-swift">8 % 2.5 // 等于 0.5
</code></pre>


<p>这个例子中，<code>8</code>除于<code>2.5</code>等于<code>3</code>余<code>0.5</code>，所以结果是一个<code>Double</code>值<code>0.5</code>。</p>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderFloat_2x.png" alt="Art/remainderFloat_2x.png" title="Art/remainderFloat_2x.png"></p>


<h3 id="-">自增和自增运算</h3>


<p>和 C 语言一样，Swift 也提供了方便对变量本身加1或减1的自增（<code>++</code>）和自减（<code>--</code>）的运算符。其操作对象可以是整形和浮点型。
&zwnj;</p>


<pre><code class="lang-swift">var i = 0
++i      // 现在 i = 1
</code></pre>


<p>每调用一次<code>++i</code>，<code>i</code>的值就会加1。实际上，<code>++i</code>是<code>i = i + 1</code>的简写，而<code>--i</code>是<code>i = i - 1</code>的简写。</p>


<p><code>++</code>和<code>--</code>既是前置又是后置运算。<code>++i</code>，<code>i++</code>，<code>--i</code>和<code>i--</code>都是有效的写法。</p>


<p>我们需要注意的是这些运算符修改了<code>i</code>后有一个返回值。如果你只想修改<code>i</code>的值，那你就可以忽略这个返回值。但如果你想使用返回值，你就需要留意前置和后置操作的返回值是不同的。</p>


<ul>
<li><p>当<code>++</code>前置的时候，先自増再返回。</p>
</li>
<li><p>当<code>++</code>后置的时候，先返回再自增。</p>
</li>
</ul>


<p>例如：</p>


<pre><code class="lang-swift">var a = 0
let b = ++a // a 和 b 现在都是 1
let c = a++ // a 现在 2, 但 c 是 a 自增前的值 1
</code></pre>


<p>上述例子，<code>let b = ++a</code>先把<code>a</code>加1了再返回<code>a</code>的值。所以<code>a</code>和<code>b</code>都是新值<code>1</code>。</p>


<p>而<code>let c = a++</code>，是先返回了<code>a</code>的值，然后<code>a</code>才加1。所以<code>c</code>得到了<code>a</code>的旧值1，而<code>a</code>加1后变成2。</p>


<p>除非你需要使用<code>i++</code>的特性，不然推荐你使用<code>++i</code>和<code>--i</code>，因为先修改后返回这样的行为更符合我们的逻辑。</p>


<h3 id="-">一元负号</h3>


<p>数值的正负号可以使用前缀<code>-</code>（即一元负号）来切换：</p>


<pre><code class="lang-swift">let three = 3
let minusThree = -three       // minusThree 等于 -3
let plusThree = -minusThree   // plusThree 等于 3, 或 "负负3"
</code></pre>


<p>一元负号（<code>-</code>）写在操作数之前，中间没有空格。</p>


<h3 id="-">一元正号</h3>


<p>一元正号（<code>+</code>）不做任何改变地返回操作数的值。</p>


<pre><code class="lang-swift">let minusSix = -6
let alsoMinusSix = +minusSix  // alsoMinusSix 等于 -6
</code></pre>


<p>虽然一元<code>+</code>做无用功，但当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。</p>


<p><a name="compound_assignment_operators"></a></p>


<h2 id="-compound-assignment-operators-">复合赋值（Compound Assignment Operators）</h2>


<p>如同强大的 C 语言，Swift 也提供把其他运算符和赋值运算（<code>=</code>）组合的复合赋值运算符，加赋运算（<code>+=</code>）是其中一个例子：</p>


<pre><code class="lang-swift">var a = 1
a += 2 // a 现在是 3
</code></pre>


<p>表达式<code>a += 2</code>是<code>a = a + 2</code>的简写，一个加赋运算就把加法和赋值两件事完成了。</p>


<blockquote>
<p>注意：</p>
<p>复合赋值运算没有返回值，<code>let b = a += 2</code>这类代码是错误。这不同于上面提到的自增和自减运算符。</p>
</blockquote>


<p>在<a href="../chapter3/04_Expressions.html">表达式</a>章节里有复合运算符的完整列表。
&zwnj;
<a name="comparison_operators"></a></p>


<h2 id="-">比较运算</h2>


<p>所有标准 C 语言中的比较运算都可以在 Swift 中使用。</p>


<ul>
<li>等于（<code>a == b</code>）</li>
<li>不等于（<code>a！= b</code>）</li>
<li>大于（<code>a &gt; b</code>）</li>
<li>小于（<code>a &lt; b</code>）</li>
<li>大于等于（<code>a &gt;= b</code>）</li>
<li>小于等于（<code>a &lt;= b</code>）</li>
</ul>


<blockquote>
<p>注意：</p>
<p>Swift 也提供恒等<code>===</code>和不恒等<code>!==</code>这两个比较符来判断两个对象是否引用同一个对象实例。更多细节在<a href="09_Classes_and_Structures.html">类与结构</a>。</p>
</blockquote>


<p>每个比较运算都返回了一个标识表达式是否成立的布尔值：</p>


<pre><code class="lang-swift">1 == 1   // true, 因为 1 等于 1
2 != 1   // true, 因为 2 不等于 1
2 &gt; 1    // true, 因为 2 大于 1
1 &lt; 2    // true, 因为 1 小于2
1 &gt;= 1   // true, 因为 1 大于等于 1
2 &lt;= 1   // false, 因为 2 并不小于等于 1
</code></pre>


<p>比较运算多用于条件语句，如<code>if</code>条件：</p>


<pre><code class="lang-swift">let name = "world"
if name == "world" {
    println("hello, world")
} else {
    println("I'm sorry \(name), but I don't recognize you")
}
// 输出 "hello, world", 因为 `name` 就是等于 "world"
</code></pre>


<p>关于<code>if</code>语句，请看<a href="05_Control_Flow.html">控制流</a>。</p>


<p><a name="ternary_conditional_operator"></a></p>


<h2 id="-ternary-conditional-operator-">三元条件运算(Ternary Conditional Operator)</h2>


<p>三元条件运算的特殊在于它是有三个操作数的运算符，它的原型是<code>问题？答案1：答案2</code>。它简洁地表达根据<code>问题</code>成立与否作出二选一的操作。如果<code>问题</code>成立，返回<code>答案1</code>的结果; 如果不成立，返回<code>答案2</code>的结果。</p>


<p>使用三元条件运算简化了以下代码：</p>


<pre><code class="lang-swift">if question: {
    answer1
}
else {
    answer2
}
</code></pre>


<p>这里有个计算表格行高的例子。如果有表头，那行高应比内容高度要高出50像素; 如果没有表头，只需高出20像素。</p>


<pre><code class="lang-swift">let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)
// rowHeight 现在是 90
</code></pre>


<p>这样写会比下面的代码简洁：</p>


<pre><code class="lang-swift">let contentHeight = 40
let hasHeader = true
var rowHeight = contentHeight
if hasHeader {
    rowHeight = rowHeight + 50
} else {
    rowHeight = rowHeight + 20
}
// rowHeight 现在是 90
</code></pre>


<p>第一段代码例子使用了三元条件运算，所以一行代码就能让我们得到正确答案。这比第二段代码简洁得多，无需将<code>rowHeight</code>定义成变量，因为它的值无需在<code>if</code>语句中改变。</p>


<p>三元条件运算提供有效率且便捷的方式来表达二选一的选择。需要注意的事，过度使用三元条件运算就会由简洁的代码变成难懂的代码。我们应避免在一个组合语句使用多个三元条件运算符。</p>


<p><a name="range_operators"></a></p>


<h2 id="-">区间运算符</h2>


<p>Swift 提供了两个方便表达一个区间的值的运算符。</p>


<h3 id="-">闭区间运算符</h3>


<p>闭区间运算符（<code>a...b</code>）定义一个包含从<code>a</code>到<code>b</code>(包括<code>a</code>和<code>b</code>)的所有值的区间。
&zwnj;
闭区间运算符在迭代一个区间的所有值时是非常有用的，如在<code>for-in</code>循环中：</p>


<pre><code class="lang-swift">for index in 1...5 {
      println("\(index) * 5 = \(index * 5)")
}
// 1 * 5 = 5
// 2 * 5 = 10
// 3 * 5 = 15
// 4 * 5 = 20
// 5 * 5 = 25
</code></pre>


<p>关于<code>for-in</code>，请看<a href="05_Control_Flow.html">控制流</a>。</p>


<h3 id="-">半闭区间</h3>


<p>半闭区间（<code>a..b</code>）定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间。
之所以称为半闭区间，是因为该区间包含第一个值而不包括最后的值。</p>


<p>半闭区间的实用性在于当你使用一个0始的列表(如数组)时，非常方便地从0数到列表的长度。</p>


<pre><code class="lang-swift">let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..count {
    println("第 \(i + 1) 个人叫 \(names[i])")
}
// 第 1 个人叫 Anna
// 第 2 个人叫 Alex
// 第 3 个人叫 Brian
// 第 4 个人叫 Jack
</code></pre>


<p>数组有4个元素，但<code>0..count</code>只数到3(最后一个元素的下标)，因为它是半闭区间。关于数组，请查阅<a href="04_Collection_Types.html#arrays">数组</a>。</p>


<p><a name="logical_operators"></a></p>


<h2 id="-">逻辑运算</h2>


<p>逻辑运算的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p>


<ul>
<li>逻辑非（<code>!a</code>）</li>
<li>逻辑与（<code>a &amp;&amp; b</code>）</li>
<li>逻辑或（<code>a || b</code>）</li>
</ul>


<h3 id="-">逻辑非</h3>


<p>逻辑非运算（<code>!a</code>）对一个布尔值取反，使得<code>true</code>变<code>false</code>，<code>false</code>变<code>true</code>。</p>


<p>它是一个前置运算符，需出现在操作数之前，且不加空格。读作<code>非 a</code>，然后我们看以下例子：</p>


<pre><code class="lang-swift">let allowedEntry = false
if !allowedEntry {
    println("ACCESS DENIED")
}
// 输出 "ACCESS DENIED"
</code></pre>


<p><code>if！allowedEntry</code>语句可以读作 &#8220;如果 非 alowed entry。&#8221;，接下一行代码只有在如果 &#8220;非 allow entry&#8221; 为<code>true</code>，即<code>allowEntry</code>为<code>false</code>时被执行。</p>


<p>在示例代码中，小心地选择布尔常量或变量有助于代码的可读性，并且避免使用双重逻辑非运算，或混乱的逻辑语句。</p>


<h3 id="-">逻辑与</h3>


<p>逻辑与（<code>a &amp;&amp; b</code>）表达了只有<code>a</code>和<code>b</code>的值都为<code>true</code>时，整个表达式的值才会是<code>true</code>。</p>


<p>只要任意一个值为<code>false</code>，整个表达式的值就为<code>false</code>。事实上，如果第一个值为<code>false</code>，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。这被称做 &#8220;短路计算（short-circuit evaluation）&#8221;。</p>


<p>以下例子，只有两个<code>Bool</code>值都为<code>true</code>值的时候才允许进入：</p>


<pre><code class="lang-swift">let enteredDoorCode = true
let passedRetinaScan = false
if enteredDoorCode &amp;&amp; passedRetinaScan {
    println("Welcome!")
} else {
    println("ACCESS DENIED")
}
// 输出 "ACCESS DENIED"
</code></pre>


<h3 id="-">逻辑或</h3>


<p>逻辑或（<code>a || b</code>）是一个由两个连续的<code>|</code>组成的中置运算符。它表示了两个逻辑表达式的其中一个为<code>true</code>，整个表达式就为<code>true</code>。</p>


<p>同逻辑与运算类似，逻辑或也是&#8221;短路计算&#8221;的，当左端的表达式为<code>true</code>时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。</p>


<p>以下示例代码中，第一个布尔值（<code>hasDoorKey</code>）为<code>false</code>，但第二个值（<code>knowsOverridePassword</code>）为<code>true</code>，所以整个表达是<code>true</code>，于是允许进入：</p>


<pre><code class="lang-swift">let hasDoorKey = false
let knowsOverridePassword = true
if hasDoorKey || knowsOverridePassword {
    println("Welcome!")
} else {
    println("ACCESS DENIED")
}
// 输出 "Welcome!"
</code></pre>


<h3 id="-">组合逻辑</h3>


<p>我们可以组合多个逻辑运算来表达一个复合逻辑：</p>


<pre><code class="lang-swift">if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {
    println("Welcome!")
} else {
    println("ACCESS DENIED")
}
// 输出 "Welcome!"
</code></pre>


<p>这个例子使用了含多个<code>&amp;&amp;</code>和<code>||</code>的复合逻辑。但无论怎样，<code>&amp;&amp;</code>和<code>||</code>始终只能操作两个值。所以这实际是三个简单逻辑连续操作的结果。我们来解读一下：</p>


<p>如果我们输入了正确的密码并通过了视网膜扫描; 或者我们有一把有效的钥匙; 又或者我们知道紧急情况下重置的密码，我们就能把门打开进入。</p>


<p>前两种情况，我们都不满足，所以前两个简单逻辑的结果是<code>false</code>，但是我们是知道紧急情况下重置的密码的，所以整个复杂表达式的值还是<code>true</code>。</p>


<h3 id="-">使用括号来明确优先级</h3>


<p>为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。在上个关于门的权限的例子中，我们给第一个部分加个括号，使用它看起来逻辑更明确：</p>


<pre><code class="lang-swift">if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    println("Welcome!")
} else {
    println("ACCESS DENIED")
}
// 输出 "Welcome!"
</code></pre>


<p>这括号使得前两个值被看成整个逻辑表达中独立的一个部分。虽然有括号和没括号的输出结果是一样的，但对于读代码的人来说有括号的代码更清晰。可读性比简洁性更重要，请在可以让你代码变清晰地地方加个括号吧！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swif协议]]></title>
    <link href="http://baxiang123.com//blog/Swift%E5%8D%8F%E8%AE%AE.html"/>
    <updated>2015-03-15T00:00:00+08:00</updated>
    <id>http://baxiang123.com//blog/Swift协议</id>
    <content type="html"><![CDATA[<p><code>Protocol(协议)</code>用于<strong>统一</strong>方法和属性的名称，而不实现任何功能。<code>协议</code>能够被类，枚举，结构体实现，满足协议要求的类，枚举，结构体被称为协议的<code>遵循者</code>。</p>


<!-- more -->


<p><code>遵循者</code>需要提供<code>协议</code>指定的成员，如属性，方法，操作符，下标等。</p>


<p><a name="protocol_syntax"></a></p>


<h2 id="-">协议的语法</h2>


<p><code>协议</code>的定义与类，结构体，枚举的定义非常相似，如下所示：</p>


<pre><code>protocol SomeProtocol {
    // 协议内容
}
</code></pre>


<p>在类，结构体，枚举的名称后加上<code>协议名称</code>，中间以冒号<code>:</code>分隔即可实现协议；实现多个协议时，各协议之间用逗号<code>,</code>分隔，如下所示：</p>


<pre><code>struct SomeStructure: FirstProtocol, AnotherProtocol {
    // 结构体内容
}
</code></pre>


<p>当某个类含有父类的同时并实现了协议，应当把父类放在所有的协议之前，如下所示：</p>


<pre><code>class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
    // 类的内容
}
</code></pre>


<p><a name="property_requirements"></a></p>


<h2 id="-">属性要求</h2>


<p><code>协议</code>能够要求其<code>遵循者</code>必须含有一些<strong>特定名称和类型</strong>的<code>实例属性(instance property)</code>或<code>类属性 (type property)</code>，也能够要求属性的<code>(设置权限)settable</code> 和<code>(访问权限)gettable</code>，但它不要求<code>属性</code>是<code>存储型属性(stored property)</code>还是<code>计算型属性(calculate property)</code>。</p>


<p>通常前置<code>var</code>关键字将属性声明为变量。在属性声明后写上<code>{ get set }</code>表示属性为可读写的。<code>{ get }</code>用来表示属性为可读的。即使你为可读的属性实现了<code>setter</code>方法，它也不会出错。</p>


<pre><code>protocol SomeProtocol {
    var musBeSettable : Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</code></pre>


<p>用类来实现协议时，使用<code>class</code>关键字来表示该属性为类成员；用结构体或枚举实现协议时，则使用<code>static</code>关键字来表示：</p>


<pre><code>protocol AnotherProtocol {
    class var someTypeProperty: Int { get set }
}

protocol FullyNamed {
    var fullName: String { get }
}
</code></pre>


<p><code>FullyNamed</code>协议含有<code>fullName</code>属性。因此其<code>遵循者</code>必须含有一个名为<code>fullName</code>，类型为<code>String</code>的可读属性。</p>


<pre><code>struct Person: FullyNamed{
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
//john.fullName 为 "John Appleseed"
</code></pre>


<p><code>Person</code>结构体含有一个名为<code>fullName</code>的<code>存储型属性</code>，完整的<code>遵循</code>了协议。(<em>若协议未被完整遵循，编译时则会报错</em>)。</p>


<p>如下所示，<code>Startship</code>类<code>遵循</code>了<code>FullyNamed</code>协议：</p>


<pre><code>class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: Stirng? = nil ) {
        self.anme = name
        self.prefix = prefix
    }
    var fullName: String {
    return (prefix ? prefix ! + " " : " ") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName == "USS Enterprise"
</code></pre>


<p><code>Starship</code>类将<code>fullName</code>实现为可读的<code>计算型属性</code>。它的每一个实例都有一个名为<code>name</code>的必备属性和一个名为<code>prefix</code>的可选属性。 当<code>prefix</code>存在时，将<code>prefix</code>插入到<code>name</code>之前来为<code>Starship</code>构建<code>fullName</code>。</p>


<p><a name="method_requirements"></a></p>


<h2 id="-">方法要求</h2>


<p><code>协议</code>能够要求其<code>遵循者</code>必备某些特定的<code>实例方法</code>和<code>类方法</code>。协议方法的声明与普通方法声明相似，但它不需要<code>方法</code>内容。</p>


<blockquote>
<p>注意：</p>
<p>协议方法支持<code>变长参数(variadic parameter)</code>，不支持<code>默认参数(default parameter)</code>。</p>
</blockquote>


<p>前置<code>class</code>关键字表示协议中的成员为<code>类成员</code>；当协议用于被<code>枚举</code>或<code>结构体</code>遵循时，则使用<code>static</code>关键字。如下所示：</p>


<pre><code>protocol SomeProtocol {
    class func someTypeMethod()
}

protocol RandomNumberGenerator {
    func random() -&gt; Double
}
</code></pre>


<p><code>RandomNumberGenerator</code>协议要求其<code>遵循者</code>必须拥有一个名为<code>random</code>， 返回值类型为<code>Double</code>的实例方法。(我们假设随机数在[0，1]区间内)。</p>


<p><code>LinearCongruentialGenerator</code>类<code>遵循</code>了<code>RandomNumberGenerator</code>协议，并提供了一个叫做<em>线性同余生成器(linear congruential generator)</em>的伪随机数算法。</p>


<pre><code>class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
println("Here's a random number: \(generator.random())")
// 输出 : "Here's a random number: 0.37464991998171"
println("And another one: \(generator.random())")
// 输出 : "And another one: 0.729023776863283"
</code></pre>


<p><a name="mutating_method_requirements"></a></p>


<h2 id="-">突变方法要求</h2>


<p>能在<code>方法</code>或<code>函数</code>内部改变实例类型的方法称为<code>突变方法</code>。在<code>值类型(Value Type)</code>(<em>译者注：特指结构体和枚举</em>)中的的<code>函数</code>前缀加上<code>mutating</code>关键字来表示该函数允许改变该实例和其属性的类型。 这一变换过程在<a href="11_Methods.html#instance_methods">实例方法(Instance Methods)</a>章节中有详细描述。</p>


<p>(<em>译者注：类中的成员为<code>引用类型(Reference Type)</code>，可以方便的修改实例及其属性的值而无需改变类型；而<code>结构体</code>和<code>枚举</code>中的成员均为<code>值类型(Value Type)</code>，修改变量的值就相当于修改变量的类型，而<code>Swift</code>默认不允许修改类型，因此需要前置<code>mutating</code>关键字用来表示该<code>函数</code>中能够修改类型</em>)</p>


<blockquote>
<p>注意：</p>
<p>用<code>class</code>实现协议中的<code>mutating</code>方法时，不用写<code>mutating</code>关键字；用<code>结构体</code>，<code>枚举</code>实现协议中的<code>mutating</code>方法时，必须写<code>mutating</code>关键字。</p>
</blockquote>


<p>如下所示，<code>Togglable</code>协议含有<code>toggle</code>函数。根据函数名称推测，<code>toggle</code>可能用于<strong>切换或恢复</strong>某个属性的状态。<code>mutating</code>关键字表示它为<code>突变方法</code>：</p>


<pre><code>protocol Togglable {
    mutating func toggle()
}
</code></pre>


<p>当使用<code>枚举</code>或<code>结构体</code>来实现<code>Togglabl</code>协议时，必须在<code>toggle</code>方法前加上<code>mutating</code>关键字。</p>


<p>如下所示，<code>OnOffSwitch</code>枚举<code>遵循</code>了<code>Togglable</code>协议，<code>On</code>，<code>Off</code>两个成员用于表示当前状态</p>


<pre><code>enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = On
        case On:
            self = Off
        }
    }
}
var lightSwitch = OnOffSwitch.Off
lightSwitch.toggle()
//lightSwitch 现在的值为 .On
</code></pre>


<p><a name="protocols_as_types"></a></p>


<h2 id="-">协议类型</h2>


<p><code>协议</code>本身不实现任何功能，但你可以将它当做<code>类型</code>来使用。</p>


<p>使用场景：</p>


<ul>
<li>作为函数，方法或构造器中的参数类型，返回值类型</li>
<li>作为常量，变量，属性的类型</li>
<li>作为数组，字典或其他容器中的元素类型</li>
</ul>


<blockquote>
<p>注意：</p>
<p>协议类型应与其他类型(Int，Double，String)的写法相同，使用驼峰式</p>
</blockquote>


<pre><code>class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) +1
    }
}
</code></pre>


<p>这里定义了一个名为 <code>Dice</code>的类，用来代表桌游中的N个面的骰子。</p>


<p> <code>Dice</code>含有<code>sides</code>和<code>generator</code>两个属性，前者用来表示骰子有几个面，后者为骰子提供一个随机数生成器。由于后者为<code>RandomNumberGenerator</code>的协议类型。所以它能够被赋值为任意<code>遵循</code>该协议的类型。</p>


<p>此外，使用<code>构造器(init)</code>来代替之前版本中的<code>setup</code>操作。构造器中含有一个名为<code>generator</code>，类型为<code>RandomNumberGenerator</code>的形参，使得它可以接收任意遵循<code>RandomNumberGenerator</code>协议的类型。</p>


<p><code>roll</code>方法用来模拟骰子的面值。它先使用<code>generator</code>的<code>random</code>方法来创建一个[0-1]区间内的随机数种子，然后加工这个随机数种子生成骰子的面值。</p>


<p>如下所示，<code>LinearCongruentialGenerator</code>的实例作为随机数生成器传入<code>Dice</code>的<code>构造器</code></p>


<pre><code>var d6 = Dice(sides: 6,generator: LinearCongruentialGenerator())
for _ in 1...5 {
    println("Random dice roll is \(d6.roll())")
}
//输出结果
//Random dice roll is 3
//Random dice roll is 5
//Random dice roll is 4
//Random dice roll is 5
//Random dice roll is 4
</code></pre>


<p><a name="delegation"></a></p>


<h2 id="-">委托(代理)模式</h2>


<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能<code>交由(委托)</code>给其他的类型。</p>


<p>委托模式的实现很简单： 定义<code>协议</code>来<code>封装</code>那些需要被委托的<code>函数和方法</code>， 使其<code>遵循者</code>拥有这些被委托的<code>函数和方法</code>。</p>


<p>委托模式可以用来响应特定的动作或接收外部数据源提供的数据，而无需要知道外部数据源的类型。</p>


<p>下文是两个基于骰子游戏的协议：</p>


<pre><code>protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(game: DiceGame)
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int)
    func gameDidEnd(game: DiceGame)
}
</code></pre>


<p><code>DiceGame</code>协议可以在任意含有骰子的游戏中实现，<code>DiceGameDelegate</code>协议可以用来追踪<code>DiceGame</code>的游戏过程。</p>


<p>如下所示，<code>SnakesAndLadders</code>是<code>Snakes and Ladders</code>(译者注：<a href="05_Control_Flow.html">控制流</a>章节有该游戏的详细介绍)游戏的新版本。新版本使用<code>Dice</code>作为骰子，并且实现了<code>DiceGame</code>和<code>DiceGameDelegate</code>协议</p>


<pre><code>class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dic = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: Int[]
    init() {
        board = Int[](count: finalSquare + 1, repeatedValue: 0)
        board[03] = +08; board[06] = +11; borad[09] = +09; board[10] = +02
        borad[14] = -10; board[19] = -11; borad[22] = -02; board[24] = -08
    }
     var delegate: DiceGameDelegate?
     func play() {
         square = 0
         delegate?.gameDidStart(self)
         gameLoop: while square != finalSquare {
             let diceRoll = dice.roll()
             delegate?.game(self,didStartNewTurnWithDiceRoll: diceRoll)
             switch square + diceRoll {
             case finalSquare:
                 break gameLoop
             case let newSquare where newSquare &gt; finalSquare:
                 continue gameLoop
             default:
             square += diceRoll
             square += board[square]
             }
         }
         delegate?.gameDIdEnd(self)
     }
}
</code></pre>


<p>游戏的<code>初始化设置(setup)</code>被<code>SnakesAndLadders</code>类的<code>构造器(initializer)</code>实现。所有的游戏逻辑被转移到了<code>play</code>方法中。</p>


<blockquote>
<p>注意：</p>
<p>因为<code>delegate</code>并不是该游戏的必备条件，<code>delegate</code>被定义为遵循<code>DiceGameDelegate</code>协议的可选属性</p>
</blockquote>


<p><code>DicegameDelegate</code>协议提供了三个方法用来追踪游戏过程。被放置于游戏的逻辑中，即<code>play()</code>方法内。分别在游戏开始时，新一轮开始时，游戏结束时被调用。</p>


<p>因为<code>delegate</code>是一个遵循<code>DiceGameDelegate</code>的可选属性，因此在<code>play()</code>方法中使用了<code>可选链</code>来调用委托方法。 若<code>delegate</code>属性为<code>nil</code>， 则委托调用<em>优雅地</em>失效。若<code>delegate</code>不为<code>nil</code>，则委托方法被调用</p>


<p>如下所示，<code>DiceGameTracker</code>遵循了<code>DiceGameDelegate</code>协议</p>


<pre><code>class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            println("Started a new game of Snakes and Ladders")
        }
        println("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        ++numberOfTurns
        println("Rolled a \(diceRoll)")
    }
    func gameDidEnd(game: DiceGame) {
        println("The game lasted for \(numberOfTurns) turns")
    }
}
</code></pre>


<p><code>DiceGameTracker</code>实现了<code>DiceGameDelegate</code>协议的方法要求，用来记录游戏已经进行的轮数。 当游戏开始时，<code>numberOfTurns</code>属性被赋值为0；在每新一轮中递加；游戏结束后，输出打印游戏的总轮数。</p>


<p><code>gameDidStart</code>方法从<code>game</code>参数获取游戏信息并输出。<code>game</code>在方法中被当做<code>DiceGame</code>类型而不是<code>SnakeAndLadders</code>类型，所以方法中只能访问<code>DiceGame</code>协议中的成员。</p>


<p><code>DiceGameTracker</code>的运行情况，如下所示：</p>


<pre><code>“let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns”
</code></pre>


<p><a name="adding_protocol_conformance_with_an_extension"></a></p>


<h2 id="-">在扩展中添加协议成员</h2>


<p>即便无法修改源代码，依然可以通过<code>扩展(Extension)</code>来扩充已存在类型(<em>译者注： 类，结构体，枚举等</em>)。<code>扩展</code>可以为已存在的类型添加<code>属性</code>，<code>方法</code>，<code>下标</code>，<code>协议</code>等成员。详情请在<a href="20_Extensions.html">扩展</a>章节中查看。</p>


<blockquote>
<p>注意：</p>
<p>通过<code>扩展</code>为已存在的类型<code>遵循</code>协议时，该类型的所有实例也会随之添加协议中的方法</p>
</blockquote>


<p><code>TextRepresentable</code>协议含有一个<code>asText</code>，如下所示：</p>


<pre><code>protocol TextRepresentable {
    func asText() -&gt; String
}
</code></pre>


<p>通过<code>扩展</code>为上一节中提到的<code>Dice</code>类遵循<code>TextRepresentable</code>协议</p>


<pre><code>extension Dice: TextRepresentable {
    cun asText() -&gt; String {
        return "A \(sides)-sided dice"
    }
}
</code></pre>


<p>从现在起，<code>Dice</code>类型的实例可被当作<code>TextRepresentable</code>类型：</p>


<pre><code>let d12 = Dice(sides: 12,generator: LinearCongruentialGenerator())
println(d12.asText())
// 输出 "A 12-sided dice"
</code></pre>


<p><code>SnakesAndLadders</code>类也可以通过<code>扩展</code>的方式来遵循协议：</p>


<pre><code>extension SnakeAndLadders: TextRepresentable {
    func asText() -&gt; String {
        return "A game of Snakes and Ladders with \(finalSquare) squares"
    }
}
println(game.asText())
// 输出 "A game of Snakes and Ladders with 25 squares"
</code></pre>


<p><a name="declaring_protocol_adoption_with_an_extension"></a></p>


<h2 id="-">通过延展补充协议声明</h2>


<p>当一个类型已经实现了协议中的所有要求，却没有声明时，可以通过<code>扩展</code>来补充协议声明：</p>


<pre><code>struct Hamster {
    var name: String
    func asText() -&gt; String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentabl {}
</code></pre>


<p>从现在起，<code>Hamster</code>的实例可以作为<code>TextRepresentable</code>类型使用</p>


<pre><code>let simonTheHamster = Hamster(name: "Simon")
let somethingTextRepresentable: TextRepresentabl = simonTheHamester
println(somethingTextRepresentable.asText())
// 输出 "A hamster named Simon"
</code></pre>


<blockquote>
<p>注意：</p>
<p>即时满足了协议的所有要求，类型也不会自动转变，因此你必须为它做出明显的协议声明</p>
</blockquote>


<p><a name="collections_of_protocol_types"></a></p>


<h2 id="-">集合中的协议类型</h2>


<p>协议类型可以被集合使用，表示集合中的元素均为协议类型：</p>


<pre><code>let things: TextRepresentable[] = [game,d12,simoTheHamster]
</code></pre>


<p>如下所示，<code>things</code>数组可以被直接遍历，并调用其中元素的<code>asText()</code>函数：</p>


<pre><code>for thing in things {
    println(thing.asText())
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
</code></pre>


<p><code>thing</code>被当做是<code>TextRepresentable</code>类型而不是<code>Dice</code>，<code>DiceGame</code>，<code>Hamster</code>等类型。因此能且仅能调用<code>asText</code>方法</p>


<p><a name="protocol_inheritance"></a></p>


<h2 id="-">协议的继承</h2>


<p>协议能够<em>继承</em>一到多个其他协议。语法与类的继承相似，多个协议间用逗号<code>,</code>分隔</p>


<pre><code>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 协议定义
}
</code></pre>


<p>如下所示，<code>PrettyTextRepresentable</code>协议继承了<code>TextRepresentable</code>协议</p>


<pre><code>protocol PrettyTextRepresentable: TextRepresentable {
    func asPrettyText() -&gt; String
}
</code></pre>


<p><code>遵循``PrettyTextRepresentable</code>协议的同时，也需要<code>遵循</code>TextRepresentable`协议。</p>


<p>如下所示，用<code>扩展</code>为<code>SnakesAndLadders</code>遵循<code>PrettyTextRepresentable</code>协议：</p>


<pre><code>extension SnakesAndLadders: PrettyTextRepresentable {
    func asPrettyText() -&gt; String {
        var output = asText() + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
                case let ladder where ladder &gt; 0:
                output += "▲ "
            case let snake where snake &lt; 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}
</code></pre>


<p>在<code>for in</code>中迭代出了<code>board</code>数组中的每一个元素：</p>


<ul>
<li>当从数组中迭代出的元素的值大于0时，用<code>▲</code>表示</li>
<li>当从数组中迭代出的元素的值小于0时，用<code>▼</code>表示</li>
<li>当从数组中迭代出的元素的值等于0时，用<code>○</code>表示</li>
</ul>


<p>任意<code>SankesAndLadders</code>的实例都可以使用<code>asPrettyText()</code>方法。</p>


<pre><code>println(game.asPrettyText())
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
</code></pre>


<p><a name="protocol_composition"></a></p>


<h2 id="-">协议合成</h2>


<p>一个协议可由多个协议采用<code>protocol&lt;SomeProtocol, AnotherProtocol&gt;</code>这样的格式进行组合，称为<code>协议合成(protocol composition)</code>。</p>


<p>举个例子：</p>


<pre><code>protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(celebrator: protocol&lt;Named, Aged&gt;) {
    println("Happy birthday \(celebrator.name) - you're \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Malcolm", age: 21)
wishHappyBirthday(birthdayPerson)
// 输出 "Happy birthday Malcolm - you're 21!
</code></pre>


<p><code>Named</code>协议包含<code>String</code>类型的<code>name</code>属性；<code>Aged</code>协议包含<code>Int</code>类型的<code>age</code>属性。<code>Person</code>结构体<code>遵循</code>了这两个协议。</p>


<p><code>wishHappyBirthday</code>函数的形参<code>celebrator</code>的类型为<code>protocol&lt;Named,Aged&gt;</code>。可以传入任意<code>遵循</code>这两个协议的类型的实例</p>


<blockquote>
<p>注意：</p>
<p><code>协议合成</code>并不会生成一个新协议类型，而是将多个协议合成为一个临时的协议，超出范围后立即失效。</p>
</blockquote>


<p><a name="checking_for_protocol_conformance"></a></p>


<h2 id="-">检验协议的一致性</h2>


<p>使用<code>is</code>检验协议一致性，使用<code>as</code>将协议类型<code>向下转换(downcast)</code>为的其他协议类型。检验与转换的语法和之前相同(<em>详情查看<a href="18_Type_Casting.html">类型检查</a></em>)：</p>


<ul>
<li><code>is</code>操作符用来检查实例是否<code>遵循</code>了某个<code>协议</code>。</li>
<li><code>as?</code>返回一个可选值，当实例<code>遵循</code>协议时，返回该协议类型；否则返回<code>nil</code></li>
<li><code>as</code>用以强制向下转换型。</li>
</ul>


<pre><code>@objc protocol HasArea {
    var area: Double { get }
}
</code></pre>


<blockquote>
<p>注意：</p>
<p><code>@objc</code>用来表示协议是可选的，也可以用来表示暴露给<code>Objective-C</code>的代码，此外，<code>@objc</code>型协议只对<code>类</code>有效，因此只能在<code>类</code>中检查协议的一致性。详情查看<em><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank">Using Siwft with Cocoa and Objectivei-c</a></em>。</p>
</blockquote>


<pre><code>class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area:≈radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}
</code></pre>


<p><code>Circle</code>和<code>Country</code>都遵循了<code>HasArea</code>协议，前者把<code>area</code>写为计算型属性（computed property），后者则把<code>area</code>写为存储型属性（stored property）。</p>


<p>如下所示，<code>Animal</code>类没有实现任何协议</p>


<pre><code>class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
</code></pre>


<p><code>Circle,Country,Animal</code>并没有一个相同的基类，所以采用<code>AnyObject</code>类型的数组来装载在他们的实例，如下所示：</p>


<pre><code>let objects: AnyObject[] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]
</code></pre>


<p>如下所示，在迭代时检查<code>object</code>数组的元素是否<code>遵循</code>了<code>HasArea</code>协议：</p>


<pre><code>for object in objects {
    if let objectWithArea = object as? HasArea {
        println("Area is \(objectWithArea.area)")
    } else {
        println("Something that doesn't have an area")
    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn't have an area
</code></pre>


<p>当数组中的元素遵循<code>HasArea</code>协议时，通过<code>as?</code>操作符将其<code>可选绑定(optional binding)</code>到<code>objectWithArea</code>常量上。</p>


<p><code>objects</code>数组中元素的类型并不会因为<code>向下转型</code>而改变，当它们被赋值给<code>objectWithArea</code>时只被视为<code>HasArea</code>类型，因此只有<code>area</code>属性能够被访问。</p>


<p><a name="optional_protocol_requirements"></a></p>


<h2 id="-">可选协议要求</h2>


<p>可选协议含有可选成员，其<code>遵循者</code>可以选择是否实现这些成员。在协议中使用<code>@optional</code>关键字作为前缀来定义可选成员。</p>


<p>可选协议在调用时使用<code>可选链</code>，详细内容在<a href="17_Optional_Chaining.html">可选链</a>章节中查看。</p>


<p>像<code>someOptionalMethod?(someArgument)</code>一样，你可以在可选方法名称后加上<code>?</code>来检查该方法是否被实现。<code>可选方法</code>和<code>可选属性</code>都会返回一个<code>可选值(optional value)</code>，当其不可访问时，<code>?</code>之后语句不会执行，并返回<code>nil</code>。</p>


<blockquote>
<p>注意：</p>
<p>可选协议只能在含有<code>@objc</code>前缀的协议中生效。且<code>@objc</code>的协议只能被<code>类</code>遵循。</p>
</blockquote>


<p><code>Counter</code>类使用<code>CounterDataSource</code>类型的外部数据源来提供<code>增量值(increment amount)</code>，如下所示：</p>


<pre><code>@objc protocol CounterDataSource {
    @optional func incrementForCount(count: Int) -&gt; Int
    @optional var fixedIncrement: Int { get }
}
</code></pre>


<p><code>CounterDataSource</code>含有<code>incrementForCount</code>的<code>可选方法</code>和<code>fiexdIncrement</code>的<code>可选属性</code>。</p>


<blockquote>
<p>注意：</p>
<p><code>CounterDataSource</code>中的属性和方法都是可选的，因此可以在类中声明但不实现这些成员，尽管技术上允许这样做，不过最好不要这样写。</p>
</blockquote>


<p><code>Counter</code>类含有<code>CounterDataSource?</code>类型的可选属性<code>dataSource</code>，如下所示：</p>


<pre><code>@objc class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement? {
            count += amount
        }
    }
}
</code></pre>


<p><code>count</code>属性用于存储当前的值，<code>increment</code>方法用来为<code>count</code>赋值。</p>


<p><code>increment</code>方法通过<code>可选链</code>，尝试从两种<code>可选成员</code>中获取<code>count</code>。</p>


<ol>
<li>由于<code>dataSource</code>可能为<code>nil</code>，因此在<code>dataSource</code>后边加上了<code>?</code>标记来表明只在<code>dataSource</code>非空时才去调用incrementForCount`方法。</li>
<li>即使<code>dataSource</code>存在，但是也无法保证其是否实现了<code>incrementForCount</code>方法，因此在<code>incrementForCount</code>方法后边也加有<code>?</code>标记。</li>
</ol>


<p>在调用<code>incrementForCount</code>方法后，<code>Int</code>型<code>可选值</code>通过<code>可选绑定(optional binding)</code>自动拆包并赋值给常量<code>amount</code>。</p>


<p>当<code>incrementForCount</code>不能被调用时，尝试使用<code>可选属性``fixedIncrement</code>来代替。</p>


<p><code>ThreeSource</code>实现了<code>CounterDataSource</code>协议，如下所示：</p>


<pre><code>class ThreeSource: CounterDataSource {
    let fixedIncrement = 3
}
</code></pre>


<p>使用<code>ThreeSource</code>作为数据源开实例化一个<code>Counter</code>：</p>


<pre><code>var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    println(counter.count)
}
// 3
// 6
// 9
// 12
</code></pre>


<p><code>TowardsZeroSource</code>实现了<code>CounterDataSource</code>协议中的<code>incrementForCount</code>方法，如下所示：</p>


<pre><code>class TowardsZeroSource: CounterDataSource {
func incrementForCount(count: Int) -&gt; Int {
        if count == 0 {
            return 0
        } else if count &lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
</code></pre>


<p>下边是执行的代码：</p>


<pre><code>counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    println(counter.count)
}
// -3
// -2
// -1
// 0
// 0
</code></pre>

]]></content>
  </entry>
  
</feed>
